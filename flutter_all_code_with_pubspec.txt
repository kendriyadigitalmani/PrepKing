===== FILE: pubspec.yaml =====

name: prepking
description: A modern, animated learning app â€“ PrepKing
publish_to: "none"
version: 1.0.0+4

environment:
  sdk: ">=3.4.0 <4.0.0"
  flutter: ">=3.22.0"

dependencies:
  flutter:
    sdk: flutter

  # Core & State Management
  flutter_riverpod: ^2.6.1
  go_router: ^14.8.1

  # Networking
  dio: ^5.7.0
  retrofit: ^4.4.1
  json_annotation: ^4.9.0

  # UI & Animations
  lottie: ^3.1.2
  animate_do: ^3.3.9
  google_fonts: ^6.2.1
  flutter_svg: ^2.0.10+1
  cached_network_image: ^3.4.1
  shimmer: ^3.0.0
  confetti: ^0.8.0

  # Utils
  share_plus: ^12.0.1
  screenshot: ^3.0.0
  path_provider: ^2.1.4
  shared_preferences: ^2.3.2
  intl: ^0.20.2
  uuid: ^4.5.0
  vibration: ^3.1.4
  cupertino_icons: ^1.0.8

  # Firebase
  firebase_core: ^3.6.0
  firebase_auth: ^5.3.1
  google_sign_in: ^6.2.1

  # Content Viewers
  flutter_html: ^3.0.0-beta.1
  flutter_markdown: ^0.7.7+1
  youtube_player_flutter: ^9.1.3

  # Syncfusion PDF Viewer - Upgraded to latest (supports intl 0.20+)
  syncfusion_flutter_pdfviewer: ^31.2.18  # Or simply "^31.0.0" to get the absolute latest

  # URL Launcher
  url_launcher: ^6.3.1

  just_audio: ^0.9.39
  rxdart: ^0.27.7
  flutter_tts: ^4.0.2
  package_info_plus: ^8.0.2

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0

  # Code Generation
  build_runner: ^2.4.13
  retrofit_generator: ^10.2.0
  json_serializable: ^6.8.0

  freezed: ^3.2.3
  freezed_annotation: ^3.1.0

  # Icons & Splash
  flutter_native_splash: ^2.4.1
  flutter_launcher_icons: ^0.14.1

flutter:
  uses-material-design: true

  assets:
    - assets/images/
    - assets/lottie/
    - assets/lottie/trophy.json
    - assets/lottie/sad.json
    - assets/lottie/splash.json

# Native Splash Configuration
flutter_native_splash:
  color: "#6C5CE7"
  image: assets/images/logo.png
  android: true
  ios: true
  android_12:
    image: assets/images/logo.png
    color: "#6C5CE7"
  fill: true
  fullscreen: true

# App Icons Configuration
flutter_launcher_icons:
  android: true
  ios: true
  image_path: "assets/images/logo.png"
  adaptive_icon_background: "#6C5CE7"
  adaptive_icon_foreground: "assets/images/logo.png"
  android_generate_legacy_files: true



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\main.dart =====

// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ SCREENS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import 'screens/home/home_screen.dart';
import 'screens/profile/profile_screen.dart';
import 'screens/quizzes/quizzes_screen.dart';
import 'screens/quizzes/daily_quizzes_screen.dart';
import 'screens/quizzes/quiz_detail_screen.dart';
import 'screens/quizzes/standard_quiz_player_screen.dart';
import 'screens/quizzes/instant_quiz_player_screen.dart';
import 'screens/quizzes/quiz_result_screen.dart';
import 'screens/quizzes/quiz_review_screen.dart';
import 'screens/splash_screen.dart';
import 'screens/onboarding_screen.dart';
import 'screens/login_screen.dart';
import 'screens/leaderboard/leaderboard_screen.dart';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ COURSES SCREENS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import 'screens/courses/course_list_screen.dart';
import 'screens/courses/course_detail_screen.dart';
import 'screens/courses/content_list_screen.dart';
import 'screens/courses/contents/pdf_content_screen.dart';
import 'screens/courses/contents/quiz_content_screen.dart';
import 'screens/courses/contents/text_content_screen.dart';
import 'screens/courses/contents/video_content_screen.dart';
import 'screens/courses/contents/audio_player_screen.dart';
import 'screens/courses/contents/text_audio_player_screen.dart'; // â† NEW IMPORT

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ PROFILE SUB-SCREENS (REAL IMPLEMENTATIONS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import 'screens/profile/edit_profile_screen.dart';
import 'screens/profile/certificates_screen.dart';
import 'screens/profile/quiz_history_screen.dart';
import 'screens/profile/coin_store_screen.dart';
import 'screens/profile/help_support_screen.dart';
import 'screens/profile/about_prepking_screen.dart';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ SETTINGS SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import 'screens/profile/settings_screen.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  // ðŸ”¥ REMOVED: await Firebase.initializeApp();
  // Firebase is now initialized asynchronously in app_init_provider.dart
  // This allows instant splash screen rendering and better cold start performance
  runApp(const ProviderScope(child: PrepKingApp()));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ ROUTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final routerProvider = Provider<GoRouter>((ref) {
  return GoRouter(
    initialLocation: '/splash',
    redirect: (_, __) => null,
    debugLogDiagnostics: false,
    routes: [
      GoRoute(path: '/splash', builder: (_, __) => const SplashScreen()),
      GoRoute(path: '/login', builder: (_, __) => const LoginScreen()),
      GoRoute(path: '/login/email', builder: (_, __) => const EmailLoginScreen()),
      GoRoute(path: '/onboarding', builder: (_, __) => const OnboardingScreen()),
      ShellRoute(
        builder: (context, state, child) => MainScaffold(child: child),
        routes: [
          GoRoute(
              path: '/home',
              pageBuilder: (_, __) => const NoTransitionPage(child: HomeScreen())),
          GoRoute(
            path: '/courses',
            pageBuilder: (_, __) =>
            const NoTransitionPage(child: CourseListScreen()),
            routes: [
              GoRoute(
                path: 'detail/:id',
                builder: (context, state) {
                  final idStr = state.pathParameters['id']!;
                  final id = int.tryParse(idStr);
                  if (id == null) {
                    return Scaffold(
                        body: Center(child: Text('Invalid course ID: $idStr')));
                  }
                  return CourseDetailScreen(courseId: id);
                },
              ),
              GoRoute(
                path: 'content/text',
                builder: (context, state) =>
                    TextContentScreen(content: state.extra as Map<String, dynamic>),
              ),
              GoRoute(
                path: 'content/video',
                builder: (context, state) =>
                    VideoContentScreen(content: state.extra as Map<String, dynamic>),
              ),
              GoRoute(
                path: 'content/pdf',
                builder: (context, state) =>
                    PdfContentScreen(content: state.extra as Map<String, dynamic>),
              ),
              GoRoute(
                path: 'content/quiz',
                builder: (context, state) =>
                    QuizContentScreen(content: state.extra as Map<String, dynamic>),
              ),
              GoRoute(
                path: 'content/audio',
                builder: (context, state) =>
                    AudioPlayerScreen(content: state.extra as Map<String, dynamic>),
              ),
              // â† NEW ROUTE FOR TEXT-TO-SPEECH PLAYER
              GoRoute(
                path: 'content/text-audio',
                builder: (context, state) {
                  final data = state.extra as Map<String, dynamic>;
                  return TextAudioPlayerScreen(
                    title: data['title'] as String,
                    text: data['text'] as String,
                  );
                },
              ),
              GoRoute(
                path: 'content/:courseId',
                builder: (context, state) {
                  final idStr = state.pathParameters['courseId']!;
                  final courseId = int.tryParse(idStr);
                  if (courseId == null) {
                    return Scaffold(
                      body: Center(child: Text('Invalid course ID: "$idStr"')),
                    );
                  }
                  return ContentListScreen(courseId: courseId);
                },
              ),
            ],
          ),
          GoRoute(
              path: '/quizzes',
              pageBuilder: (_, __) =>
              const NoTransitionPage(child: QuizzesScreen())),
          GoRoute(
            path: '/quizzes/daily',
            pageBuilder: (_, __) =>
            const NoTransitionPage(child: DailyQuizzesScreen()),
          ),
          GoRoute(
              path: '/leaderboard',
              pageBuilder: (_, __) =>
              const NoTransitionPage(child: LeaderboardScreen())),
          GoRoute(
            path: '/profile',
            pageBuilder: (_, __) =>
            const NoTransitionPage(child: ProfileScreen()),
            routes: [
              GoRoute(
                  path: 'certificates',
                  builder: (_, __) => const CertificatesScreen()),
              GoRoute(
                  path: 'history', builder: (_, __) => const QuizHistoryScreen()),
              GoRoute(
                  path: 'edit', builder: (_, __) => const EditProfileScreen()),
              GoRoute(
                  path: 'settings',
                  builder: (_, __) => const SettingsScreen()),
              GoRoute(path: 'coins', builder: (_, __) => const CoinStoreScreen()),
              GoRoute(path: 'help', builder: (_, __) => const HelpSupportScreen()),
              GoRoute(path: 'about', builder: (_, __) => const AboutPrepKingScreen()),
            ],
          ),
        ],
      ),
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€ Standalone routes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      GoRoute(
          path: '/quizzes/detail',
          builder: (context, state) =>
              QuizDetailScreen(quiz: state.extra as Map<String, dynamic>)),
      GoRoute(
          path: '/q/:slug',
          builder: (context, state) => Scaffold(
              body: Center(
                  child: Text('Loading quiz: ${state.pathParameters['slug']}')))),
      GoRoute(path: '/quizzes/instant-player', builder: (context, state) {
        final extra = state.extra as Map<String, dynamic>;
        return InstantQuizPlayerScreen(
            quiz: extra['quiz'], attemptId: extra['attempt_id']);
      }),
      GoRoute(path: '/quizzes/standard-player', builder: (context, state) {
        final extra = state.extra as Map<String, dynamic>;
        return StandardQuizPlayerScreen(
            quiz: extra['quiz'], attemptId: extra['attempt_id']);
      }),
      GoRoute(
          path: '/quizzes/result',
          builder: (context, state) =>
              QuizResultScreen(result: state.extra as Map<String, dynamic>)),
      GoRoute(path: '/quiz-review', builder: (context, state) {
        final extra = state.extra as Map<String, dynamic>?;
        final attemptId = extra?['attemptId'] ?? extra?['attempt_id'] ?? 0;
        final testName = extra?['testName'] ?? extra?['quiz_title'];
        if (attemptId <= 0) {
          return const Scaffold(
              body: Center(
                  child: Text('Invalid Attempt ID',
                      style: TextStyle(color: Colors.red))));
        }
        return QuizReviewScreen(attemptId: attemptId, testName: testName);
      }),
      GoRoute(path: '/certificate', builder: (context, state) {
        final extra = state.extra as Map<String, dynamic>?;
        final courseId = extra?['courseId'];
        return Scaffold(
          appBar: AppBar(
              title: const Text("Certificate"),
              backgroundColor: const Color(0xFF6C5CE7)),
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Lottie.asset('assets/lottie/certificate.json', width: 200),
                const SizedBox(height: 20),
                Text("Congratulations!",
                    style: GoogleFonts.poppins(
                        fontSize: 28, fontWeight: FontWeight.bold)),
                Text("Course ID: $courseId Completed!",
                    style: GoogleFonts.poppins(fontSize: 18)),
              ],
            ),
          ),
        );
      }),
    ],
  );
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ APP & SCAFFOLD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class PrepKingApp extends ConsumerWidget {
  const PrepKingApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp.router(
      title: 'PrepKing',
      debugShowCheckedModeBanner: false,
      routerConfig: ref.watch(routerProvider),
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xFF6C5CE7)),
        useMaterial3: true,
        fontFamily: GoogleFonts.poppins().fontFamily,
      ),
    );
  }
}

class MainScaffold extends ConsumerStatefulWidget {
  final Widget child;
  const MainScaffold({super.key, required this.child});

  @override
  ConsumerState<MainScaffold> createState() => _MainScaffoldState();
}

class _MainScaffoldState extends ConsumerState<MainScaffold> {
  int _currentIndex = 0;
  final List<String> _locations = [
    '/home',
    '/courses',
    '/quizzes',
    '/leaderboard',
    '/profile'
  ];
  DateTime? _lastBackPressTime;

  Future<bool> _onWillPop() async {
    final now = DateTime.now();
    if (_currentIndex != 0) return true;
    if (_lastBackPressTime == null ||
        now.difference(_lastBackPressTime!) > const Duration(seconds: 2)) {
      _lastBackPressTime = now;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text('Press back again to exit'),
            backgroundColor: Color(0xFF6C5CE7)),
      );
      return false;
    }
    return true;
  }

  @override
  Widget build(BuildContext context) {
    final location = GoRouterState.of(context).uri.toString();
    // Sync bottom navigation index with current route
    final index = _locations.indexWhere((path) => location.startsWith(path));
    if (index != -1 && index != _currentIndex) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          setState(() => _currentIndex = index);
        }
      });
    }
    // Hide bottom bar when viewing the audio player screen
    final hideBottomBar = location.contains('/content/audio');

    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        body: widget.child,
        bottomNavigationBar: hideBottomBar
            ? null
            : BottomNavigationBar(
          currentIndex: _currentIndex,
          onTap: (i) {
            setState(() => _currentIndex = i);
            context.go(_locations[i]);
          },
          type: BottomNavigationBarType.fixed,
          selectedItemColor: const Color(0xFF6C5CE7),
          unselectedItemColor: Colors.grey,
          items: const [
            BottomNavigationBarItem(icon: Icon(Icons.home_rounded), label: 'Home'),
            BottomNavigationBarItem(
                icon: Icon(Icons.menu_book_rounded), label: 'Courses'),
            BottomNavigationBarItem(icon: Icon(Icons.quiz_rounded), label: 'Quizzes'),
            BottomNavigationBarItem(
                icon: Icon(Icons.emoji_events_rounded), label: 'Leaderboard'),
            BottomNavigationBarItem(
                icon: Icon(Icons.person_rounded), label: 'Profile'),
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\constants\api_constants.dart =====

// lib/core/constants/api_constants.dart
class ApiConstants {
  static const String baseUrl = "https://quizard.in/api_002.php";

  // Endpoints
  static const String user = "/user";
  static const String userById = "/user/";
  static const String classEndpoint = "/class";
  static const String content = "/content";
  static const String course = "/course";
  static const String courseQuiz = "/course_quiz";
  static const String quizAttempt = "/quiz_attempt";
  static const String certificate = "/certificate";
  static const String result = "/result";
  static const String savedQuestion = "/saved_question";
  static const String savedQuiz = "/saved_quiz";
  static const String student = "/student";
  static const String userProgress = "/user_progress";
  static const String attemptReview = "/attempt_review";
  static const String firebaseSetting = "/firebase_setting";
  static const String questionPaper = "/question_paper";
  static const privacyUrl = "https://kendriyadigital.blogspot.com/2025/12/privacy-policy-for-prepking-online.html";
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\services\api_service.dart =====

// lib/core/services/api_service.dart
import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../models/app_settings.dart';
import '../constants/api_constants.dart';

final apiServiceProvider = Provider((ref) => ApiService());

class ApiService {
  late final Dio _dio;

  ApiService() {
    _dio = Dio(BaseOptions(
      baseUrl: ApiConstants.baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      validateStatus: (status) => status! < 500,
    ));

    // ðŸ”’ SECURITY FIX: Disable logging of request/response bodies in debug mode
    // This prevents accidental leakage of sensitive data (emails, firebase IDs, tokens, etc.)
    // which is a common reason for Google Play Store compliance rejections.
    if (kDebugMode) {
      _dio.interceptors.add(LogInterceptor(
        request: true,
        requestHeader: true,
        requestBody: false, // â† Disabled to avoid logging sensitive payloads
        responseBody: false, // â† Disabled to avoid logging personal data
        responseHeader: false,
        error: true,
        logPrint: (obj) => debugPrint("API â†’ $obj"),
      ));
    }
  }

  // ==================== App Settings ====================
  /// Fetches app settings from the server (used for version checking & forced updates)
  Future<AppSettings> getAppSettings({required String packageId}) async {
    try {
      final response = await get('/appsettings', query: {'packageid': packageId});
      return AppSettings.fromJson(response);
    } catch (e) {
      debugPrint('getAppSettings error: $e');
      rethrow;
    }
  }

  // ==================== Generic HTTP Methods ====================
  Future<Map<String, dynamic>> get(String endpoint, {Map<String, dynamic>? query}) async {
    try {
      final response = await _dio.get(
        endpoint,
        queryParameters: query?..map((k, v) => MapEntry(k, v.toString())),
      );
      return _handleResponse(response);
    } catch (e) {
      debugPrint('GET Error [$endpoint]: $e');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> post(
      String endpoint,
      Map<String, dynamic> data, {
        Map<String, dynamic>? query,
      }) async {
    try {
      // Body is NOT logged due to LogInterceptor settings above
      debugPrint('POST â†’ $endpoint');
      final response = await _dio.post(
        endpoint,
        queryParameters: query?..map((k, v) => MapEntry(k, v.toString())),
        data: data,
      );
      return _handleResponse(response);
    } catch (e) {
      debugPrint('POST Error [$endpoint]: $e');
      if (e is DioException) debugPrint('Response: ${e.response?.data}');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> put(String endpoint, Map<String, dynamic> data) async {
    try {
      final response = await _dio.put(endpoint, data: data);
      return _handleResponse(response);
    } catch (e) {
      debugPrint('PUT Error [$endpoint]: $e');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> delete(String endpoint) async {
    try {
      final response = await _dio.delete(endpoint);
      return _handleResponse(response);
    } catch (e) {
      debugPrint('DELETE Error [$endpoint]: $e');
      rethrow;
    }
  }

  // ==================== Content CRUD ====================
  Future<List<Map<String, dynamic>>> getAllContents() async {
    try {
      final response = await get('/content');
      final data = response['data'] as List<dynamic>? ?? [];
      return data.cast<Map<String, dynamic>>();
    } catch (e) {
      debugPrint('getAllContents error: $e');
      return [];
    }
  }

  Future<Map<String, dynamic>?> getContentById(int id) async {
    try {
      final response = await get('/content/$id');
      return response['data'] as Map<String, dynamic>?;
    } catch (e) {
      debugPrint('getContentById($id) error: $e');
      return null;
    }
  }

  Future<Map<String, dynamic>> createContent(Map<String, dynamic> data) async {
    return await post('/content', data);
  }

  Future<Map<String, dynamic>> updateContent(int id, Map<String, dynamic> data) async {
    return await put('/content/$id', data);
  }

  Future<bool> deleteContent(int id) async {
    try {
      await delete('/content/$id');
      return true;
    } catch (e) {
      debugPrint('deleteContent($id) failed: $e');
      return false;
    }
  }

  // ==================== Quiz Attempts ====================
  Future<List<Map<String, dynamic>>> getQuizAttempts({
    required int courseQuizId,
    required int userId,
  }) async {
    final response = await get('/quiz_attempt', query: {
      'course_quiz_id': courseQuizId.toString(),
      'user_id': userId.toString(),
    });
    return (response['data'] as List?)?.cast<Map<String, dynamic>>() ?? [];
  }

  Future<Map<String, dynamic>?> getLatestQuizAttempt({
    required int courseQuizId,
    required int userId,
  }) async {
    final attempts = await getQuizAttempts(courseQuizId: courseQuizId, userId: userId);
    if (attempts.isEmpty) return null;
    return attempts.reduce((a, b) => (a['id'] as int) > (b['id'] as int) ? a : b);
  }

  Future<List<Map<String, dynamic>>> getInProgressAttempts({
    required int courseQuizId,
    required int userId,
  }) async {
    final attempts = await getQuizAttempts(courseQuizId: courseQuizId, userId: userId);
    return attempts.where((a) => a['status'] == 'in_progress').toList();
  }

  Future<Map<String, dynamic>> updateQuizAttempt({
    required int attemptId,
    required String status,
    Map<String, dynamic>? additionalData,
  }) async {
    final payload = {'status': status, ...?additionalData};
    return await put('/quiz_attempt/$attemptId', payload);
  }

  // ==================== Central Response Handler ====================
  Map<String, dynamic> _handleResponse(Response response) {
    final method = response.requestOptions.method;
    final path = response.requestOptions.path;
    final statusCode = response.statusCode;
    debugPrint('API SUCCESS: [$method] $path â†’ $statusCode');

    dynamic data = response.data;
    if (data is String) {
      try {
        data = jsonDecode(data);
      } catch (e) {
        debugPrint('JSON Parse failed: $e');
        throw Exception('Invalid JSON response');
      }
    }

    if (data is! Map<String, dynamic>) {
      debugPrint('Invalid response format: $data');
      throw Exception('API response must be a JSON object');
    }

    if (data['success'] == false) {
      final message = data['message'] ?? 'Unknown error';
      // Graceful handling for "not found" cases (common for optional resources)
      if (message.contains('not found') || message.contains('Resource')) {
        return {'success': true, 'data': null};
      }
      throw Exception('API Error: $message');
    }

    return data;
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\app_version_validator.dart =====

// lib/core/utils/app_version_validator.dart
import 'package:package_info_plus/package_info_plus.dart';

import '../../models/app_settings.dart';

class AppVersionValidator {
  static Future<bool> isUpdateRequired(AppSettings settings) async {
    final info = await PackageInfo.fromPlatform();
    final localVersion = info.version;
    final localBuild = int.tryParse(info.buildNumber) ?? 0;

    // Update required if version name differs OR remote build number is higher
    if (settings.versionName != localVersion) return true;
    if (settings.buildNumber > localBuild) return true;

    return false;
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\back_button_handler.dart =====

// lib/core/utils/back_button_handler.dart
import 'package:flutter/material.dart';

mixin BackButtonHandlerMixin<T extends StatefulWidget> on State<T> {
  bool _isHandlingBack = false;

  /// Override this method to handle back button press
  Future<bool> onWillPop() async {
    return true; // Default behavior - allow back
  }

  /// Wrap your scaffold with back button handling
  Widget buildWithBackHandler(Widget child) {
    return WillPopScope(
      onWillPop: () async {
        if (_isHandlingBack) return false;
        _isHandlingBack = true;

        final shouldPop = await onWillPop();

        if (mounted) {
          _isHandlingBack = false;
        }

        return shouldPop;
      },
      child: child,
    );
  }

  /// Show exit confirmation dialog
  Future<bool> showExitConfirmation() async {
    final shouldExit = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text("Exit PrepKing?", style: TextStyle(fontFamily: 'Poppins', fontWeight: FontWeight.bold)),
        content: Text("Are you sure you want to exit the app?", style: TextStyle(fontFamily: 'Poppins')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text("Stay", style: TextStyle(fontFamily: 'Poppins', color: Colors.grey[600])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFF6C5CE7)),
            onPressed: () => Navigator.pop(context, true),
            child: Text("Exit", style: TextStyle(fontFamily: 'Poppins', color: Colors.white)),
          ),
        ],
      ),
    );
    return shouldExit ?? false;
  }

  /// Show quit quiz confirmation dialog
  Future<bool> showQuitQuizConfirmation() async {
    final shouldQuit = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text("Quit Quiz?", style: TextStyle(fontFamily: 'Poppins', fontWeight: FontWeight.bold)),
        content: Text("Are you sure you want to quit without completing the quiz?", style: TextStyle(fontFamily: 'Poppins')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text("Cancel", style: TextStyle(fontFamily: 'Poppins', color: Colors.grey[600])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            onPressed: () => Navigator.pop(context, true),
            child: Text("Quit", style: TextStyle(fontFamily: 'Poppins', color: Colors.white)),
          ),
        ],
      ),
    );
    return shouldQuit ?? false;
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\network_utils.dart =====

// ===== FILE: lib/core/utils/network_utils.dart =====
// lib/core/utils/network_utils.dart
import 'dart:io';

class NetworkUtils {
  static Future<bool> hasInternet() async {
    try {
      final result = await InternetAddress.lookup('google.com');
      return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
    } catch (_) {
      return false;
    }
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\user_preferences.dart =====

// lib/core/utils/user_preferences.dart

import 'package:shared_preferences/shared_preferences.dart';

/// A lightweight utility class for storing non-sensitive app preferences.
///
/// IMPORTANT BEST PRACTICE (for Google Play compliance & security):
/// - This class should ONLY store flags, settings, and non-personal data.
/// - NEVER store profile data like name, email, or user_id here for display.
///   Use providers (currentUserProvider / userWithProgressProvider) for all user profile data.
/// - Personal data in SharedPreferences is considered insecure and can cause Play Store rejections.
///
/// Current safe usage:
/// - seenOnboarding (flag)
/// - Future expansion: theme, notifications, etc.
class UserPreferences {
  // Keys â€“ keep them private
  static const _seen_onboarding = 'seenOnboarding';
  // Removed deprecated personal data keys (name, email, user_id, etc.)
  // They caused data mixing bugs and compliance risks.

  /// Marks onboarding as seen â€“ safe flag
  Future<void> saveOnboardingSeen() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_seen_onboarding, true);
  }

  /// Checks if onboarding has been seen
  Future<bool> hasSeenOnboarding() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(_seen_onboarding) ?? false;
  }

  /// Clears ALL preferences.
  /// Called during full logout to ensure clean state.
  Future<void> clearAll() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.clear();
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DEPRECATED METHODS (kept temporarily for backward compatibility)
  // These will be removed in future updates.
  // DO NOT USE THEM IN NEW CODE.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  @Deprecated('Use providers instead. This method stores personal data unsafely.')
  Future<void> saveUserData({
    required int userId,
    required String firebaseId,
    required String name,
    required String email,
    bool isFirstTime = false,
    bool isGuest = false,
  }) async {
    // No-op or minimal â€“ do NOT save personal data
    await saveOnboardingSeen();
  }

  @Deprecated('Guest mode should not rely on local storage for profile data.')
  Future<void> saveGuestData({required String firebaseId}) async {
    await saveOnboardingSeen();
  }

  @Deprecated('Do not read profile data from SharedPreferences. Use currentUserProvider.')
  Future<Map<String, dynamic>?> getUserData() async {
    // Return only safe flags â€“ never personal data
    return {
      'seenOnboarding': await hasSeenOnboarding(),
    };
  }

  @Deprecated('Use clearAll() instead.')
  Future<void> clear() async {
    await clearAll();
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\models\app_settings.dart =====

// lib/core/models/app_settings.dart
class AppSettings {
  final String versionName;
  final int buildNumber;
  final String publishTo;

  AppSettings({
    required this.versionName,
    required this.buildNumber,
    required this.publishTo,
  });

  factory AppSettings.fromJson(Map<String, dynamic> json) {
    final data = json['data'] as Map<String, dynamic>;
    return AppSettings(
      versionName: data['version_name'] as String,
      buildNumber: data['build_number'] as int,
      publishTo: data['publish_to'] as String,
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\models\user_model.dart =====

// lib/models/user_model.dart
class UserModel {
  final int id;
  final String email;
  final String name;
  final String? mobile;
  final String? profilePicture;
  final int coins;
  final int streak;
  // Progress fields â€“ now properly populated
  final Map<String, double> courseProgress; // courseId â†’ progress (0.0 to 1.0)
  final Set<String> completedContentIds;
  // Settings fields (from backend)
  final bool notificationsEnabled;
  final String theme; // 'light' or 'dark'
  UserModel({
    required this.id,
    required this.email,
    required this.name,
    this.mobile,
    this.profilePicture,
    this.coins = 0,
    this.streak = 7,
    Map<String, double>? courseProgress,
    Set<String>? completedContentIds,
    this.notificationsEnabled = true,
    this.theme = 'light',
  }) : courseProgress = courseProgress ?? {},
        completedContentIds = Set.from(completedContentIds ?? {});
  // Updated factory to support both plain user API and merged progress API
  factory UserModel.fromJson(Map<String, dynamic> json) {
    // Handle different API variations: sometimes json['data'], sometimes direct map, sometimes list
    final data = json is List
        ? (json.isNotEmpty ? json[0] : {})
        : (json['data'] ?? json);
    // Extract progress if present (this is what your merged provider adds)
    Map<String, dynamic> progressMap = {};
    Set<String> completedIds = {};
    if (data['course_progress'] != null) {
      progressMap = Map<String, dynamic>.from(data['course_progress']);
    }
    if (data['completed_contents'] is List) {
      completedIds = (data['completed_contents'] as List).cast<String>().toSet();
    }
    // Convert progressMap { "5": "0.75" } â†’ { "5": 0.75 }
    final Map<String, double> parsedProgress = {};
    progressMap.forEach((key, value) {
      final double? prog = double.tryParse(value.toString());
      if (prog != null) parsedProgress[key] = prog.clamp(0.0, 1.0);
    });
    // === FIX #1: Support both old and new API field names ===
    final bool notificationsEnabled =
        data['isNotificationEnabled'] == 1 ||
            data['isNotificationEnabled'] == true ||
            data['isNotificationEnabled']?.toString().toLowerCase() == 'true' ||
            data['notifications_enabled'] == 1 ||
            data['notifications_enabled'] == true ||
            data['notifications_enabled']?.toString().toLowerCase() == 'true';

    final String theme = (data['theme']?.toString().toLowerCase() ?? 'light') == 'dark'
        ? 'dark'
        : 'light';
    return UserModel(
      id: data['id'] ?? 0,
      email: data['email'] ?? 'user@example.com',
      name: data['name'] ?? 'PrepKing Warrior',
      mobile: data['mobile'],
      profilePicture: data['profile_picture'],
      coins: int.tryParse(data['coins']?.toString() ?? '0') ?? 0,
      streak: int.tryParse(data['streak']?.toString() ?? '7') ?? 7,
      courseProgress: parsedProgress,
      completedContentIds: completedIds,
      notificationsEnabled: notificationsEnabled,
      theme: theme,
    );
  }
  UserModel copyWith({
    int? id,
    String? email,
    String? name,
    String? mobile,
    String? profilePicture,
    int? coins,
    int? streak,
    Map<String, double>? courseProgress,
    Set<String>? completedContentIds,
    bool? notificationsEnabled,
    String? theme,
  }) {
    return UserModel(
      id: id ?? this.id,
      email: email ?? this.email,
      name: name ?? this.name,
      mobile: mobile ?? this.mobile,
      profilePicture: profilePicture ?? this.profilePicture,
      coins: coins ?? this.coins,
      streak: streak ?? this.streak,
      courseProgress: courseProgress ?? this.courseProgress,
      completedContentIds: completedContentIds ?? this.completedContentIds,
      notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
      theme: theme ?? this.theme,
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\app_init_provider.dart =====

// lib/providers/app_init_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';

import '../core/utils/network_utils.dart';
import '../core/utils/user_preferences.dart';
import '../core/utils/app_version_validator.dart';
import 'user_provider.dart';
import 'app_settings_provider.dart';

/// This provider completes ONLY when the app is fully ready to proceed.
/// It handles:
/// - Network check
/// - Parallel Firebase init + App Settings fetch
/// - Version validation (throws UPDATE_REQUIRED if needed)
/// - Local preferences
/// - User session fetch
final appInitProvider = FutureProvider<void>((ref) async {
  // 1ï¸âƒ£ CHECK NETWORK
  final hasInternet = await NetworkUtils.hasInternet();
  if (!hasInternet) {
    throw Exception('NO_NETWORK');
  }

  // 2ï¸âƒ£ START BOTH FIREBASE INITIALIZATION AND APP SETTINGS FETCH IN PARALLEL
  // This ensures no blocking â€” splash animation runs smoothly
  final firebaseFuture = Firebase.initializeApp(); // Non-blocking start
  final appSettingsFuture = ref.read(appSettingsProvider.future);

  // 3ï¸âƒ£ WAIT FOR APP SETTINGS FIRST â€” REQUIRED FOR VERSION CHECK
  final settings = await appSettingsFuture;

  // 4ï¸âƒ£ VERSION VALIDATION â€” If update required, throw specific exception
  final updateRequired = await AppVersionValidator.isUpdateRequired(settings);
  if (updateRequired) {
    throw Exception('UPDATE_REQUIRED');
  }

  // 5ï¸âƒ£ NOW WAIT FOR FIREBASE TO FINISH INITIALIZING
  await firebaseFuture;

  // 6ï¸âƒ£ LOAD LOCAL PREFERENCES (e.g., onboarding seen flag)
  final prefs = UserPreferences();
  await prefs.hasSeenOnboarding();

  // 7ï¸âƒ£ IF USER IS LOGGED IN, FETCH THEIR DETAILS FROM BACKEND
  final firebaseUser = FirebaseAuth.instance.currentUser;
  if (firebaseUser != null) {
    await ref.read(currentUserProvider.future);
  }

  // All checks passed â†’ app is ready for navigation
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\app_settings_provider.dart =====

// lib/providers/app_settings_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:package_info_plus/package_info_plus.dart';
import '../core/services/api_service.dart';
import '../models/app_settings.dart';

/// Provides the app settings fetched from the server.
/// Dynamically uses the current app's package name (no hardcoding).
final appSettingsProvider = FutureProvider<AppSettings>((ref) async {
  // Get package info at runtime (works on Android & iOS)
  final packageInfo = await PackageInfo.fromPlatform();
  final String packageId = packageInfo.packageName;

  // Fetch app settings using the actual package ID
  final apiService = ref.read(apiServiceProvider);
  return await apiService.getAppSettings(packageId: packageId);
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\certificate_provider.dart =====

// lib/providers/certificate_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

final certificatesProvider = FutureProvider.family<List<dynamic>, int>((ref, userId) async {
  final api = ref.read(apiServiceProvider);
  final res = await api.get('/certificate', query: {'user_id': userId.toString()});
  return res['data'] ?? [];
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\continue_learning_provider.dart =====

// New file: lib/providers/continue_learning_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

final continueLearningProvider =
FutureProvider.family<List<Map<String, dynamic>>, int>((ref, userId) async {
  final api = ref.read(apiServiceProvider);
  final response = await api.get(
    '/user_progress/$userId',
    query: {'type': 'course'},
  );
  if (response['success'] == true && response['data'] is List) {
    return (response['data'] as List)
        .cast<Map<String, dynamic>>()
        .where((e) =>
    (double.tryParse(e['progress_percentage']?.toString() ?? '0') ?? 0) <
        100)
        .toList();
  }
  return [];
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\course_progress_provider.dart =====

// lib/providers/course_progress_provider.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

/// THIS IS THE CORRECT ONE â€” matches your real backend endpoint
final preciseCourseProgressProvider = FutureProvider.family<Map<String, dynamic>?, (int, int)>(
      (ref, params) async {
    final courseId = params.$1;
    final userId = params.$2;

    final api = ref.read(apiServiceProvider);

    try {
      final response = await api.get(
        '/course/$courseId/progress',
        query: {'userid': userId.toString(), 'courseid': courseId.toString()},
      );

      if (response['success'] == true && response['data'] is List && (response['data'] as List).isNotEmpty) {
        return (response['data'] as List).first as Map<String, dynamic>;
      }
      return null; // Not enrolled
    } catch (e) {
      debugPrint('Error fetching precise progress: $e');
      return null;
    }
  },
);



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\course_providers.dart =====

// lib/providers/course_providers.dart

import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dio/dio.dart';
import 'dart:convert';
import '../core/services/api_service.dart';

/// Fetch a single course detail by ID
final courseDetailProvider = FutureProvider.family<Map<String, dynamic>, int>((ref, courseId) async {
  final api = ref.read(apiServiceProvider);

  try {
    debugPrint('Fetching course detail for ID: $courseId');
    final response = await api.get('/course/$courseId');

    if (response['success'] == true) {
      final data = Map<String, dynamic>.from(response['data'] ?? {});
      debugPrint('Course loaded successfully: ${data['title'] ?? 'No title'}');
      return data;
    }

    // API returned error
    final message = response['message'] ?? 'Unknown error';
    final raw = jsonEncode(response);
    debugPrint('courseDetailProvider API failed â†’ $message');
    debugPrint('Raw response: $raw');

    throw Exception('Failed to load course\n\n$message\n\nRaw: $raw');
  } on DioException catch (e) {
    final status = e.response?.statusCode;
    final raw = e.response?.data;
    final msg = e.message ?? 'Network error';

    debugPrint('DioException in courseDetailProvider: $status - $msg');
    debugPrint('Raw response: $raw');

    throw Exception(
      'Network Error\n'
          'Status: $status\n'
          'Message: $msg\n'
          'Response: ${raw is String ? raw : jsonEncode(raw)}',
    );
  } catch (e) {
    debugPrint('Unexpected error in courseDetailProvider: $e');
    rethrow;
  }
});

/// Fetch all contents (lessons) for a course
final courseContentsProvider = FutureProvider.family<List<Map<String, dynamic>>, int>((ref, courseId) async {
  final api = ref.read(apiServiceProvider);

  try {
    debugPrint('Fetching contents for course ID: $courseId');
    final response = await api.get('/course/$courseId/contents');

    if (response['success'] == true) {
      final rawData = response['data'] ?? [];
      final contents = List<Map<String, dynamic>>.from(rawData);
      debugPrint('Successfully loaded ${contents.length} lesson(s)');
      return contents;
    }

    final message = response['message'] ?? 'Unknown error';
    final rawResponse = jsonEncode(response);
    debugPrint('Contents API failed â†’ $message');
    debugPrint('Raw API Response: $rawResponse');
    return [];
  } on DioException catch (dioError) {
    final statusCode = dioError.response?.statusCode;
    final rawBody = dioError.response?.data;
    final errorMsg = dioError.message;

    debugPrint('DioException while fetching course contents:');
    debugPrint('Status: $statusCode | Message: $errorMsg');
    debugPrint('Raw Response Body: $rawBody');

    throw Exception(
      'Failed to load lessons\n\n'
          'Status: $statusCode\n'
          'Error: $errorMsg\n'
          'Response: ${rawBody is String ? rawBody : jsonEncode(rawBody)}',
    );
  } catch (e) {
    debugPrint('Unexpected error in courseContentsProvider: $e');
    rethrow;
  }
});

// Optional: Keep other providers you already had
final classesProvider = FutureProvider<List<dynamic>>((ref) async {
  final api = ref.read(apiServiceProvider);
  final res = await api.get('/class');
  return res['data'] ?? [];
});

final coursesProvider = FutureProvider.family<List<dynamic>, int>((ref, classId) async {
  final api = ref.read(apiServiceProvider);
  final res = await api.get('/course?class_id=$classId');
  return res['data'] ?? [];
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\firebase_init_provider.dart =====

// lib/providers/firebase_init_provider.dart
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final firebaseInitProvider = FutureProvider<FirebaseApp>((ref) async {
  return Firebase.initializeApp();
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\quiz_attempts_provider.dart =====

// lib/providers/quiz_attempts_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';
import 'user_provider.dart';

/// ðŸ“‹ Provider for all quiz attempts
final quizAttemptsProvider = FutureProvider.family<List<Map<String, dynamic>>, int>((ref, quizId) async {
  // Watch user provider properly to handle loading states
  final userAsync = ref.watch(currentUserProvider);

  // Handle loading/error states gracefully
  if (!userAsync.hasValue || userAsync.value == null) {
    throw Exception('User not authenticated');
  }

  final user = userAsync.value!;
  final api = ref.read(apiServiceProvider);

  return api.getQuizAttempts(
    courseQuizId: quizId,
    userId: user.id,
  );
});

/// ðŸŽ¯ Provider for latest quiz attempt
final latestQuizAttemptProvider = FutureProvider.family<Map<String, dynamic>?, int>((ref, quizId) async {
  final userAsync = ref.watch(currentUserProvider);

  if (!userAsync.hasValue || userAsync.value == null) {
    throw Exception('User not authenticated');
  }

  final user = userAsync.value!;
  final api = ref.read(apiServiceProvider);

  return api.getLatestQuizAttempt(
    courseQuizId: quizId,
    userId: user.id,
  );
});

/// ðŸ”„ Provider for in-progress attempts (bonus)
final inProgressAttemptsProvider = FutureProvider.family<List<Map<String, dynamic>>, int>((ref, quizId) async {
  final userAsync = ref.watch(currentUserProvider);

  if (!userAsync.hasValue || userAsync.value == null) {
    throw Exception('User not authenticated');
  }

  final user = userAsync.value!;
  final api = ref.read(apiServiceProvider);

  return api.getInProgressAttempts(
    courseQuizId: quizId,
    userId: user.id,
  );
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\quiz_history_provider.dart =====

// lib/providers/quiz_history_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

final quizHistoryProvider = FutureProvider.family<List<Map<String, dynamic>>, int>((ref, userId) async {
  final api = ref.read(apiServiceProvider);

  try {
    final res = await api.get('/quiz_attempt', query: {'user_id': userId.toString()});
    final List<dynamic> rawAttempts = res['data'] ?? [];

    final List<Map<String, dynamic>> history = [];

    // Batch fetch quiz titles to reduce API calls
    final Set<int> quizIds = rawAttempts
        .map((a) => a['course_quiz_id'])
        .whereType<int>()
        .toSet();

    // Map of quiz_id -> title
    final Map<int, String> quizTitles = {};

    if (quizIds.isNotEmpty) {
      for (final id in quizIds) {
        try {
          final quizRes = await api.get('/course_quiz/$id');
          final data = quizRes['data'];
          if (data != null && data is Map) {
            quizTitles[id] = data['title']?.toString() ?? 'Untitled Quiz';
          }
        } catch (e) {
          quizTitles[id] = 'Untitled Quiz';
        }
      }
    }

    for (var attempt in rawAttempts) {
      final map = Map<String, dynamic>.from(attempt);
      final quizId = map['course_quiz_id'] as int?;

      map['quiz_title'] = quizId != null
          ? (quizTitles[quizId] ?? 'Untitled Quiz')
          : (map['type'] == 'course' ? 'Course Quiz' : 'Practice Quiz');

      // Additional helpful fields
      map['display_score'] = map['status'] == 'completed'
          ? '${map['obtained_marks'] ?? '0'} / ${map['total_marks'] ?? '?'}'
          : 'In Progress';

      map['display_date'] = map['completed_at']?.toString().split(' ').first
          ?? map['started_at']?.toString().split(' ').first
          ?? 'Unknown Date';

      history.add(map);
    }

    // Sort by most recent first
    history.sort((a, b) {
      final dateA = a['completed_at'] ?? a['started_at'] ?? '';
      final dateB = b['completed_at'] ?? b['started_at'] ?? '';
      return dateB.compareTo(dateA);
    });

    return history;
  } catch (e) {
    throw Exception('Failed to load quiz history');
  }
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\user_progress_merged_provider.dart =====

// lib/providers/user_progress_merged_provider.dart

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../models/user_model.dart';
import 'user_provider.dart';
import '../core/services/api_service.dart';

/// â”€â”€ Global user progress provider (family) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// Fetches all progress entries for a given userId from /user_progress?user_id=...
final userProgressProvider = FutureProvider.family<List<Map<String, dynamic>>, int>((ref, userId) async {
  final api = ref.read(apiServiceProvider);

  try {
    final response = await api.get(
      '/user_progress',
      query: {'user_id': userId.toString()},
    );

    if (response['success'] == true) {
      final data = response['data'] as List<dynamic>? ?? [];
      return data.cast<Map<String, dynamic>>();
    }

    debugPrint('user_progress API failed: ${response['message']}');
    return [];
  } catch (e) {
    debugPrint('Error fetching global user progress for user $userId: $e');
    return [];
  }
});

/// â”€â”€ FINAL MERGED PROVIDER: Current user + progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// Combines currentUserProvider (basic profile) with userProgressProvider (progress data)
///
/// Benefits of the update:
/// - Depends on currentUserProvider (which now uses authStateProvider)
/// - Automatically refreshes when the user logs out/in (thanks to authStateProvider)
/// - No stale progress data from previous user after logout/login
final userWithProgressProvider = FutureProvider<UserModel?>((ref) async {
  // Watch currentUserProvider â€“ it will be null when not logged in
  final userAsync = ref.watch(currentUserProvider);

  if (userAsync is AsyncLoading || userAsync is AsyncError) {
    // Propagate loading/error state
    return null;
  }

  final user = userAsync.value;

  if (user == null) {
    debugPrint("userWithProgressProvider: No logged-in user");
    return null;
  }

  final userId = user.id;

  // Fetch progress for this user
  final globalProgressList = await ref.watch(userProgressProvider(userId).future);

  final Map<String, double> courseProgress = {};
  final Set<String> completedContentIds = <String>{};

  for (final p in globalProgressList) {
    final courseId = p['course_id']?.toString();
    final contentId = p['content_id']?.toString();
    final progressPercentage = double.tryParse(p['progress_percentage']?.toString() ?? '0') ?? 0.0;
    final isCompleted = p['completed'] == 1 || p['completed'] == true;

    if (contentId != null && isCompleted) {
      completedContentIds.add(contentId);
    }

    if (courseId != null) {
      courseProgress[courseId] = (progressPercentage / 100.0).clamp(0.0, 1.0);
    }
  }

  // Merge progress into the user model
  return user.copyWith(
    courseProgress: courseProgress,
    completedContentIds: completedContentIds,
  );
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\user_provider.dart =====

// ===== FILE: lib/providers/user_provider.dart =====
// lib/providers/user_provider.dart

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../core/services/api_service.dart';
import '../models/user_model.dart';
import 'firebase_init_provider.dart';

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ API PROVIDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final apiProvider = Provider<ApiService>((ref) {
  return ref.read(apiServiceProvider);
});

/// ðŸ” We KEEP authStateProvider for any UI that needs real-time auth state (e.g., logout listeners)
/// But currentUserProvider no longer depends on it for performance.
final authStateProvider = StreamProvider<User?>((ref) {
  return FirebaseAuth.instance.authStateChanges();
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ CURRENT USER (REAL DATA FROM /user?firebaseid={uid}) â”€â”€â”€â”€â”€â”€â”€
/// âœ¨ Updated logic: Uses FirebaseAuth.instance.currentUser (synchronous, faster)
/// Still waits for Firebase to initialize to avoid race conditions.
final currentUserProvider = FutureProvider<UserModel?>((ref) async {
  final firebaseUser = FirebaseAuth.instance.currentUser;
  if (firebaseUser == null) {
    debugPrint("No Firebase user logged in");
    return null;
  }

  final api = ref.read(apiProvider);

  try {
    // Using query parameter firebaseid as per API documentation
    final response = await api.get(
      '/user',
      query: {'firebaseid': firebaseUser.uid},
    );
    debugPrint("User API Response: $response");

    final data = response['data'];
    if (data is Map<String, dynamic>?) {
      if (data != null) {
        return UserModel.fromJson(data);
      }
    }

    debugPrint("No user data found for uid: ${firebaseUser.uid}");
    return null;
  } catch (e, stack) {
    debugPrint("User fetch error: $e\n$stack");
    // Return null instead of rethrowing to avoid UI crash; FutureProvider handles error state
    return null;
  }
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONTINUE COURSE PROGRESS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class UserProgressModel {
  final String courseTitle;
  final double progressPercentage;
  final String? courseImage;

  const UserProgressModel({
    required this.courseTitle,
    required this.progressPercentage,
    this.courseImage,
  });
}

final continueCourseProvider = FutureProvider<UserProgressModel?>((ref) async {
  final api = ref.read(apiProvider);
  try {
    final response = await api.get('/user_progress');
    final data = response['data'];

    if (data != null && data is List && data.isNotEmpty) {
      final item = data[0] as Map<String, dynamic>;
      return UserProgressModel(
        courseTitle: item['course_title']?.toString() ?? "Continue Learning",
        progressPercentage: double.tryParse(item['progress']?.toString() ?? "0") ?? 0.0,
        courseImage: item['course_image'] as String?,
      );
    }
  } catch (e) {
    debugPrint("Continue course error: $e");
  }

  return const UserProgressModel(
    courseTitle: "Algebra Mastery 101",
    progressPercentage: 68.5,
  );
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ DAILY CHALLENGE QUIZ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class DailyQuizModel {
  final int id;
  final String title;
  final int questionCount;
  final String? thumbnail;

  const DailyQuizModel({
    required this.id,
    required this.title,
    required this.questionCount,
    this.thumbnail,
  });
}

final dailyChallengeProvider = FutureProvider<DailyQuizModel?>((ref) async {
  final api = ref.read(apiProvider);
  try {
    final response = await api.get('/course_quiz', query: {'type': 'daily'});
    final data = response['data'];

    if (data != null && data is List && data.isNotEmpty) {
      final quiz = data[0] as Map<String, dynamic>;
      return DailyQuizModel(
        id: int.tryParse(quiz['id'].toString()) ?? 0,
        title: quiz['title']?.toString() ?? "Today's Challenge",
        questionCount: int.tryParse(quiz['total_questions']?.toString() ?? "5") ?? 5,
        thumbnail: quiz['thumbnail'] as String?,
      );
    }
  } catch (e) {
    debugPrint("Daily quiz fetch error: $e");
  }

  return const DailyQuizModel(
    id: 999,
    title: "Daily Challenge",
    questionCount: 10,
  );
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ ONE-TAP REFRESH ALL USER DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final refreshUserDataProvider = Provider<void Function()>((ref) {
  return () {
    ref.invalidate(currentUserProvider);
    ref.invalidate(continueCourseProvider);
    ref.invalidate(dailyChallengeProvider);
  };
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\dots_loader.dart =====

import 'package:flutter/material.dart';

class _DotsLoader extends StatefulWidget {
  const _DotsLoader();
  @override
  State<_DotsLoader> createState() => _DotsLoaderState();
}

class _DotsLoaderState extends State<_DotsLoader> with TickerProviderStateMixin {
  late final List<AnimationController> _controllers;

  @override
  void initState() {
    super.initState();
    _controllers = List.generate(3, (_) {
      return AnimationController(vsync: this, duration: const Duration(milliseconds: 600))
        ..repeat(reverse: true);
    });
    for (int i = 0; i < _controllers.length; i++) {
      Future.delayed(Duration(milliseconds: i * 150), () {
        if (mounted) _controllers[i].forward();
      });
    }
  }

  @override
  void dispose() {
    for (final c in _controllers) c.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: List.generate(3, (i) {
        return ScaleTransition(
          scale: Tween<double>(begin: 0.4, end: 1.4).animate(
            CurvedAnimation(parent: _controllers[i], curve: Curves.easeInOut),
          ),
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 6),
            width: 12,
            height: 12,
            decoration: const BoxDecoration(
              color: Colors.white,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(color: Colors.white30, blurRadius: 8, spreadRadius: 2),
              ],
            ),
          ),
        );
      }),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\login_screen.dart =====

// lib/screens/login_screen.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:animate_do/animate_do.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:url_launcher/url_launcher.dart';

import '../core/constants/api_constants.dart';
import '../core/utils/user_preferences.dart';
import '../core/services/api_service.dart';
import '../providers/user_provider.dart'; // â† For refreshUserDataProvider
import 'package:flutter_riverpod/flutter_riverpod.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  bool _isSigningIn = false;

  Future<void> _googleSignIn() async {
    if (_isSigningIn) return;
    setState(() => _isSigningIn = true);

    try {
      final googleUser = await GoogleSignIn().signIn();

      if (googleUser == null) {
        setState(() => _isSigningIn = false);
        return;
      }

      final googleAuth = await googleUser.authentication;
      final idToken = googleAuth.idToken;

      if (idToken == null) {
        debugPrint('ID token is null');
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Sign-in failed: Missing ID token')),
        );
        return;
      }

      final credential = GoogleAuthProvider.credential(idToken: idToken);
      final userCredential = await FirebaseAuth.instance.signInWithCredential(credential);

      await handlePostAuthentication(context, ref, userCredential);
    } catch (e) {
      debugPrint('Google Sign-In Error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Sign-in failed: $e')),
      );
    } finally {
      if (mounted) setState(() => _isSigningIn = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF6C5CE7),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 40),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElasticIn(
                child: Text(
                  'Welcome to PrepKing',
                  style: GoogleFonts.poppins(
                    fontSize: 34,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
              ),
              const SizedBox(height: 60),
              ElevatedButton.icon(
                onPressed: _isSigningIn ? null : _googleSignIn,
                icon: _isSigningIn
                    ? const SizedBox(
                  width: 34,
                  height: 34,
                  child: CircularProgressIndicator(color: Colors.red, strokeWidth: 2),
                )
                    : const Icon(Icons.g_mobiledata, size: 34, color: Colors.red),
                label: Text(
                  _isSigningIn ? 'Signing In...' : 'Continue with Google',
                  style: GoogleFonts.poppins(fontSize: 18),
                ),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 18),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
                ),
              ),
              const SizedBox(height: 40),
              Text('or', style: GoogleFonts.poppins(color: Colors.white, fontSize: 16)),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () => context.push('/login/email'),
                child: Text(
                  'Login with Email',
                  style: GoogleFonts.poppins(fontSize: 18, color: Colors.white, fontWeight: FontWeight.w600),
                ),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF8E44AD),
                  padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 18),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(30),
                    side: const BorderSide(color: Colors.white, width: 1.5),
                  ),
                ),
              ),
              const SizedBox(height: 40),
              Text(
                'By continuing, you agree to our',
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(color: Colors.white70, fontSize: 14),
              ),
              const SizedBox(height: 8),
              GestureDetector(
                onTap: () async {
                  //const url = 'https://kendriyadigital.blogspot.com/2025/12/privacy-policy-for-prepking-online.html'; // â† REPLACE WITH YOUR ACTUAL PRIVACY POLICY URL
                  if (await canLaunchUrl(Uri.parse(ApiConstants.privacyUrl))) {
                    await launchUrl(Uri.parse(ApiConstants.privacyUrl), mode: LaunchMode.externalApplication);
                  }
                },
                child: Text(
                  'Privacy Policy',
                  style: GoogleFonts.poppins(
                    color: Colors.white,
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                    decoration: TextDecoration.underline,
                  ),
                ),
              ),
              const SizedBox(height: 20),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: Text(
                  'Sign in to access your account and save your progress across devices.',
                  textAlign: TextAlign.center,
                  style: GoogleFonts.poppins(color: Colors.white70, fontSize: 14),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// â”€â”€ SHARED POST-AUTHENTICATION LOGIC â”€â”€
Future<void> handlePostAuthentication(
    BuildContext context,
    WidgetRef ref,
    UserCredential userCredential,
    ) async {
  final firebaseId = userCredential.user?.uid;
  if (firebaseId == null) {
    throw Exception('Firebase UID is missing after sign-in');
  }

  final apiService = ref.read(apiServiceProvider);
  final response = await apiService.get('/user', query: {'firebaseid': firebaseId});
  final userData = response['data'] as Map<String, dynamic>?;
  final prefs = UserPreferences();

  if (userData != null) {
    // Existing user
    await prefs.saveUserData(
      userId: userData['id'] as int,
      firebaseId: userData['firebase_id'] as String,
      name: userData['name'] as String,
      email: userData['email'] as String,
      isFirstTime: false,
      isGuest: false,
    );
  } else {
    // New user â€” create in backend
    final newUserResponse = await apiService.post('/user', {
      'firebase_id': firebaseId,
      'name': userCredential.user?.displayName ?? 'User',
      'email': userCredential.user?.email ?? '',
      'role': 'guest',
    });
    final createdUser = newUserResponse['data'] as Map<String, dynamic>;
    await prefs.saveUserData(
      userId: createdUser['id'] as int,
      firebaseId: createdUser['firebase_id'] as String,
      name: createdUser['name'] as String,
      email: createdUser['email'] as String,
      isFirstTime: true,
      isGuest: false,
    );
  }

  // â”€â”€ CRITICAL FIX: Invalidate all user-related providers after login
  // This ensures fresh data is fetched and no stale data from previous session remains
  ref.read(refreshUserDataProvider)();

  if (context.mounted) {
    context.go('/home');
  }
}

// â”€â”€ EMAIL LOGIN SCREEN â”€â”€
class EmailLoginScreen extends ConsumerStatefulWidget {
  const EmailLoginScreen({super.key});

  @override
  ConsumerState<EmailLoginScreen> createState() => _EmailLoginScreenState();
}

class _EmailLoginScreenState extends ConsumerState<EmailLoginScreen> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;
  final _formKey = GlobalKey<FormState>();

  Future<void> _signInWithEmail() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);
    try {
      final credential = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      await handlePostAuthentication(context, ref, credential);
    } on FirebaseAuthException catch (e) {
      String message;
      switch (e.code) {
        case 'user-not-found':
          message = 'No user found for that email.';
          break;
        case 'wrong-password':
          message = 'Wrong password provided.';
          break;
        case 'invalid-email':
          message = 'Invalid email address.';
          break;
        case 'user-disabled':
          message = 'This account has been disabled.';
          break;
        default:
          message = 'Login failed: ${e.message ?? 'Unknown error'}';
      }
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(message)));
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: $e')));
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF6C5CE7),
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => context.pop(),
        ),
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 40),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                Text(
                  'Login with Email',
                  style: GoogleFonts.poppins(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
                const SizedBox(height: 60),
                TextFormField(
                  controller: _emailController,
                  keyboardType: TextInputType.emailAddress,
                  style: const TextStyle(color: Colors.white),
                  decoration: InputDecoration(
                    hintText: 'Email',
                    hintStyle: GoogleFonts.poppins(color: Colors.white70),
                    filled: true,
                    fillColor: Colors.white.withOpacity(0.2),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(30),
                      borderSide: BorderSide.none,
                    ),
                    contentPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) return 'Please enter email';
                    if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value)) {
                      return 'Enter a valid email';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                TextFormField(
                  controller: _passwordController,
                  obscureText: true,
                  style: const TextStyle(color: Colors.white),
                  decoration: InputDecoration(
                    hintText: 'Password',
                    hintStyle: GoogleFonts.poppins(color: Colors.white70),
                    filled: true,
                    fillColor: Colors.white.withOpacity(0.2),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(30),
                      borderSide: BorderSide.none,
                    ),
                    contentPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) return 'Please enter password';
                    if (value.length < 6) return 'Password must be at least 6 characters';
                    return null;
                  },
                ),
                const SizedBox(height: 40),
                ElevatedButton(
                  onPressed: _isLoading ? null : _signInWithEmail,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF8E44AD),
                    padding: const EdgeInsets.symmetric(horizontal: 60, vertical: 18),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(30),
                      side: const BorderSide(color: Colors.white, width: 1.5),
                    ),
                  ),
                  child: _isLoading
                      ? const CircularProgressIndicator(color: Colors.white)
                      : Text(
                    'Login',
                    style: GoogleFonts.poppins(fontSize: 18, color: Colors.white, fontWeight: FontWeight.w600),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\onboarding_screen.dart =====

// lib/screens/onboarding_screen.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

import '../core/utils/user_preferences.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _pageController = PageController();
  int _currentPage = 0;

  final List<Map<String, String>> onboardingData = [
    {
      "title": "Practice Smart",
      "text": "Thousands of questions with detailed solutions",
      "lottie": "practice.json",
    },
    {
      "title": "Track Progress",
      "text": "See your improvement with beautiful analytics",
      "lottie": "progress.json",
    },
    {
      "title": "Compete & Win",
      "text": "Join live contests and climb the leaderboard",
      "lottie": "trophy.json",
    },
  ];

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  /// Called when user completes onboarding
  Future<void> _completeOnboarding() async {
    // Mark onboarding as seen using the safe, updated UserPreferences
    await UserPreferences().saveOnboardingSeen();

    if (!mounted) return;

    // Always go to login after onboarding (user must sign in to save progress)
    // This is best practice: onboarding â†’ login â†’ home
    context.go('/login');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF6C5CE7),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: PageView.builder(
                controller: _pageController,
                onPageChanged: (i) => setState(() => _currentPage = i),
                itemCount: onboardingData.length,
                itemBuilder: (context, index) {
                  final data = onboardingData[index];
                  return OnboardingPage(data: data);
                },
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(30.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // Page indicators
                  Row(
                    children: List.generate(
                      onboardingData.length,
                          (i) => AnimatedContainer(
                        duration: const Duration(milliseconds: 300),
                        margin: const EdgeInsets.only(right: 8),
                        height: 10,
                        width: _currentPage == i ? 30 : 10,
                        decoration: BoxDecoration(
                          color: _currentPage == i ? Colors.white : Colors.white38,
                          borderRadius: BorderRadius.circular(5),
                        ),
                      ),
                    ),
                  ),
                  // Next / Done button
                  FloatingActionButton(
                    backgroundColor: Colors.white,
                    elevation: 6,
                    onPressed: () async {
                      if (_currentPage == onboardingData.length - 1) {
                        await _completeOnboarding();
                      } else {
                        _pageController.nextPage(
                          duration: const Duration(milliseconds: 400),
                          curve: Curves.easeInOut,
                        );
                      }
                    },
                    child: Icon(
                      _currentPage == onboardingData.length - 1
                          ? Icons.check
                          : Icons.arrow_forward,
                      color: const Color(0xFF6C5CE7),
                      size: 28,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class OnboardingPage extends StatelessWidget {
  final Map<String, String> data;

  const OnboardingPage({super.key, required this.data});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 40.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Lottie.asset(
            'assets/lottie/${data["lottie"]}',
            width: 320,
            fit: BoxFit.contain,
            repeat: true,
            errorBuilder: (context, error, stackTrace) {
              // Fallback if Lottie fails to load
              return const Icon(
                Icons.quiz,
                size: 200,
                color: Colors.white70,
              );
            },
          ),
          const SizedBox(height: 60),
          Text(
            data["title"]!,
            style: GoogleFonts.poppins(
              fontSize: 36,
              fontWeight: FontWeight.bold,
              color: Colors.white,
              height: 1.2,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 20),
          Text(
            data["text"]!,
            textAlign: TextAlign.center,
            style: GoogleFonts.poppins(
              fontSize: 18,
              color: Colors.white70,
              height: 1.5,
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\splash_screen.dart =====

// lib/screens/splash_screen.dart
import 'package:animate_do/animate_do.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:url_launcher/url_launcher.dart'; // â† NEW IMPORT

import '../providers/app_init_provider.dart';
import '../core/utils/user_preferences.dart';

class SplashScreen extends ConsumerWidget {
  const SplashScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch the initialization state for loading indicator
    final initAsync = ref.watch(appInitProvider);

    // Listen for completion or error
    ref.listen(appInitProvider, (prev, next) {
      next.whenOrNull(
        data: (_) async {
          final prefs = UserPreferences();
          final seen = await prefs.hasSeenOnboarding();
          final user = FirebaseAuth.instance.currentUser;

          if (!seen) {
            context.go('/onboarding');
          } else if (user == null) {
            context.go('/login');
          } else {
            context.go('/home');
          }
        },
        error: (error, _) {
          // No Internet Connection
          if (error.toString().contains('NO_NETWORK')) {
            showDialog(
              context: context,
              barrierDismissible: false,
              builder: (_) => AlertDialog(
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                title: Text(
                  'No Internet Connection',
                  style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
                ),
                content: Text(
                  'Network not available.\nPlease check your internet connection and try again.',
                  style: GoogleFonts.poppins(),
                ),
                actions: [
                  TextButton(
                    onPressed: () {
                      Navigator.pop(context);
                      ref.invalidate(appInitProvider); // Retry initialization
                    },
                    child: Text(
                      'Retry',
                      style: GoogleFonts.poppins(
                        color: const Color(0xFF6C5CE7),
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
            );
          }
          // Update Required (Forced Update)
          else if (error.toString().contains('UPDATE_REQUIRED')) {
            showDialog(
              context: context,
              barrierDismissible: false, // Non-cancelable
              builder: (_) => AlertDialog(
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                title: Text(
                  'Update Required',
                  style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
                ),
                content: Text(
                  'A new version of PrepKing is available.\nPlease update to continue using the app.',
                  style: GoogleFonts.poppins(),
                ),
                actions: [
                  TextButton(
                    onPressed: () async {
                      final uri = Uri.parse(
                        'https://play.google.com/store/apps/details?id=com.dube.prepking',
                      );
                      if (await canLaunchUrl(uri)) {
                        await launchUrl(uri, mode: LaunchMode.externalApplication);
                      }
                    },
                    child: Text(
                      'UPDATE NOW',
                      style: GoogleFonts.poppins(
                        color: const Color(0xFF6C5CE7),
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
            );
          }
        },
      );
    });

    // Optional safety timeout (unchanged)
    Future.delayed(const Duration(seconds: 12), () {
      if (context.mounted && initAsync.isLoading) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Taking longer than expected...',
              style: GoogleFonts.poppins(),
            ),
            backgroundColor: Colors.orange.shade700,
            behavior: SnackBarBehavior.floating,
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () => ref.invalidate(appInitProvider),
            ),
          ),
        );
      }
    });

    // --- Beautiful UI (100% preserved from your original design) ---
    return Scaffold(
      backgroundColor: const Color(0xFF6C5CE7),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset(
              'assets/lottie/splash.json',
              width: 280,
              fit: BoxFit.contain,
              repeat: true,
              errorBuilder: (context, error, stackTrace) {
                return Column(
                  children: [
                    Image.asset(
                      'assets/images/logo.png',
                      width: 180,
                      height: 180,
                      errorBuilder: (context, error, stackTrace) =>
                      const Icon(Icons.school, size: 100, color: Colors.white),
                    ),
                    const SizedBox(height: 20),
                    const CircularProgressIndicator(color: Colors.white),
                  ],
                );
              },
            ),
            const SizedBox(height: 50),
            FadeInDown(
              duration: const Duration(milliseconds: 1000),
              child: Text(
                'PrepKing',
                style: GoogleFonts.poppins(
                  fontSize: 52,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                  letterSpacing: 1.2,
                  shadows: const [
                    Shadow(color: Colors.black26, offset: Offset(0, 4), blurRadius: 10),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),
            FadeInUp(
              duration: const Duration(milliseconds: 1200),
              delay: const Duration(milliseconds: 400),
              child: Text(
                'Master Any Exam. Anytime. Anywhere.',
                style: GoogleFonts.poppins(fontSize: 18, color: Colors.white70),
                textAlign: TextAlign.center,
              ),
            ),
            const SizedBox(height: 120),
            if (initAsync.isLoading) const _DotsLoader(),
          ],
        ),
      ),
    );
  }
}

/// Beautiful bouncing dots loader (exactly as in your original code)
class _DotsLoader extends StatefulWidget {
  const _DotsLoader();

  @override
  State<_DotsLoader> createState() => _DotsLoaderState();
}

class _DotsLoaderState extends State<_DotsLoader> with TickerProviderStateMixin {
  late final List<AnimationController> _controllers = List.generate(
    3,
        (_) => AnimationController(vsync: this, duration: const Duration(milliseconds: 600))
      ..repeat(reverse: true),
  );

  @override
  void initState() {
    super.initState();
    for (int i = 0; i < 3; i++) {
      Future.delayed(Duration(milliseconds: i * 150), () {
        if (mounted) _controllers[i].forward();
      });
    }
  }

  @override
  void dispose() {
    for (final c in _controllers) c.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: List.generate(3, (i) {
        return ScaleTransition(
          scale: Tween<double>(begin: 0.4, end: 1.4).animate(
            CurvedAnimation(parent: _controllers[i], curve: Curves.easeInOut),
          ),
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 6),
            width: 12,
            height: 12,
            decoration: const BoxDecoration(
              color: Colors.white,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(color: Colors.white30, blurRadius: 8, spreadRadius: 2),
              ],
            ),
          ),
        );
      }),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\content_list_screen.dart =====

// lib/screens/courses/content_list_screen.dart
import 'package:animate_do/animate_do.dart';
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

import '../../providers/course_providers.dart'; // Contains courseContentsProvider
import '../../providers/user_progress_merged_provider.dart'; // Contains userWithProgressProvider

class ContentListScreen extends ConsumerStatefulWidget {
  final int courseId;
  const ContentListScreen({super.key, required this.courseId});

  @override
  ConsumerState<ContentListScreen> createState() => _ContentListScreenState();
}

class _ContentListScreenState extends ConsumerState<ContentListScreen> {
  late ConfettiController _confettiController;

  @override
  void initState() {
    super.initState();
    _confettiController = ConfettiController(duration: const Duration(seconds: 3));
  }

  @override
  void dispose() {
    _confettiController.dispose();
    super.dispose();
  }

  void _showCompletionCelebration() {
    _confettiController.play();
    Future.delayed(const Duration(seconds: 1), () {
      if (mounted) {
        context.push('/certificate', extra: {'courseId': widget.courseId});
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final contentsAsync = ref.watch(courseContentsProvider(widget.courseId));
    final userProgressAsync = ref.watch(userWithProgressProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(
          "Course Content",
          style: GoogleFonts.poppins(
            fontWeight: FontWeight.bold,
            fontSize: 20,
          ),
        ),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: Stack(
        children: [
          userProgressAsync.when(
            loading: () => const Center(
                child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
            error: (_, __) => const Center(child: Text("Error loading progress")),
            data: (user) {
              final Set<String> completedIds = user?.completedContentIds ?? {};

              return contentsAsync.when(
                loading: () => const Center(child: CircularProgressIndicator()),
                error: (_, __) => const Center(child: Text("Error loading content")),
                data: (contents) {
                  // Auto-celebrate when course is fully completed
                  final allCompleted = contents.isNotEmpty &&
                      contents.every(
                              (c) => completedIds.contains(c['id'].toString()));

                  if (allCompleted) {
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      if (mounted) _showCompletionCelebration();
                    });
                  }

                  return ListView.builder(
                    padding: const EdgeInsets.all(16),
                    itemCount: contents.length,
                    itemBuilder: (ctx, i) {
                      final content = contents[i];
                      final contentId = content['id'].toString();
                      final isCompleted = completedIds.contains(contentId);

                      // Lock next lesson until previous is completed
                      final prevContentId =
                      i > 0 ? contents[i - 1]['id'].toString() : null;
                      final isLocked = i > 0 &&
                          prevContentId != null &&
                          !completedIds.contains(prevContentId);

                      // Determine content type
                      final String rawType = (content['type'] as String?)
                          ?.toLowerCase()
                          .trim() ??
                          'text';

                      String route;
                      switch (rawType) {
                        case 'video':
                        case 'youtube':
                        case 'vimeo':
                          route = '/courses/content/video';
                          break;
                        case 'audio':
                          route = '/courses/content/audio';
                          break;
                        case 'quiz':
                        case 'mcq':
                        case 'assessment':
                          route = '/courses/content/quiz';
                          break;
                        case 'pdf':
                        case 'document':
                        case 'file':
                          route = '/courses/content/pdf';
                          break;
                        case 'text':
                        case 'article':
                        case 'lesson':
                        case 'html':
                        case 'markdown':
                        default:
                          route = '/courses/content/text';
                          break;
                      }

                      // Choose appropriate icon based on type
                      IconData typeIcon;
                      switch (rawType) {
                        case 'video':
                        case 'youtube':
                        case 'vimeo':
                          typeIcon = Icons.play_circle_filled;
                          break;
                        case 'audio':
                          typeIcon = Icons.headset;
                          break;
                        case 'quiz':
                        case 'mcq':
                        case 'assessment':
                          typeIcon = Icons.quiz;
                          break;
                        case 'pdf':
                        case 'document':
                        case 'file':
                          typeIcon = Icons.picture_as_pdf;
                          break;
                        default:
                          typeIcon = Icons.description;
                          break;
                      }

                      return FadeInUp(
                        delay: Duration(milliseconds: i * 100),
                        duration: const Duration(milliseconds: 600),
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 16),
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(20),
                            gradient: LinearGradient(
                              colors: isLocked
                                  ? [Colors.grey.shade300, Colors.grey.shade400]
                                  : isCompleted
                                  ? [
                                Colors.green.shade400,
                                Colors.green.shade600
                              ]
                                  : [
                                const Color(0xFF6C5CE7),
                                const Color(0xFF4A43B0)
                              ],
                              begin: Alignment.topLeft,
                              end: Alignment.bottomRight,
                            ),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.15),
                                blurRadius: 12,
                                offset: const Offset(0, 6),
                              ),
                            ],
                          ),
                          child: ListTile(
                            contentPadding: const EdgeInsets.symmetric(
                                horizontal: 20, vertical: 12),
                            leading: CircleAvatar(
                              radius: 28,
                              backgroundColor: Colors.white.withOpacity(0.3),
                              child: Icon(
                                isCompleted
                                    ? Icons.check_rounded
                                    : (isLocked ? Icons.lock_rounded : typeIcon),
                                color: Colors.white,
                                size: 28,
                              ),
                            ),
                            title: Text(
                              content['title'] ?? "Lesson ${i + 1}",
                              style: GoogleFonts.poppins(
                                color: Colors.white,
                                fontWeight: FontWeight.w600,
                                fontSize: 17,
                              ),
                            ),
                            subtitle: Padding(
                              padding: const EdgeInsets.only(top: 6),
                              child: Row(
                                children: [
                                  Icon(
                                    typeIcon,
                                    color: Colors.white70,
                                    size: 16,
                                  ),
                                  const SizedBox(width: 6),
                                  Text(
                                    (content['type'] as String?)
                                        ?.toUpperCase() ??
                                        "TEXT",
                                    style: GoogleFonts.poppins(
                                      color: Colors.white70,
                                      fontSize: 13,
                                      fontWeight: FontWeight.w500,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            trailing: isCompleted
                                ? const Icon(Icons.check_circle_rounded,
                                color: Colors.white, size: 32)
                                : (isLocked
                                ? const Icon(Icons.lock_outline,
                                color: Colors.white70, size: 28)
                                : const Icon(Icons.arrow_forward_ios_rounded,
                                color: Colors.white, size: 24)),
                            enabled: !isLocked,
                            onTap: !isLocked
                                ? () {
                              context.push(route, extra: content);
                            }
                                : null,
                          ),
                        ),
                      );
                    },
                  );
                },
              );
            },
          ),

          // Confetti Celebration (full screen)
          Align(
            alignment: Alignment.topCenter,
            child: ConfettiWidget(
              confettiController: _confettiController,
              blastDirectionality: BlastDirectionality.explosive,
              colors: const [
                Colors.purple,
                Colors.pink,
                Colors.blue,
                Colors.orange,
                Colors.green,
                Colors.yellow
              ],
              emissionFrequency: 0.05,
              numberOfParticles: 80,
              gravity: 0.2,
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\course_detail_screen.dart =====

// lib/screens/course_detail_screen.dart
import 'dart:convert';
import 'package:animate_do/animate_do.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:share_plus/share_plus.dart';
import 'package:dio/dio.dart';
import '../../providers/course_providers.dart';
import '../../providers/course_progress_provider.dart';
import '../../providers/user_progress_merged_provider.dart';
import '../../core/services/api_service.dart';

class CourseDetailScreen extends ConsumerStatefulWidget {
  final int courseId;
  const CourseDetailScreen({super.key, required this.courseId});

  @override
  ConsumerState<CourseDetailScreen> createState() => _CourseDetailScreenState();
}

class _CourseDetailScreenState extends ConsumerState<CourseDetailScreen> {
  bool _isEnrolling = false;

  Future<void> _enrollInCourse() async {
    final userAsync = ref.read(userWithProgressProvider);
    final user = userAsync.asData?.value;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Please log in to enroll")),
      );
      return;
    }

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text("Enroll in Course", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: const Text("Are you sure you want to enroll in this course?"),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text("Cancel")),
          ElevatedButton(
            onPressed: () => Navigator.pop(ctx, true),
            style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFF6C5CE7)),
            child: const Text("Enroll Now"),
          ),
        ],
      ),
    );

    if (!(confirmed ?? false)) return;

    setState(() => _isEnrolling = true);

    try {
      final api = ref.read(apiServiceProvider);
      await api.post(
        '/course/${widget.courseId}/enroll',
        {},
        query: {
          'userid': user.id.toString(),
          'courseid': widget.courseId.toString(),
        },
      );

      ref.invalidate(preciseCourseProgressProvider((widget.courseId, user.id)));
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Successfully enrolled!")),
      );
    } catch (e) {
      String msg = "Enrollment failed!";
      if (e is DioException) {
        final data = e.response?.data;
        if (data is Map<String, dynamic> && data.containsKey('message')) {
          msg = data['message'];
        } else {
          msg = data is Map ? jsonEncode(data) : data.toString();
        }
      }
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(backgroundColor: Colors.red, content: Text(msg)),
      );
      debugPrint('Enrollment Error: $e');
    } finally {
      setState(() => _isEnrolling = false);
    }
  }

  void _shareCourse(String title, dynamic slug) {
    final url = "https://prepking.online/c/${slug ?? widget.courseId}";
    Share.share("$title\n\nJoin now: $url", subject: "Check out this course!");
  }

  // Extract real lesson count from PHP serialized content_ids
  int _getLessonCount(Map<String, dynamic> course) {
    final String? serialized = course['content_ids'] as String?;
    if (serialized == null || serialized.isEmpty) return 0;
    final regExp = RegExp(r'a:(\d+):');
    final match = regExp.firstMatch(serialized);
    if (match != null) {
      return int.tryParse(match.group(1)!) ?? 0;
    }
    return 0;
  }

  // NEW: Determine correct route based on content type
  String _getContentRoute(Map<String, dynamic> content) {
    final String rawType = (content['type'] as String?)?.toLowerCase().trim() ?? 'text';

    switch (rawType) {
      case 'video':
      case 'youtube':
      case 'vimeo':
        return '/courses/content/video';
      case 'quiz':
      case 'mcq':
      case 'assessment':
        return '/courses/content/quiz';
      case 'pdf':
      case 'document':
      case 'file':
        return '/courses/content/pdf';
      case 'text':
      case 'article':
      case 'lesson':
      case 'html':
      case 'markdown':
      default:
        return '/courses/content/text';
    }
  }

  @override
  Widget build(BuildContext context) {
    final courseAsync = ref.watch(courseDetailProvider(widget.courseId));
    final contentsAsync = ref.watch(courseContentsProvider(widget.courseId));
    final userAsync = ref.watch(userWithProgressProvider);
    final userId = userAsync.asData?.value?.id ?? 0;

    if (userId == 0) {
      return _buildUI(courseAsync, contentsAsync, progress: 0.0, isEnrolled: false, isCompleted: false);
    }

    final progressAsync = ref.watch(preciseCourseProgressProvider((widget.courseId, userId)));
    final double progress = progressAsync.when(
      data: (data) => data == null
          ? 0.0
          : (double.tryParse(data['progress_percentage'].toString()) ?? 0.0) / 100.0,
      loading: () => userAsync.value?.courseProgress[widget.courseId.toString()] ?? 0.0,
      error: (_, __) => userAsync.value?.courseProgress[widget.courseId.toString()] ?? 0.0,
    );

    final bool isEnrolled = progressAsync.hasValue && progressAsync.value != null;
    final bool isCompleted = progress >= 0.99;

    return _buildUI(
      courseAsync,
      contentsAsync,
      progress: progress.clamp(0.0, 1.0),
      isEnrolled: isEnrolled,
      isCompleted: isCompleted,
    );
  }

  Widget _buildUI(
      AsyncValue<Map<String, dynamic>> courseAsync,
      AsyncValue<List<Map<String, dynamic>>> contentsAsync, {
        required double progress,
        required bool isEnrolled,
        required bool isCompleted,
      }) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FF),
      body: courseAsync.when(
        loading: () => const Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
        error: (err, _) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error, size: 80, color: Colors.red),
              const SizedBox(height: 16),
              Text("Failed to load course", style: GoogleFonts.poppins(fontSize: 18)),
              ElevatedButton.icon(
                onPressed: () => ref.invalidate(courseDetailProvider(widget.courseId)),
                icon: const Icon(Icons.refresh),
                label: const Text("Retry"),
              ),
            ],
          ),
        ),
        data: (course) {
          final title = course['title'] ?? 'Course';
          final thumbnail = course['thumbnail'];
          final slug = course['slug'] ?? course['id'].toString();
          final int lessonCount = _getLessonCount(course);

          return Stack(
            children: [
              CustomScrollView(
                slivers: [
                  SliverAppBar(
                    expandedHeight: 340,
                    pinned: true,
                    flexibleSpace: FlexibleSpaceBar(
                      background: Stack(
                        fit: StackFit.expand,
                        children: [
                          thumbnail != null
                              ? Image.network(thumbnail, fit: BoxFit.cover)
                              : Lottie.asset('assets/lottie/learning.json', fit: BoxFit.cover),
                          Container(
                            decoration: const BoxDecoration(
                              gradient: LinearGradient(
                                begin: Alignment.topCenter,
                                end: Alignment.bottomCenter,
                                colors: [Colors.black45, Colors.black87],
                              ),
                            ),
                          ),
                          Positioned(
                            bottom: 24,
                            left: 20,
                            right: 60,
                            child: FadeInUp(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(title, style: GoogleFonts.poppins(fontSize: 28, fontWeight: FontWeight.bold, color: Colors.white)),
                                  const SizedBox(height: 8),
                                  Wrap(
                                    spacing: 8,
                                    children: [
                                      Chip(
                                        backgroundColor: Colors.purple.shade100.withOpacity(0.9),
                                        label: Text(course['topic'] ?? 'General', style: GoogleFonts.poppins(fontSize: 12)),
                                      ),
                                      Chip(
                                        backgroundColor: Colors.orange.shade100.withOpacity(0.9),
                                        label: Text(course['difficulty'] ?? 'Medium', style: GoogleFonts.poppins(fontSize: 12)),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                          ),
                          Positioned(
                            top: 50,
                            right: 16,
                            child: IconButton(
                              icon: const Icon(Icons.share_rounded, color: Colors.white, size: 28),
                              onPressed: () => _shareCourse(title, slug),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  SliverToBoxAdapter(
                    child: Padding(
                      padding: const EdgeInsets.all(20),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const SizedBox(height: 16),
                          if (isEnrolled && progress > 0.0)
                            FadeInUp(
                              child: Container(
                                padding: const EdgeInsets.all(20),
                                margin: const EdgeInsets.only(bottom: 24),
                                decoration: BoxDecoration(
                                  color: Colors.white,
                                  borderRadius: BorderRadius.circular(20),
                                  boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 15, offset: const Offset(0, 8))],
                                ),
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text("Your Progress", style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w600)),
                                    const SizedBox(height: 12),
                                    Row(
                                      children: [
                                        Expanded(
                                          child: LinearProgressIndicator(
                                            value: progress,
                                            backgroundColor: Colors.grey[200],
                                            valueColor: const AlwaysStoppedAnimation(Color(0xFF6C5CE7)),
                                            minHeight: 10,
                                            borderRadius: BorderRadius.circular(8),
                                          ),
                                        ),
                                        const SizedBox(width: 12),
                                        Text("${(progress * 100).toInt()}%", style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.bold, color: const Color(0xFF6C5CE7))),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          Text("COURSE DETAILS", style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.bold)),
                          const SizedBox(height: 16),
                          _buildInfoCard(Icons.play_circle_outline, lessonCount > 0 ? "$lessonCount Lessons" : "N/A Lessons", "Total lessons"),
                          const SizedBox(height: 12),
                          _buildInfoCard(Icons.access_time, "${course['duration_minutes'] ?? '60'} mins", "Duration"),
                          const SizedBox(height: 12),
                          _buildInfoCard(Icons.card_giftcard, course['certificate_enabled'] == 1 ? "Certificate Included" : "No Certificate", ""),
                          const SizedBox(height: 32),
                          Text("LESSONS", style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.bold)),
                          const SizedBox(height: 16),
                          contentsAsync.when(
                            loading: () => const Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
                            error: (_, __) => const Text("Failed to load lessons", style: TextStyle(color: Colors.red)),
                            data: (contents) => contents.isEmpty
                                ? const Text("No lessons available yet")
                                : ListView.separated(
                              shrinkWrap: true,
                              physics: const NeverScrollableScrollPhysics(),
                              itemCount: contents.length,
                              separatorBuilder: (_, __) => const Divider(height: 1),
                              itemBuilder: (context, i) {
                                final c = contents[i];
                                final isCompleted = ref.read(userWithProgressProvider).asData?.value?.completedContentIds.contains(c['id'].toString()) ?? false;

                                return ListTile(
                                  enabled: isEnrolled,
                                  leading: CircleAvatar(
                                    backgroundColor: isCompleted ? Colors.green : Colors.grey[300],
                                    child: isCompleted
                                        ? const Icon(Icons.check, color: Colors.white)
                                        : Text("${i + 1}", style: const TextStyle(color: Colors.white)),
                                  ),
                                  title: Text(c['title'] ?? "Lesson ${i + 1}", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
                                  subtitle: c['duration_minutes'] != null ? Text("${c['duration_minutes']} mins") : null,
                                  trailing: isEnrolled ? const Icon(Icons.chevron_right) : const Icon(Icons.lock_outline),
                                  onTap: isEnrolled
                                      ? () {
                                    final route = _getContentRoute(c);
                                    context.push(route, extra: c);
                                  }
                                      : null,
                                );
                              },
                            ),
                          ),
                          const SizedBox(height: 120),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
              // Bottom Button (unchanged)
              Positioned(
                bottom: 30,
                left: 24,
                right: 24,
                child: FadeInUp(
                  child: ElevatedButton.icon(
                    onPressed: _isEnrolling
                        ? null
                        : () {
                      if (isCompleted) {
                        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Certificate coming soon!")));
                      } else if (isEnrolled) {
                        context.push('/courses/content/${widget.courseId}');
                      } else {
                        _enrollInCourse();
                      }
                    },
                    icon: _isEnrolling
                        ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 3, color: Colors.white))
                        : Icon(
                      isCompleted
                          ? Icons.card_giftcard_rounded
                          : isEnrolled
                          ? (progress > 0 ? Icons.play_arrow_rounded : Icons.play_circle_fill)
                          : Icons.rocket_launch_rounded,
                      size: 28,
                    ),
                    label: Text(
                      _isEnrolling
                          ? "Enrolling..."
                          : isCompleted
                          ? "View Certificate"
                          : isEnrolled
                          ? (progress > 0 ? "Continue Learning" : "Start Learning")
                          : "Enroll Now",
                      style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF6C5CE7),
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(vertical: 18),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
                      elevation: 12,
                    ),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildInfoCard(IconData icon, String title, String subtitle) {
    return FadeInUp(
      child: Container(
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(20),
          boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.05), blurRadius: 15, offset: const Offset(0, 8))],
        ),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(color: const Color(0xFF6C5CE7).withOpacity(0.1), borderRadius: BorderRadius.circular(16)),
              child: Icon(icon, color: const Color(0xFF6C5CE7), size: 28),
            ),
            const SizedBox(width: 16),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(title, style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.bold)),
                if (subtitle.isNotEmpty) Text(subtitle, style: GoogleFonts.poppins(fontSize: 13, color: Colors.grey[600])),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\course_list_screen.dart =====

// lib/screens/course_list_screen.dart

import 'package:animate_do/animate_do.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

import '../../core/services/api_service.dart';
import '../../providers/user_progress_merged_provider.dart';

/// Provider that returns list of all courses
final allCoursesProvider = FutureProvider<List<dynamic>>((ref) async {
  final api = ref.read(apiServiceProvider);
  final response = await api.get('/course');
  if (response is Map<String, dynamic> && response['success'] == true) {
    return (response['data'] as List?) ?? [];
  }
  return [];
});

class CourseListScreen extends ConsumerWidget {
  const CourseListScreen({super.key});

  // Count total lessons from PHP-serialized content_ids string
  int _getTotalContents(Map<String, dynamic> course) {
    final contentIds = course['content_ids'];
    if (contentIds == null || contentIds is! String) return 0;
    try {
      final match = RegExp(r'a:(\d+)').firstMatch(contentIds);
      return match != null ? int.parse(match.group(1)!) : 0;
    } catch (e) {
      return 0;
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final coursesAsync = ref.watch(allCoursesProvider);
    final userProgressAsync = ref.watch(userWithProgressProvider);

    return Scaffold(
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            expandedHeight: 180,
            pinned: true,
            flexibleSpace: FlexibleSpaceBar(
              titlePadding:
              const EdgeInsetsDirectional.only(start: 20, bottom: 16),
              title: Text(
                "Courses",
                style: GoogleFonts.poppins(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
              background: Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [Color(0xFF6C5CE7), Color(0xFF4A3CB7)],
                  ),
                ),
              ),
            ),
            backgroundColor: const Color(0xFF6C5CE7),
          ),
          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: coursesAsync.when(
              loading: () => const SliverToBoxAdapter(
                child: Center(
                  child: CircularProgressIndicator(
                    color: Color(0xFF6C5CE7),
                  ),
                ),
              ),
              error: (_, __) => SliverToBoxAdapter(
                child: Center(
                  child: Column(
                    children: [
                      Lottie.asset('assets/lottie/no_connection.json', width: 200),
                      const SizedBox(height: 20),
                      Text("No internet connection", style: GoogleFonts.poppins(fontSize: 18)),
                      TextButton(
                        onPressed: () => ref.refresh(allCoursesProvider),
                        child: const Text("Retry", style: TextStyle(color: Color(0xFF6C5CE7))),
                      ),
                    ],
                  ),
                ),
              ),
              data: (courses) {
                if (courses.isEmpty) {
                  return SliverToBoxAdapter(
                    child: Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Lottie.asset('assets/lottie/empty.json', width: 250),
                          const SizedBox(height: 20),
                          Text(
                            "No courses available yet",
                            style: GoogleFonts.poppins(fontSize: 20, color: Colors.grey[600]),
                            textAlign: TextAlign.center,
                          ),
                        ],
                      ),
                    ),
                  );
                }

                // âœ… SAFELY extract user progress â€” no crash on guest
                double getProgressForCourse(String courseId) {
                  // Only if user data loaded successfully
                  if (userProgressAsync is AsyncData) {
                    return userProgressAsync.value?.courseProgress[courseId] ?? 0.0;
                  }
                  // If loading, error, or not logged in â†’ treat as 0%
                  return 0.0;
                }

                return SliverList(
                  delegate: SliverChildBuilderDelegate(
                        (context, index) {
                      final course = courses[index];
                      final courseId = course['id'].toString();
                      final progress = getProgressForCourse(courseId);
                      final totalLessons = _getTotalContents(course);

                      return FadeInUp(
                        delay: Duration(milliseconds: index * 100),
                        child: Hero(
                          tag: 'course-hero-$courseId',
                          child: Container(
                            margin: const EdgeInsets.only(bottom: 16),
                            child: Card(
                              elevation: 8,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
                              child: InkWell(
                                borderRadius: BorderRadius.circular(24),
                                onTap: () => context.push('/courses/detail/$courseId'),
                                child: Padding(
                                  padding: const EdgeInsets.all(20),
                                  child: Row(
                                    children: [
                                      ClipRRect(
                                        borderRadius: BorderRadius.circular(16),
                                        child: Container(
                                          width: 80,
                                          height: 80,
                                          color: Colors.grey[200],
                                          child: (course['thumbnail'] != null &&
                                              course['thumbnail'].toString().isNotEmpty)
                                              ? Image.network(
                                            course['thumbnail'],
                                            fit: BoxFit.cover,
                                            errorBuilder: (_, __, ___) => Lottie.asset(
                                              'assets/lottie/learning.json',
                                              fit: BoxFit.cover,
                                              repeat: true,
                                            ),
                                          )
                                              : Lottie.asset(
                                            'assets/lottie/learning.json',
                                            fit: BoxFit.cover,
                                            repeat: true,
                                          ),
                                        ),
                                      ),
                                      const SizedBox(width: 16),
                                      Expanded(
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            Text(
                                              course['title'] ?? "Untitled Course",
                                              style: GoogleFonts.poppins(
                                                fontSize: 18,
                                                fontWeight: FontWeight.bold,
                                              ),
                                              maxLines: 2,
                                              overflow: TextOverflow.ellipsis,
                                            ),
                                            const SizedBox(height: 8),
                                            Row(
                                              children: [
                                                const Icon(Icons.play_circle_outline, size: 18, color: Colors.grey),
                                                const SizedBox(width: 6),
                                                Text(
                                                  "$totalLessons Lessons",
                                                  style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
                                                ),
                                                const Spacer(),
                                                if (progress > 0)
                                                  Text(
                                                    "${(progress * 100).toInt()}% Done",
                                                    style: GoogleFonts.poppins(
                                                      fontSize: 14,
                                                      fontWeight: FontWeight.w600,
                                                      color: const Color(0xFF6C5CE7),
                                                    ),
                                                  ),
                                              ],
                                            ),
                                            const SizedBox(height: 12),
                                            LinearProgressIndicator(
                                              value: progress,
                                              backgroundColor: Colors.grey[300],
                                              valueColor: const AlwaysStoppedAnimation(Color(0xFF6C5CE7)),
                                              minHeight: 7,
                                              borderRadius: BorderRadius.circular(10),
                                            ),
                                          ],
                                        ),
                                      ),
                                      Padding(
                                        padding: const EdgeInsets.only(left: 12),
                                        child: Icon(
                                          Icons.arrow_forward_ios_rounded,
                                          color: Colors.grey[600],
                                          size: 20,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                    childCount: courses.length,
                  ),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        backgroundColor: const Color(0xFF6C5CE7),
        onPressed: () {
          ref.invalidate(allCoursesProvider);
          ref.invalidate(userWithProgressProvider);
        },
        child: const Icon(Icons.refresh_rounded, color: Colors.white),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\audio_player_screen.dart =====

// lib/screens/courses/contents/audio_player_screen.dart
import 'package:animate_do/animate_do.dart';
import 'package:audio_session/audio_session.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:just_audio/just_audio.dart';
import 'package:rxdart/rxdart.dart';

class AudioPlayerScreen extends StatefulWidget {
  final Map<String, dynamic> content;
  const AudioPlayerScreen({super.key, required this.content});

  @override
  State<AudioPlayerScreen> createState() => _AudioPlayerScreenState();
}

class _AudioPlayerScreenState extends State<AudioPlayerScreen> with TickerProviderStateMixin {
  late AudioPlayer _audioPlayer;
  late AnimationController _pulseController;
  double _playbackSpeed = 1.0;
  double _volume = 1.0;
  bool _isCompleted = false;

  @override
  void initState() {
    super.initState();
    _audioPlayer = AudioPlayer(
      audioPipeline: AudioPipeline(
        androidAudioEffects: [AndroidLoudnessEnhancer()],
      ),
    );
    _initAudioSession();
    final String? audioUrl = widget.content['resource_url'];
    if (audioUrl != null && audioUrl.isNotEmpty) {
      _audioPlayer.setUrl(audioUrl).catchError((e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error loading audio: $e')),
          );
        }
      });
    }
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    )..repeat(reverse: true);
  }

  Future<void> _initAudioSession() async {
    final session = await AudioSession.instance;
    await session.configure(const AudioSessionConfiguration.music());
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _audioPlayer.dispose();
    super.dispose();
  }

  Stream<PositionData> get _positionDataStream =>
      Rx.combineLatest3<Duration, Duration, Duration?, PositionData>(
        _audioPlayer.positionStream,
        _audioPlayer.bufferedPositionStream,
        _audioPlayer.durationStream,
            (position, bufferedPosition, duration) => PositionData(
          position,
          bufferedPosition,
          duration ?? Duration.zero,
        ),
      );

  String _formatDuration(Duration duration) {
    final minutes = duration.inMinutes.remainder(60).toString().padLeft(2, '0');
    final seconds = duration.inSeconds.remainder(60).toString().padLeft(2, '0');
    return '$minutes:$seconds';
  }

  Future<bool> _onBackPressed() async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text("Leave Audio"),
        content: const Text(
          "Do you want to leave this screen?\nIs the content completed by you?",
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text("Stay"),
          ),
          TextButton(
            onPressed: () async {
              await _recordProgress(completed: true);
              Navigator.pop(context, true);
            },
            child: const Text("Completed"),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text("Leave"),
          ),
        ],
      ),
    );
    return result ?? false;
  }

  Future<void> _recordProgress({required bool completed}) async {
    // CALL YOUR API HERE
  }

  @override
  Widget build(BuildContext context) {
    final String title = widget.content['title'] ?? 'Audio Lesson';
    final String? audioUrl = widget.content['resource_url'];

    return WillPopScope(
      onWillPop: _onBackPressed,
      child: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [Color(0xFF6C5CE7), Color(0xFF4A43B0)],
            ),
          ),
          child: SafeArea(
            child: SingleChildScrollView(  // Added for safety on very small screens
              physics: const BouncingScrollPhysics(),
              child: Column(
                children: [
                  // App Bar
                  Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Row(
                      children: [
                        IconButton(
                          icon: const Icon(Icons.arrow_downward, color: Colors.white, size: 28),
                          onPressed: () => GoRouter.of(context).pop(),
                        ),
                        Expanded(
                          child: Text(
                            title,
                            style: GoogleFonts.poppins(
                              color: Colors.white,
                              fontSize: 18,
                              fontWeight: FontWeight.w600,
                            ),
                            textAlign: TextAlign.center,
                          ),
                        ),
                        const SizedBox(width: 48),
                      ],
                    ),
                  ),
                  const SizedBox(height: 20), // Added small top spacing for balance

                  // Album Art / Visualizer (Reduced size)
                  FadeIn(
                    child: ScaleTransition(
                      scale: Tween<double>(begin: 0.95, end: 1.05).animate(_pulseController),
                      child: Container(
                        width: 240,  // Reduced from 280
                        height: 240, // Reduced from 280
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: Colors.white.withOpacity(0.15),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.25),
                              blurRadius: 24,
                              offset: const Offset(0, 8),
                            ),
                          ],
                        ),
                        child: const Icon(
                          Icons.headphones_rounded,
                          size: 96,  // Reduced from 120
                          color: Colors.white,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 40), // Reduced from 60

                  // Title & Description
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 32),
                    child: Column(
                      children: [
                        Text(
                          title,
                          style: GoogleFonts.poppins(
                            color: Colors.white,
                            fontSize: 24,
                            fontWeight: FontWeight.bold,
                          ),
                          textAlign: TextAlign.center,
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Course Audio Lesson',
                          style: GoogleFonts.poppins(
                            color: Colors.white70,
                            fontSize: 16,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16), // Reduced from 20

                  // Speed Selector
                  PopupMenuButton<double>(
                    initialValue: _playbackSpeed,
                    onSelected: (speed) {
                      setState(() => _playbackSpeed = speed);
                      _audioPlayer.setSpeed(speed);
                    },
                    itemBuilder: (context) => [1, 1.25, 1.5, 2, 3, 4]
                        .map((e) => PopupMenuItem(
                      value: e.toDouble(),
                      child: Text("${e}x"),
                    ))
                        .toList(),
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(20),
                        color: Colors.white.withOpacity(0.2),
                      ),
                      child: Text(
                        "${_playbackSpeed}x",
                        style: GoogleFonts.poppins(color: Colors.white),
                      ),
                    ),
                  ),
                  const SizedBox(height: 28), // Reduced from 40

                  // Seek Bar & Time
                  if (audioUrl != null && audioUrl.isNotEmpty)
                    StreamBuilder<PositionData>(
                      stream: _positionDataStream,
                      builder: (context, snapshot) {
                        final positionData = snapshot.data ??
                            PositionData(Duration.zero, Duration.zero, Duration.zero);
                        final duration = positionData.duration;
                        final position = positionData.position;
                        return Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 32),
                          child: Column(
                            children: [
                              SliderTheme(
                                data: SliderTheme.of(context).copyWith(
                                  trackHeight: 4,
                                  thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 8),
                                  overlayShape: const RoundSliderOverlayShape(overlayRadius: 16),
                                  activeTrackColor: Colors.white,
                                  inactiveTrackColor: Colors.white30,
                                  thumbColor: Colors.white,
                                  overlayColor: Colors.white.withOpacity(0.2),
                                ),
                                child: Slider(
                                  min: 0.0,
                                  max: duration.inMilliseconds.toDouble(),
                                  value: position.inMilliseconds
                                      .toDouble()
                                      .clamp(0.0, duration.inMilliseconds.toDouble()),
                                  onChanged: (value) {
                                    _audioPlayer.seek(Duration(milliseconds: value.toInt()));
                                  },
                                ),
                              ),
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  Text(
                                    _formatDuration(position),
                                    style: GoogleFonts.poppins(color: Colors.white70, fontSize: 14),
                                  ),
                                  Text(
                                    _formatDuration(duration),
                                    style: GoogleFonts.poppins(color: Colors.white70, fontSize: 14),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        );
                      },
                    )
                  else
                    const Text(
                      "Audio file not available",
                      style: TextStyle(color: Colors.white70, fontSize: 16),
                    ),

                  const SizedBox(height: 20),

                  // Volume Control
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 32),
                    child: Row(
                      children: [
                        const Icon(Icons.volume_down, color: Colors.white),
                        Expanded(
                          child: Slider(
                            min: 0,
                            max: 1,
                            value: _volume,
                            onChanged: (value) {
                              setState(() => _volume = value);
                              _audioPlayer.setVolume(value);
                            },
                          ),
                        ),
                        const Icon(Icons.volume_up, color: Colors.white),
                      ],
                    ),
                  ),
                  const SizedBox(height: 28), // Reduced from 40

                  // Playback Controls
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      IconButton(
                        iconSize: 40,
                        color: Colors.white70,
                        icon: const Icon(Icons.skip_previous_rounded),
                        onPressed: () {},
                      ),
                      const SizedBox(width: 32),
                      StreamBuilder<PlayerState>(
                        stream: _audioPlayer.playerStateStream,
                        builder: (context, snapshot) {
                          final playerState = snapshot.data;
                          final processingState = playerState?.processingState;
                          final playing = playerState?.playing ?? false;
                          if (processingState == ProcessingState.loading ||
                              processingState == ProcessingState.buffering) {
                            return const SizedBox(
                              width: 72,
                              height: 72,
                              child: CircularProgressIndicator(color: Colors.white, strokeWidth: 6),
                            );
                          }
                          return BounceInDown(
                            child: GestureDetector(
                              onTap: () {
                                if (playing) {
                                  _audioPlayer.pause();
                                } else {
                                  _audioPlayer.play();
                                }
                              },
                              child: Container(
                                width: 72,
                                height: 72,
                                decoration: const BoxDecoration(
                                  shape: BoxShape.circle,
                                  color: Colors.white,
                                  boxShadow: [
                                    BoxShadow(
                                      color: Colors.black26,
                                      blurRadius: 20,
                                      offset: Offset(0, 8),
                                    ),
                                  ],
                                ),
                                child: Icon(
                                  playing ? Icons.pause_rounded : Icons.play_arrow_rounded,
                                  size: 44,
                                  color: const Color(0xFF6C5CE7),
                                ),
                              ),
                            ),
                          );
                        },
                      ),
                      const SizedBox(width: 32),
                      IconButton(
                        iconSize: 40,
                        color: Colors.white70,
                        icon: const Icon(Icons.skip_next_rounded),
                        onPressed: () {},
                      ),
                    ],
                  ),

                  const SizedBox(height: 16), // Replaced bottom Spacer()
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class PositionData {
  final Duration position;
  final Duration bufferedPosition;
  final Duration duration;
  PositionData(this.position, this.bufferedPosition, this.duration);
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\content_player_screen.dart =====

// lib/screens/course/contents/content_player_screen.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'text_content_screen.dart';
import 'video_content_screen.dart';
import 'quiz_content_screen.dart';
import 'pdf_content_screen.dart';

class ContentPlayerScreen extends StatelessWidget {
  final Map<String, dynamic> content;

  const ContentPlayerScreen({super.key, required this.content});

  @override
  Widget build(BuildContext context) {
    final String type = (content['type'] as String?)?.toLowerCase().trim() ?? 'text';

    Widget screen;

    switch (type) {
      case 'video':
      case 'youtube':
      case 'vimeo':
        screen = VideoContentScreen(content: content);
        break;

      case 'quiz':
      case 'mcq':
      case 'assessment':
        screen = QuizContentScreen(content: content);
        break;

      case 'pdf':
      case 'document':
      case 'file':
        screen = PdfContentScreen(content: content);
        break;

      case 'text':
      case 'article':
      case 'lesson':
      case 'html':
      case 'markdown':
      default:
        screen = TextContentScreen(content: content);
        break;
    }

    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
        title: Text(
          content['title']?.toString() ?? 'Lesson',
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600, fontSize: 18),
        ),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.share_outlined),
            onPressed: () => ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text("Share coming soon!")),
            ),
          ),
        ],
      ),
      body: SafeArea(child: screen),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\pdf_content_screen.dart =====

// lib/screens/course/contents/pdf_content_screen.dart
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_pdfviewer/pdfviewer.dart';

class PdfContentScreen extends StatelessWidget {
  final Map<String, dynamic> content;

  const PdfContentScreen({super.key, required this.content});

  @override
  Widget build(BuildContext context) {
    final url = content['pdf_url']?.toString() ?? content['file_url']?.toString() ?? '';

    if (url.isEmpty) {
      return const Center(
        child: Text("No PDF file found.", style: TextStyle(fontSize: 18)),
      );
    }

    return SfPdfViewer.network(
      url,
      canShowScrollHead: true,
      canShowScrollStatus: true,
      pageLayoutMode: PdfPageLayoutMode.continuous,
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\quiz_content_screen.dart =====

// lib/screens/course/contents/quiz_content_screen.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';

class QuizContentScreen extends StatelessWidget {
  final Map<String, dynamic> content;

  const QuizContentScreen({super.key, required this.content});

  @override
  Widget build(BuildContext context) {
    final quizId = int.tryParse(content['quiz_id']?.toString() ?? '0') ?? 0;
    final total = content['total_questions'] ?? 10;

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              padding: const EdgeInsets.all(30),
              decoration: BoxDecoration(
                color: const Color(0xFF6C5CE7).withOpacity(0.15),
                shape: BoxShape.circle,
              ),
              child: const Icon(Icons.quiz, size: 90, color: Color(0xFF6C5CE7)),
            ),
            const SizedBox(height: 40),
            Text(
              content['title']?.toString() ?? 'Quiz',
              style: GoogleFonts.poppins(fontSize: 28, fontWeight: FontWeight.bold),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            Text(
              "$total Questions â€¢ Earn points on completion",
              style: const TextStyle(fontSize: 16, color: Colors.grey),
            ),
            const SizedBox(height: 50),
            ElevatedButton.icon(
              onPressed: quizId > 0
                  ? () => context.push('/quiz/$quizId', extra: content)
                  : null,
              icon: const Icon(Icons.play_arrow, size: 28),
              label: const Text("Start Quiz", style: TextStyle(fontSize: 18)),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF6C5CE7),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 50, vertical: 18),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
              ),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\text_audio_player_screen.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:animate_do/animate_do.dart';

class TextAudioPlayerScreen extends StatefulWidget {
  final String title;
  final String text;
  const TextAudioPlayerScreen({
    super.key,
    required this.title,
    required this.text,
  });

  @override
  State<TextAudioPlayerScreen> createState() => _TextAudioPlayerScreenState();
}

class _TextAudioPlayerScreenState extends State<TextAudioPlayerScreen> {
  final FlutterTts _tts = FlutterTts();
  bool _isPlaying = false;
  double _speechRate = 0.5;
  int _currentWordIndex = -1;
  late List<String> _words;
  late String _cleanText;
  DateTime _lastHighlightTime = DateTime.now();
  final ScrollController _scrollController = ScrollController();
  List<int> _wordLineMap = [];
  List<double> _lineOffsets = [];
  int _currentLine = -1;

  // Character boundaries for each word in _cleanText
  List<int> _wordStartIndices = [];
  List<int> _wordEndIndices = [];

  @override
  void initState() {
    super.initState();
    _cleanText = _sanitizeText(widget.text);
    _words = _cleanText.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
    _computeWordBoundaries();
    _initTts();
  }

  @override
  void dispose() {
    _tts.stop();
    _scrollController.dispose();
    super.dispose();
  }

  String _sanitizeText(String text) {
    return text
        .replaceAll(RegExp(r'<[^>]*>'), ' ') // Strip HTML tags
        .replaceAll(RegExp(r'&nbsp;|\u00A0'), ' ') // Non-breaking spaces
        .replaceAll(RegExp(r'\s+'), ' ') // Multiple spaces â†’ one
        .trim();
  }

  void _computeWordBoundaries() {
    _wordStartIndices.clear();
    _wordEndIndices.clear();
    int charIndex = 0;
    for (var word in _words) {
      _wordStartIndices.add(charIndex);
      charIndex += word.length;
      _wordEndIndices.add(charIndex);
      charIndex += 1; // account for space
    }
  }

  Future<void> _initTts() async {
    await _tts.setLanguage("und"); // auto-detect
    await _tts.setSpeechRate(_speechRate);
    await _tts.setVolume(1.0);
    await _tts.setPitch(1.0);

    _tts.setStartHandler(() {
      if (mounted) setState(() => _isPlaying = true);
    });

    _tts.setContinueHandler(() {
      if (mounted) setState(() => _isPlaying = true);
    });

    _tts.setPauseHandler(() {
      if (mounted) setState(() => _isPlaying = false);
    });

    _tts.setProgressHandler((String text, int start, int end, String word) {
      if (!_isPlaying || !mounted) return;

      int? wordIndex;
      // Try to find word by start offset
      for (int i = 0; i < _wordStartIndices.length; i++) {
        if (start >= _wordStartIndices[i] && start < _wordEndIndices[i]) {
          wordIndex = i;
          break;
        }
      }

      // Fallback: use end offset if start didn't match
      if (wordIndex == null) {
        for (int i = 0; i < _wordEndIndices.length; i++) {
          if (end <= _wordEndIndices[i]) {
            wordIndex = i;
            break;
          }
        }
      }

      if (wordIndex != null) {
        final now = DateTime.now();
        if (now.difference(_lastHighlightTime).inMilliseconds > 120) {
          if (mounted) {
            setState(() {
              _currentWordIndex = wordIndex!;
            });
          }
          _lastHighlightTime = now;
          _scrollToWord(wordIndex!);
        }
      }
    });

    _tts.setCompletionHandler(() {
      if (mounted) _resetPlaybackState();
    });

    _tts.setCancelHandler(() {
      if (mounted) _resetPlaybackState();
    });
  }

  void _resetPlaybackState() {
    setState(() {
      _isPlaying = false;
      _currentWordIndex = -1;
    });
  }

  Future<void> _togglePlay() async {
    if (_isPlaying) {
      await _tts.pause();
    } else {
      await _tts.speak(_cleanText); // Always full text
    }
  }

  void _computeLineMetrics(BoxConstraints constraints) {
    final double effectiveWidth = constraints.maxWidth - 40.0;
    final TextSpan textSpan = TextSpan(
      text: _cleanText,
      style: const TextStyle(fontSize: 18, height: 1.8, color: Colors.black87),
    );
    final TextPainter painter = TextPainter(
      text: textSpan,
      textDirection: TextDirection.ltr,
    );
    painter.layout(maxWidth: effectiveWidth);
    final List<LineMetrics> lines = painter.computeLineMetrics();

    _lineOffsets = [];
    _wordLineMap = List.filled(_words.length, 0);

    // Compute character start positions of each word
    List<int> wordStarts = [];
    int charPos = 0;
    for (var word in _words) {
      wordStarts.add(charPos);
      charPos += word.length + 1;
    }
    if (_words.isNotEmpty) charPos--; // adjust for last word

    int offset = 0;
    int wordIndex = 0;
    for (int lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      final double lineY = painter.getOffsetForCaret(TextPosition(offset: offset), Rect.zero).dy;
      _lineOffsets.add(lineY);

      // Binary search for line end offset
      int low = offset;
      int high = _cleanText.length;
      while (low < high) {
        final int mid = low + (high - low) ~/ 2;
        final double midY = painter.getOffsetForCaret(TextPosition(offset: mid), Rect.zero).dy;
        if (midY == lineY) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      final int lineEnd = low;

      while (wordIndex < _words.length && wordStarts[wordIndex] < lineEnd) {
        _wordLineMap[wordIndex] = lineIndex;
        wordIndex++;
      }

      offset = lineEnd;
    }
  }

  void _scrollToWord(int wordIndex) {
    if (_wordLineMap.isEmpty || wordIndex >= _wordLineMap.length) return;
    final int lineIndex = _wordLineMap[wordIndex];
    if (lineIndex < 6) return;
    if (lineIndex != _currentLine) {
      _currentLine = lineIndex;
      if (_lineOffsets.isNotEmpty && lineIndex < _lineOffsets.length) {
        final double targetOffset = (_lineOffsets[lineIndex] - 40.0)
            .clamp(0.0, _scrollController.position.maxScrollExtent);
        _scrollController.animateTo(
          targetOffset,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    }
  }

  Widget _buildHighlightedText() {
    return SelectableText.rich(
      TextSpan(
        children: _words.asMap().entries.map((entry) {
          final index = entry.key;
          final word = entry.value;
          final isActive = index == _currentWordIndex;
          return TextSpan(
            text: "$word ",
            style: TextStyle(
              fontSize: 18,
              height: 1.8,
              color: isActive ? Colors.white : Colors.black87,
              backgroundColor: isActive ? const Color(0xFF6C5CE7) : Colors.transparent,
              fontWeight: isActive ? FontWeight.bold : FontWeight.normal,
            ),
          );
        }).toList(),
      ),
      style: const TextStyle(fontSize: 18, color: Colors.black87),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        title: Text(
          widget.title,
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
        ),
      ),
      body: Column(
        children: [
          FadeInDown(
            duration: const Duration(milliseconds: 600),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.all(24),
              decoration: const BoxDecoration(
                color: Color(0xFF6C5CE7),
                borderRadius: BorderRadius.vertical(bottom: Radius.circular(30)),
              ),
              child: Column(
                children: [
                  AnimatedContainer(
                    duration: const Duration(milliseconds: 300),
                    child: Icon(
                      _isPlaying ? Icons.graphic_eq : Icons.headphones,
                      size: 64,
                      color: Colors.white,
                    ),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    _isPlaying ? "Reading aloud..." : "Tap play to listen",
                    style: GoogleFonts.poppins(color: Colors.white70, fontSize: 16),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 20),
          Expanded(
            child: LayoutBuilder(
              builder: (context, constraints) {
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  if (_wordLineMap.isEmpty) {
                    _computeLineMetrics(constraints);
                  }
                });
                return SingleChildScrollView(
                  controller: _scrollController,
                  padding: const EdgeInsets.symmetric(horizontal: 20),
                  child: _buildHighlightedText(),
                );
              },
            ),
          ),
          Container(
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.white,
              boxShadow: [
                BoxShadow(color: Colors.black12, blurRadius: 10, offset: Offset(0, -2))
              ],
            ),
            child: Column(
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [0.5, 0.75, 1.0, 1.25, 1.5].map((rate) {
                    return Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 4),
                      child: ChoiceChip(
                        label: Text("${rate}x"),
                        selected: _speechRate == rate,
                        selectedColor: const Color(0xFF6C5CE7),
                        labelStyle: TextStyle(
                          color: _speechRate == rate ? Colors.white : Colors.black87,
                        ),
                        onSelected: (_) async {
                          setState(() => _speechRate = rate);
                          await _tts.setSpeechRate(rate);
                          if (_isPlaying) {
                            await _tts.stop();
                            await Future.delayed(const Duration(milliseconds: 100));
                            await _tts.speak(_cleanText);
                          }
                        },
                      ),
                    );
                  }).toList(),
                ),
                const SizedBox(height: 20),
                ZoomIn(
                  duration: const Duration(milliseconds: 400),
                  child: FloatingActionButton.large(
                    backgroundColor: const Color(0xFF6C5CE7),
                    onPressed: _togglePlay,
                    child: Icon(
                      _isPlaying ? Icons.pause : Icons.play_arrow,
                      size: 40,
                      color: Colors.white,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\text_content_screen.dart =====

// lib/screens/course/contents/text_content_screen.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart'; // <-- Added for context.push
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_html/flutter_html.dart';

class TextContentScreen extends StatelessWidget {
  final Map<String, dynamic> content;
  const TextContentScreen({super.key, required this.content});

  /// Safely extract and trim ctext â€“ this is the only field we use for text content
  String? _getTextContent() {
    final dynamic ctextRaw = content['ctext'];
    if (ctextRaw == null) return null;
    final String ctext = ctextRaw.toString().trim();
    return ctext.isEmpty ? null : ctext;
  }

  /// Detect if the content contains actual HTML tags
  bool _isHtmlContent(String text) {
    return text.contains(RegExp(
      r'<(p|div|h[1-6]|ul|ol|li|blockquote|img|br|table|thead|tbody|tr|td|th|section|article|span)\b',
      caseSensitive: false,
    ));
  }

  String _getReadingTimeDisplay() {
    final dynamic readingTimeRaw = content['reading_time'];
    if (readingTimeRaw == null) return '';
    final String value = readingTimeRaw.toString().trim();
    final int? minutes = int.tryParse(value);
    if (minutes != null && minutes > 0) {
      return "Reading time: $minutes min";
    } else if (value.isNotEmpty) {
      return "Reading time: $value";
    }
    return '';
  }

  @override
  Widget build(BuildContext context) {
    final String? body = _getTextContent();
    final bool isHtml = body != null && _isHtmlContent(body ?? '');
    final String readingTimeText = _getReadingTimeDisplay();
    final String title = content['title']?.toString().trim() ?? 'Untitled Lesson';

    return Scaffold(
      appBar: AppBar(
        title: Text(
          title,
          style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
        ),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Optional Thumbnail
            if (content['thumbnail'] != null &&
                content['thumbnail'].toString().trim().isNotEmpty)
              ClipRRect(
                borderRadius: BorderRadius.circular(16),
                child: Image.network(
                  content['thumbnail'].toString().trim(),
                  height: 220,
                  width: double.infinity,
                  fit: BoxFit.cover,
                  errorBuilder: (_, __, ___) => Container(
                    height: 220,
                    color: Colors.grey[200],
                    child: const Icon(Icons.image_not_supported, size: 60, color: Colors.grey),
                  ),
                ),
              ),
            const SizedBox(height: 24),
            // Title
            Text(
              title,
              style: GoogleFonts.poppins(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: Colors.black87,
              ),
            ),
            const SizedBox(height: 12),
            // Reading Time
            if (readingTimeText.isNotEmpty)
              Row(
                children: [
                  const Icon(Icons.access_time, size: 18, color: Colors.grey),
                  const SizedBox(width: 6),
                  Text(
                    readingTimeText,
                    style: const TextStyle(color: Colors.grey, fontSize: 14),
                  ),
                ],
              ),
            if (readingTimeText.isNotEmpty) const SizedBox(height: 16),

            // === NEW: Listen Button (between title/reading time and divider) ===
            if (body != null)
              Center(
                child: Padding(
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  child: ElevatedButton.icon(
                    onPressed: () {
                      context.push(
                        '/courses/content/text-audio',
                        extra: {
                          'title': title,
                          'text': body,
                        },
                      );
                    },
                    icon: const Icon(Icons.headphones, size: 20),
                    label: const Text("Listen to this lesson"),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF6C5CE7),
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(30),
                      ),
                    ),
                  ),
                ),
              ),

            const Divider(height: 40, thickness: 1),

            // Main Text Content from ctext
            if (body != null)
              isHtml
                  ? Html(
                data: body,
                style: {
                  "body": Style(
                    fontSize: FontSize(17),
                    lineHeight: LineHeight(1.7),
                    margin: Margins.zero,
                  ),
                  "h1,h2,h3,h4,h5,h6": Style(
                    fontWeight: FontWeight.bold,
                    fontSize: FontSize(22),
                  ),
                  "p": Style(margin: Margins.symmetric(vertical: 12)),
                  "ul,ol": Style(margin: Margins.symmetric(vertical: 12)),
                  "li": Style(margin: Margins.only(left: 20)),
                  "img": Style(
                    width: Width(100, Unit.percent),
                    height: Height.auto(),
                    margin: Margins.symmetric(vertical: 20),
                    display: Display.block,
                  ),
                  "blockquote": Style(
                    backgroundColor: Colors.grey[100],
                    padding: HtmlPaddings.all(16),
                    margin: Margins.symmetric(vertical: 16),
                    border: Border(left: BorderSide(color: Colors.grey, width: 4)),
                  ),
                },
              )
                  : Text(
                body,
                style: const TextStyle(
                  fontSize: 17,
                  height: 1.7,
                  color: Colors.black87,
                ),
              )
            else
              const Center(
                child: Padding(
                  padding: EdgeInsets.symmetric(vertical: 60),
                  child: Text(
                    "No text content available.",
                    style: TextStyle(fontSize: 16, color: Colors.grey),
                  ),
                ),
              ),
            const SizedBox(height: 120), // Bottom padding for navigation
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\video_content_screen.dart =====

// lib/screens/course/contents/video_content_screen.dart
import 'package:flutter/material.dart';
import 'package:youtube_player_flutter/youtube_player_flutter.dart';

class VideoContentScreen extends StatefulWidget {
  final Map<String, dynamic> content;
  const VideoContentScreen({super.key, required this.content});

  @override
  State<VideoContentScreen> createState() => _VideoContentScreenState();
}

class _VideoContentScreenState extends State<VideoContentScreen> {
  late YoutubePlayerController _controller;

  @override
  void initState() {
    super.initState();
    final url = widget.content['video_url']?.toString() ?? widget.content['url']?.toString() ?? '';
    final videoId = YoutubePlayer.convertUrlToId(url) ?? '';

    _controller = YoutubePlayerController(
      initialVideoId: videoId.isNotEmpty ? videoId : 'dQw4w9WgXcQ', // fallback
      flags: const YoutubePlayerFlags(autoPlay: true, mute: false),
    );
  }

  @override
  Widget build(BuildContext context) {
    final desc = widget.content['description']?.toString() ?? '';

    return Column(
      children: [
        YoutubePlayer(
          controller: _controller,
          showVideoProgressIndicator: true,
          progressColors: const ProgressBarColors(
            playedColor: Color(0xFF6C5CE7),
            handleColor: Colors.purple,
          ),
        ),
        if (desc.isNotEmpty)
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(20),
              child: Text(desc, style: const TextStyle(fontSize: 16, height: 1.6)),
            ),
          ),
      ],
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\home\home_screen.dart =====

// lib/screens/home/home_screen.dart
import 'package:animate_do/animate_do.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

import '../../providers/user_provider.dart';
import '../../core/utils/user_preferences.dart';
import '../../providers/continue_learning_provider.dart'; // NEW IMPORT

class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen> with TickerProviderStateMixin {
  late AnimationController _fireController;

  @override
  void initState() {
    super.initState();
    _fireController = AnimationController(vsync: this);
  }

  @override
  void dispose() {
    _fireController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final userAsync = ref.watch(currentUserProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFF6C5CE7), Color(0xFF4A3CB7)],
          ),
        ),
        child: SafeArea(
          child: RefreshIndicator(
            onRefresh: () => ref.refresh(currentUserProvider.future),
            child: SingleChildScrollView(
              physics: const BouncingScrollPhysics(),
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // HEADER
                  Row(
                    children: [
                      Expanded(
                        child: userAsync.when(
                          data: (user) {
                            if (user != null) {
                              return Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text("Hello,", style: GoogleFonts.poppins(fontSize: 20, color: Colors.white70)),
                                  Text(user.name, style: GoogleFonts.poppins(fontSize: 32, fontWeight: FontWeight.bold, color: Colors.white)),
                                ],
                              );
                            } else {
                              return _buildFallbackHeader();
                            }
                          },
                          loading: () => _buildFallbackHeader(),
                          error: (_, __) => _buildFallbackHeader(),
                        ),
                      ),
                      CircleAvatar(
                        radius: 28,
                        backgroundColor: Colors.white24,
                        backgroundImage: FirebaseAuth.instance.currentUser?.photoURL != null
                            ? NetworkImage(FirebaseAuth.instance.currentUser!.photoURL!)
                            : null,
                        child: FirebaseAuth.instance.currentUser?.photoURL == null
                            ? const Icon(Icons.person, size: 36, color: Colors.white)
                            : null,
                      ),
                    ],
                  ),
                  const SizedBox(height: 30),

                  // Streak & Coins
                  userAsync.when(
                    data: (user) {
                      if (user != null) {
                        return Row(
                          children: [
                            Expanded(child: _streakCard(user.streak)),
                            const SizedBox(width: 16),
                            Expanded(child: _coinsCard(user.coins)),
                          ],
                        );
                      } else {
                        return _buildFallbackStats();
                      }
                    },
                    loading: () => _buildFallbackStats(),
                    error: (_, __) => _buildFallbackStats(),
                  ),
                  const SizedBox(height: 30),

                  // NEW: Dynamic Continue Learning Section
                  _buildContinueLearningSection(),

                  const SizedBox(height: 20),
                  _dailyChallengeCard(),
                  const SizedBox(height: 20),
                  _quickActions(),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  // Fallback Header (using cached data)
  Widget _buildFallbackHeader() {
    return FutureBuilder<Map<String, dynamic>?>(
      future: UserPreferences().getUserData(),
      builder: (context, snapshot) {
        final name = snapshot.data?['name'] ?? 'Warrior';
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Hello,", style: GoogleFonts.poppins(fontSize: 20, color: Colors.white70)),
            Text(name, style: GoogleFonts.poppins(fontSize: 32, fontWeight: FontWeight.bold, color: Colors.white)),
          ],
        );
      },
    );
  }

  // Fallback Stats (streak & coins)
  Widget _buildFallbackStats() {
    return FutureBuilder<Map<String, dynamic>?>(
      future: UserPreferences().getUserData(),
      builder: (context, snapshot) {
        final data = snapshot.data;
        final streak = data?['streak'] as int? ?? 7;
        final coins = data?['coins'] as int? ?? 1250;
        return Row(
          children: [
            Expanded(child: _streakCard(streak)),
            const SizedBox(width: 16),
            Expanded(child: _coinsCard(coins)),
          ],
        );
      },
    );
  }

  Widget _streakCard(int streak) => FadeInLeft(
    child: Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.2),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.white24),
      ),
      child: Column(
        children: [
          Lottie.asset('assets/lottie/fire.json', controller: _fireController, onLoaded: (c) {
            _fireController
              ..duration = c.duration
              ..repeat();
          }, height: 60),
          Text("$streak Day Streak", style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w600, color: Colors.white)),
          Text("Keep burning!", style: GoogleFonts.poppins(fontSize: 12, color: Colors.white70)),
        ],
      ),
    ),
  );

  Widget _coinsCard(int coins) => FadeInRight(
    child: Container(
      padding: const EdgeInsets.all(20),
      decoration: const BoxDecoration(
        gradient: LinearGradient(colors: [Colors.amber, Colors.orange]),
        borderRadius: BorderRadius.all(Radius.circular(20)),
      ),
      child: Column(
        children: [
          Lottie.asset('assets/lottie/coin.json', height: 60),
          Text(coins.toString(), style: GoogleFonts.poppins(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.white)),
          Text("Coins", style: GoogleFonts.poppins(fontSize: 14, color: Colors.white)),
        ],
      ),
    ),
  );

  Widget _dailyChallengeCard() => FadeInUp(
    delay: const Duration(milliseconds: 200),
    child: Container(
      padding: const EdgeInsets.all(24),
      decoration: const BoxDecoration(
        gradient: LinearGradient(colors: [Colors.pinkAccent, Colors.purple]),
        borderRadius: BorderRadius.all(Radius.circular(24)),
      ),
      child: Row(
        children: [
          Lottie.asset('assets/lottie/daily.json', width: 100),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text("Daily Challenge", style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.bold, color: Colors.white)),
                Text("Current Affairs Quiz", style: GoogleFonts.poppins(fontSize: 16, color: Colors.white)),
                const SizedBox(height: 12),
                ElevatedButton(
                  onPressed: () => context.push('/quizzes/daily'),
                  style: ElevatedButton.styleFrom(backgroundColor: Colors.white, foregroundColor: Colors.purple),
                  child: const Text("Start Now"),
                ),
              ],
            ),
          ),
        ],
      ),
    ),
  );

  Widget _quickActions() => FadeInUp(
    delay: const Duration(milliseconds: 400),
    child: GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: 2,
      mainAxisSpacing: 16,
      crossAxisSpacing: 16,
      childAspectRatio: 1.6,
      children: [
        _quickAction("Practice", Icons.menu_book, Colors.blue),
        _quickAction("Mock Test", Icons.timer, Colors.green),
        _quickAction("Leaderboard", Icons.emoji_events, Colors.orange),
        _quickAction("Certificates", Icons.card_membership, Colors.purple),
      ],
    ),
  );

  Widget _quickAction(String title, IconData icon, Color color) => Container(
    decoration: BoxDecoration(
      color: color.withOpacity(0.1),
      borderRadius: BorderRadius.circular(20),
      border: Border.all(color: color.withOpacity(0.3)),
    ),
    child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(icon, size: 48, color: color),
        const SizedBox(height: 12),
        Text(title, style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w600, color: color)),
      ],
    ),
  );

  // ==================== NEW: CONTINUE LEARNING SECTION ====================

  Widget _buildContinueLearningSection() {
    final userAsync = ref.watch(currentUserProvider);
    return userAsync.when(
      data: (user) {
        if (user == null) return const SizedBox.shrink();
        final progressAsync = ref.watch(continueLearningProvider(user.id));
        return progressAsync.when(
          loading: () => _continueSkeleton(),
          error: (_, __) => const SizedBox.shrink(),
          data: (courses) {
            if (courses.isEmpty) return const SizedBox.shrink();
            return Column(
              children: courses.map((item) => _continueCourseCard(item)).toList(),
            );
          },
        );
      },
      loading: () => _continueSkeleton(),
      error: (_, __) => const SizedBox.shrink(),
    );
  }

  Widget _continueCourseCard(Map<String, dynamic> item) => FadeInUp(
    child: GestureDetector(
      onTap: () {
        final courseId = int.tryParse(item['course_quiz_id']?.toString() ?? '');
        if (courseId != null && courseId > 0) {
          context.push('/courses/detail/$courseId');
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.all(24),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(24),
          boxShadow: const [
            BoxShadow(color: Colors.black12, blurRadius: 20),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "Continue Learning",
              style: GoogleFonts.poppins(
                fontSize: 18,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                ClipRRect(
                  borderRadius: BorderRadius.circular(16),
                  child: Image.network(
                    item['course_image'] ?? '',
                    width: 80,
                    height: 80,
                    fit: BoxFit.cover,
                    errorBuilder: (_, __, ___) => Container(
                      width: 80,
                      height: 80,
                      color: Colors.grey[300],
                      child: const Icon(Icons.menu_book, color: Colors.grey),
                    ),
                    loadingBuilder: (_, child, loadingProgress) {
                      if (loadingProgress == null) return child;
                      return Container(
                        width: 80,
                        height: 80,
                        color: Colors.grey[300],
                        child: const Center(child: CircularProgressIndicator(strokeWidth: 2)),
                      );
                    },
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        item['title'] ?? 'Untitled Course',
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 8),
                      LinearProgressIndicator(
                        value: (double.tryParse(item['progress_percentage']?.toString() ?? '0') ?? 0) / 100,
                        backgroundColor: Colors.grey[300],
                        valueColor: const AlwaysStoppedAnimation(Color(0xFF6C5CE7)),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        "${item['progress_percentage'] ?? '0'}% Complete",
                        style: GoogleFonts.poppins(fontSize: 14),
                      ),
                    ],
                  ),
                ),
                const Icon(
                  Icons.arrow_forward_ios,
                  color: Color(0xFF6C5CE7),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );

  Widget _continueSkeleton() => FadeInUp(
    child: Container(
      height: 160,
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.1),
        borderRadius: BorderRadius.circular(24),
      ),
    ),
  );
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\leaderboard\leaderboard_screen.dart =====

// lib/screens/leaderboard/leaderboard_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:animate_do/animate_do.dart';
import '../../providers/user_provider.dart';
import '../../core/services/api_service.dart';

class LeaderboardEntry {
  final int rank;
  final int userId;
  final String name;
  final String? profilePicture;
  final int score;
  final bool isCurrentUser;

  LeaderboardEntry({
    required this.rank,
    required this.userId,
    required this.name,
    this.profilePicture,
    required this.score,
    this.isCurrentUser = false,
  });
}

enum LeaderboardType { global, quiz, course }

// Providers remain unchanged
final currentUserIdProvider = FutureProvider<int?>((ref) async {
  final user = await ref.watch(currentUserProvider.future);
  return user?.id;
});

final globalLeaderboardProvider = FutureProvider<List<LeaderboardEntry>>((ref) async {
  final api = ref.read(apiProvider);
  final response = await api.get('/leaderboard');
  final data = (response['data'] as List<dynamic>?) ?? [];
  return data.asMap().entries.map((e) {
    final index = e.key;
    final item = e.value as Map<String, dynamic>;
    return LeaderboardEntry(
      rank: index + 1,
      userId: int.tryParse(item['id']?.toString() ?? '0') ?? 0,
      name: item['name']?.toString() ?? 'Anonymous',
      profilePicture: item['profile_picture'] as String?,
      score: int.tryParse(item['total_score']?.toString() ?? '0') ??
          int.tryParse(item['score']?.toString() ?? '0') ??
          0,
    );
  }).toList();
});

final personalLeaderboardProvider = FutureProvider.family<List<LeaderboardEntry>, LeaderboardType>((ref, type) async {
  final userId = await ref.watch(currentUserIdProvider.future);
  if (userId == null) return [];
  final api = ref.read(apiProvider);
  String path = '/leaderboard/$userId';
  if (type == LeaderboardType.quiz) path += '/quiz';
  if (type == LeaderboardType.course) path += '/course';
  final response = await api.get(path);
  final data = (response['data'] as List<dynamic>?) ?? [];
  return data.map((itemRaw) {
    final item = itemRaw as Map<String, dynamic>;
    final isCurrent = (int.tryParse(item['id']?.toString() ?? '0') ?? 0) == userId;
    return LeaderboardEntry(
      rank: int.tryParse(item['rank']?.toString() ?? '0') ?? 0,
      userId: int.tryParse(item['id']?.toString() ?? '0') ?? 0,
      name: item['name']?.toString() ?? 'Anonymous',
      profilePicture: item['profile_picture'] as String?,
      score: int.tryParse(item['score']?.toString() ?? '0') ??
          int.tryParse(item['total_score']?.toString() ?? '0') ??
          0,
      isCurrentUser: isCurrent,
    );
  }).toList();
});

class LeaderboardScreen extends ConsumerStatefulWidget {
  const LeaderboardScreen({super.key});

  @override
  ConsumerState<LeaderboardScreen> createState() => _LeaderboardScreenState();
}

class _LeaderboardScreenState extends ConsumerState<LeaderboardScreen>
    with TickerProviderStateMixin {
  late final TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final currentUserAsync = ref.watch(currentUserProvider);
    return Scaffold(
      body: SafeArea( // ðŸ‘ˆ ONLY CHANGE: Wrap in SafeArea
        child: Column(
          children: [
            // Gradient Header
            Container(
              width: double.infinity,
              padding: const EdgeInsets.only(top: 48, bottom: 24), // ðŸ‘ˆ ONLY CHANGE: Reduced padding
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  colors: [Color(0xFF6C5CE7), Color(0xFFa29bfe)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
              ),
              child: Column(
                children: [
                  FadeInDown(
                    child: const Icon(Icons.emoji_events_rounded, size: 90, color: Colors.amber),
                  ),
                  const SizedBox(height: 16),
                  FadeInUp(
                    child: const Text(
                      'Leaderboard',
                      style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold, color: Colors.white),
                    ),
                  ),
                  const SizedBox(height: 12),
                  currentUserAsync.when(
                    data: (user) => FadeIn(
                      child: Text(
                        user != null
                            ? 'Streak: ${user.streak} ðŸ”¥ â€¢ Coins: ${user.coins} ðŸª™'
                            : 'Log in to compete',
                        style: const TextStyle(fontSize: 16, color: Colors.white70),
                      ),
                    ),
                    loading: () => const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2),
                    ),
                    error: (_, __) => const Text('Stats unavailable', style: TextStyle(color: Colors.white70)),
                  ),
                ],
              ),
            ),
            // Tabs
            TabBar(
              controller: _tabController,
              labelColor: Theme.of(context).colorScheme.primary,
              unselectedLabelColor: Colors.grey,
              labelStyle: const TextStyle(fontWeight: FontWeight.bold),
              indicatorColor: Theme.of(context).colorScheme.primary,
              tabs: const [
                Tab(text: 'Global'),
                Tab(text: 'Quiz Masters'),
                Tab(text: 'Course Champions'),
              ],
            ),
            // Tab Views
            Expanded(
              child: TabBarView(
                controller: _tabController,
                children: [
                  _buildLeaderboardTab(globalLeaderboardProvider, false),
                  _buildLeaderboardTab(personalLeaderboardProvider(LeaderboardType.quiz), true),
                  _buildLeaderboardTab(personalLeaderboardProvider(LeaderboardType.course), true),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLeaderboardTab(
      ProviderListenable<AsyncValue<List<LeaderboardEntry>>> provider,
      bool highlightCurrentUser,
      ) {
    final asyncValue = ref.watch(provider);
    return asyncValue.when(
      data: (entries) => _buildList(entries, highlightCurrentUser, provider),
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.sentiment_dissatisfied, size: 64, color: Colors.grey),
              const SizedBox(height: 16),
              const Text('Failed to load leaderboard', style: TextStyle(fontSize: 18)),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                onPressed: () => ref.invalidate(provider as ProviderBase), // Safe cast
                icon: const Icon(Icons.refresh),
                label: const Text('Retry'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildList(
      List<LeaderboardEntry> entries,
      bool highlightCurrentUser,
      ProviderListenable<AsyncValue<List<LeaderboardEntry>>> provider,
      ) {
    if (entries.isEmpty) {
      return const Center(
        child: Text(
          'No rankings yet.\nBe the first! ðŸ†',
          textAlign: TextAlign.center,
          style: TextStyle(fontSize: 18, color: Colors.grey),
        ),
      );
    }
    return RefreshIndicator(
      onRefresh: () async {
        ref.invalidate(provider as ProviderBase);
      },
      child: ListView.builder(
        physics: const AlwaysScrollableScrollPhysics(),
        padding: const EdgeInsets.all(16),
        itemCount: entries.length,
        itemBuilder: (context, index) {
          final entry = entries[index];
          final isTop3 = entry.rank <= 3;
          return FadeInLeft(
            duration: Duration(milliseconds: 500 + index * 100),
            child: Card(
              margin: const EdgeInsets.symmetric(vertical: 8),
              elevation: entry.isCurrentUser ? 12 : 4,
              color: entry.isCurrentUser
                  ? Theme.of(context).colorScheme.primaryContainer.withOpacity(0.4)
                  : null,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
              child: ListTile(
                contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                leading: Stack(
                  children: [
                    CircleAvatar(
                      radius: 30,
                      backgroundImage: entry.profilePicture != null
                          ? NetworkImage(entry.profilePicture!)
                          : null,
                      backgroundColor: Theme.of(context).colorScheme.primaryContainer,
                      child: entry.profilePicture == null
                          ? Text(
                        entry.name.isNotEmpty ? entry.name[0].toUpperCase() : '?',
                        style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                      )
                          : null,
                    ),
                    if (isTop3)
                      Positioned(
                        right: -6,
                        bottom: -6,
                        child: Icon(
                          Icons.star_rounded,
                          size: 32,
                          color: entry.rank == 1
                              ? Colors.amber
                              : entry.rank == 2
                              ? Colors.grey.shade400
                              : const Color(0xFFCD7F32), // Bronze
                        ),
                      ),
                  ],
                ),
                title: Text(
                  entry.name,
                  style: TextStyle(
                    fontWeight: entry.isCurrentUser ? FontWeight.bold : FontWeight.w600,
                    fontSize: 16,
                  ),
                ),
                subtitle: entry.isCurrentUser
                    ? const Text('You', style: TextStyle(fontWeight: FontWeight.bold, color: Color(0xFF6C5CE7)))
                    : null,
                trailing: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Text(
                      '#${entry.rank}',
                      style: TextStyle(
                        fontSize: 28,
                        fontWeight: FontWeight.bold,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                    ),
                    Text(
                      '${entry.score} pts',
                      style: const TextStyle(fontSize: 14, color: Colors.grey),
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\about_prepking_screen.dart =====

// lib/screens/profile/about_prepking_screen.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

class AboutPrepKingScreen extends StatelessWidget {
  const AboutPrepKingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("About PrepKing"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      backgroundColor: const Color(0xFFF8FAFC),
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Center(
              child: Lottie.asset(
                'assets/lottie/splash.json',
                width: 140,
                height: 140,
                fit: BoxFit.contain,
                errorBuilder: (_, __, ___) => Image.asset(
                  'assets/images/logo.png',
                  width: 120,
                  height: 120,
                  errorBuilder: (_, __, ___) => const Icon(Icons.school, size: 100, color: Color(0xFF6C5CE7)),
                ),
              ),
            ),
            const SizedBox(height: 32),
            Text(
              "PrepKing",
              style: GoogleFonts.poppins(fontSize: 32, fontWeight: FontWeight.bold, color: const Color(0xFF2D3436)),
            ),
            const SizedBox(height: 12),
            Text(
              "A modern learning platform built for students, by educators.",
              style: GoogleFonts.poppins(fontSize: 16, color: Colors.grey[700], height: 1.5),
            ),
            const SizedBox(height: 32),
            _buildInfoRow("Version", "1.0.0"),
            _buildInfoRow("Made in", "India ðŸ‡®ðŸ‡³"),
            _buildInfoRow("Technology", "Flutter â€¢ Firebase â€¢ Riverpod"),
            const SizedBox(height: 40),
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: Colors.grey.shade200),
              ),
              child: Row(
                children: [
                  Icon(Icons.info_outline, color: Colors.grey[700]),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      "PrepKing is committed to providing a distraction-free, ad-free, and safe learning environment for students across India.",
                      style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        children: [
          Text(
            "$label: ",
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600, color: Colors.grey[700]),
          ),
          Text(
            value,
            style: GoogleFonts.poppins(fontWeight: FontWeight.w500, color: const Color(0xFF2D3436)),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\certificates_screen.dart =====

// lib/screens/profile/certificates_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../../providers/user_provider.dart';
import '../../providers/certificate_provider.dart';

class CertificatesScreen extends ConsumerWidget {
  const CertificatesScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(currentUserProvider).value!;
    final certs = ref.watch(certificatesProvider(user.id));

    return Scaffold(
      appBar: AppBar(
        title: const Text("My Certificates"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
      ),
      body: certs.when(
        loading: () => const Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
        error: (_, __) => const Center(child: Text("Failed to load certificates")),
        data: (list) => list.isEmpty
            ? Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.workspace_premium, size: 80, color: Colors.grey),
              const SizedBox(height: 16),
              Text("No certificates yet", style: GoogleFonts.poppins(fontSize: 18)),
              const SizedBox(height: 8),
              Text("Complete courses to earn certificates!", style: TextStyle(color: Colors.grey)),
            ],
          ),
        )
            : ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: list.length,
          itemBuilder: (_, i) => Card(
            margin: const EdgeInsets.only(bottom: 12),
            child: ListTile(
              leading: const Icon(Icons.workspace_premium, color: Color(0xFF6C5CE7)),
              title: Text(list[i]['title'] ?? 'Certificate', style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
              subtitle: Text("Issued on: ${list[i]['issued_on'] ?? 'N/A'}", style: GoogleFonts.poppins(fontSize: 13)),
            ),
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\coin_store_screen.dart =====

// lib/screens/profile/coin_store_screen.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

class CoinStoreScreen extends StatelessWidget {
  const CoinStoreScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Coin Store"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      backgroundColor: const Color(0xFFF8FAFC),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Lottie.asset(
                'assets/lottie/coin.json',
                width: 160,
                height: 160,
                fit: BoxFit.contain,
                repeat: true,
              ),
              const SizedBox(height: 32),
              Text(
                "Coming Soon ðŸš€",
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  color: const Color(0xFF2D3436),
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              Text(
                "Earn coins by learning, completing quizzes, and climbing the leaderboard!",
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 40),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
                decoration: BoxDecoration(
                  color: Colors.grey[100],
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: Colors.grey.shade200),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(Icons.info_outline, color: Colors.grey[700]),
                    const SizedBox(width: 12),
                    Flexible(
                      child: Text(
                        "Coins can be used to unlock premium content, hints, and exclusive badges.",
                        style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\edit_profile_screen.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../../models/user_model.dart';
import '../../providers/user_provider.dart';
import '../../core/services/api_service.dart';

class EditProfileScreen extends ConsumerStatefulWidget {
  const EditProfileScreen({super.key});

  @override
  ConsumerState<EditProfileScreen> createState() => _EditProfileScreenState();
}

class _EditProfileScreenState extends ConsumerState<EditProfileScreen> {
  late TextEditingController nameCtrl;
  late TextEditingController mobileCtrl;
  bool saving = false;

  @override
  void initState() {
    super.initState();
    final user = ref.read(currentUserProvider).value!;
    nameCtrl = TextEditingController(text: user.name);
    mobileCtrl = TextEditingController(text: user.mobile ?? '');
  }

  Future<void> _save(UserModel user) async {
    setState(() => saving = true);
    try {
      final api = ref.read(apiServiceProvider);
      await api.put(
        '/user/${user.id}',
        {
          'name': nameCtrl.text.trim(),
          'mobile': mobileCtrl.text.trim(),
        },
      );
      ref.read(refreshUserDataProvider)();
      if (mounted) Navigator.pop(context);
    } catch (e) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text('Update failed: $e')));
    } finally {
      setState(() => saving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = ref.watch(currentUserProvider).value!;
    return Scaffold(
      appBar: AppBar(
        title: const Text("Edit Profile"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
      ),
      body: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            TextField(
              controller: nameCtrl,
              style: GoogleFonts.poppins(),
              decoration: InputDecoration(
                labelText: 'Name',
                labelStyle: GoogleFonts.poppins(),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: mobileCtrl,
              keyboardType: TextInputType.phone,
              style: GoogleFonts.poppins(),
              decoration: InputDecoration(
                labelText: 'Mobile',
                labelStyle: GoogleFonts.poppins(),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
              ),
            ),
            const Spacer(),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: saving ? null : () => _save(user),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF6C5CE7),
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
                child: saving
                    ? const CircularProgressIndicator(color: Colors.white)
                    : const Text("Save Changes", style: TextStyle(fontWeight: FontWeight.bold)),
              ),
            )
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\help_support_screen.dart =====

// lib/screens/profile/help_support_screen.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:url_launcher/url_launcher.dart';

class HelpSupportScreen extends StatelessWidget {
  const HelpSupportScreen({super.key});

  Future<void> _launchEmail() async {
    final Uri emailUri = Uri(
      scheme: 'mailto',
      path: 'support@prepking.in',
      queryParameters: const {'subject': 'PrepKing Support Request'},
    );
    if (await canLaunchUrl(emailUri)) {
      await launchUrl(emailUri);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Help & Support"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      backgroundColor: const Color(0xFFF8FAFC),
      body: Padding(
        padding: const EdgeInsets.all(20),
        child: ListView(
          children: [
            Center(
              child: Lottie.asset(
                'assets/lottie/help.json',
                width: 160,
                height: 160,
                fit: BoxFit.contain,
                errorBuilder: (_, __, ___) => const Icon(Icons.help_outline, size: 120, color: Color(0xFF6C5CE7)),
              ),
            ),
            const SizedBox(height: 32),
            _buildSupportCard(
              icon: Icons.email_outlined,
              title: "Email Support",
              subtitle: "support@prepking.in",
              onTap: _launchEmail,
            ),
            const SizedBox(height: 16),
            _buildSupportCard(
              icon: Icons.help_outline,
              title: "Frequently Asked Questions",
              subtitle: "Find answers to common questions",
              onTap: () {
                // Placeholder for future FAQ screen
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text("FAQ section coming soon!")),
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSupportCard({
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: ListTile(
        leading: Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: const Color(0xFF6C5CE7).withOpacity(0.1),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Icon(icon, color: const Color(0xFF6C5CE7), size: 28),
        ),
        title: Text(
          title,
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600, fontSize: 16),
        ),
        subtitle: Text(
          subtitle,
          style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
        ),
        trailing: const Icon(Icons.arrow_forward_ios, color: Colors.grey, size: 18),
        onTap: onTap,
        contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 12),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\profile_screen.dart =====

// lib/screens/profile/profile_screen.dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:lottie/lottie.dart';
import '../../core/utils/user_preferences.dart';
import '../../models/user_model.dart';
import '../../providers/user_progress_merged_provider.dart';
import '../../providers/user_provider.dart';
import '../../widgets/profile_menu_tile.dart';

// Shared GoogleSignIn instance
final GoogleSignIn googleSignIn = GoogleSignIn();

class ProfileScreen extends ConsumerWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userAsync = ref.watch(currentUserProvider);

    return userAsync.when(
      loading: () => _buildLoadingScreen(),
      error: (err, stack) => _ProfileError(
        onRetry: () => ref.invalidate(currentUserProvider),
      ),
      data: (user) {
        if (user == null) {
          return _NotLoggedInView();
        }
        return _ProfileContent(
          user: user,
          onLogout: () => _showLogoutDialog(context, ref),
        );
      },
    );
  }

  Widget _buildLoadingScreen() {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset('assets/lottie/loading.json', width: 100, height: 100),
            const SizedBox(height: 16),
            Text(
              'Loading your profile...',
              style: GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _showLogoutDialog(BuildContext context, WidgetRef ref) async {
    final shouldLogout = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text("Logout", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: Text(
          "Are you sure you want to logout?\nYour progress is saved.",
          style: GoogleFonts.poppins(),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext, false),
            child: Text("Cancel", style: GoogleFonts.poppins(color: Colors.grey[700])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),
            onPressed: () => Navigator.pop(dialogContext, true),
            child: Text("Logout", style: GoogleFonts.poppins(color: Colors.white)),
          ),
        ],
      ),
    );

    if (shouldLogout != true || !context.mounted) return;

    try {
      // Firebase sign-out
      await FirebaseAuth.instance.signOut();

      // Google sign-out (if applicable)
      try {
        if (await googleSignIn.isSignedIn()) {
          await googleSignIn.signOut();
        }
      } catch (e) {
        debugPrint("Google sign out error: $e");
      }

      // Clear local prefs
      await UserPreferences().clearAll();

      // Invalidate providers
      ref.read(refreshUserDataProvider)();
      ref.invalidate(currentUserProvider);
      ref.invalidate(userWithProgressProvider);

      // Navigate to login
      if (context.mounted) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (context.mounted) {
            context.go('/login');
          }
        });
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Logout failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}

// â”€â”€â”€ Error State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _ProfileError extends StatelessWidget {
  final VoidCallback onRetry;
  const _ProfileError({required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text("Failed to load profile", style: GoogleFonts.poppins()),
            TextButton(
              onPressed: onRetry,
              child: const Text("Retry"),
            ),
          ],
        ),
      ),
    );
  }
}

// â”€â”€â”€ Not Logged In State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _NotLoggedInView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings_outlined, color: Colors.grey),
            onPressed: () => context.push('/profile/settings'),
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text("No user logged in", style: GoogleFonts.poppins(fontSize: 18)),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () => context.go('/login'),
              child: Text("Go to Login", style: GoogleFonts.poppins()),
            ),
          ],
        ),
      ),
    );
  }
}

// â”€â”€â”€ Main Profile Content â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _ProfileContent extends StatelessWidget {
  final UserModel user;
  final VoidCallback onLogout;

  const _ProfileContent({
    required this.user,
    required this.onLogout,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings_outlined, color: Colors.grey),
            onPressed: () => context.push('/profile/settings'),
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () async {
          final ref = ProviderScope.containerOf(context, listen: false);
          ref.invalidate(currentUserProvider);
          ref.invalidate(userWithProgressProvider);
        },
        child: ListView(
          padding: const EdgeInsets.only(bottom: 40),
          children: [
            // â”€â”€â”€ Profile Header â”€â”€â”€
            Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                children: [
                  CircleAvatar(
                    radius: 64,
                    backgroundColor: Colors.grey.shade200,
                    backgroundImage: user.profilePicture != null
                        ? CachedNetworkImageProvider(user.profilePicture!)
                        : (FirebaseAuth.instance.currentUser?.photoURL != null
                        ? CachedNetworkImageProvider(FirebaseAuth.instance.currentUser!.photoURL!)
                        : null),
                    child: (user.profilePicture == null &&
                        FirebaseAuth.instance.currentUser?.photoURL == null)
                        ? const Icon(Icons.person, size: 80, color: Colors.grey)
                        : null,
                  ),
                  const SizedBox(height: 20),
                  Text(
                    user.name,
                    style: GoogleFonts.poppins(
                      fontSize: 28,
                      fontWeight: FontWeight.bold,
                      color: const Color(0xFF2D3436),
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 6),
                  Text(
                    user.email,
                    style: GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
                  ),
                  if (user.mobile != null && user.mobile!.isNotEmpty) ...[
                    const SizedBox(height: 4),
                    Text(
                      user.mobile!,
                      style: GoogleFonts.poppins(fontSize: 15, color: Colors.grey[500]),
                    ),
                  ],
                  const SizedBox(height: 32),
                  // â”€â”€â”€ Stats Row â”€â”€â”€
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      _buildStat("${user.coins}", "Coins", 'assets/lottie/coin.json'),
                      _buildStat("${user.streak}", "Day Streak", 'assets/lottie/fire.json'),
                      _buildStat("0", "Certificates", 'assets/lottie/trophy.json'),
                    ],
                  ),
                ],
              ),
            ),
            const SizedBox(height: 20),
            // â”€â”€â”€ Menu Section â”€â”€â”€
            Container(
              margin: const EdgeInsets.symmetric(horizontal: 20),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.05),
                    blurRadius: 15,
                    offset: const Offset(0, 5),
                  ),
                ],
              ),
              child: Column(
                children: [
                  ProfileMenuTile(
                    icon: Icons.person_outline,
                    title: "Edit Profile",
                    onTap: () => context.push('/profile/edit'),
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.card_membership_outlined,
                    title: "My Certificates",
                    trailing: const Icon(Icons.chevron_right),
                    onTap: () => context.push('/profile/certificates'),
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.history,
                    title: "Quiz History",
                    trailing: const Icon(Icons.chevron_right),
                    onTap: () => context.push('/profile/history'),
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.emoji_events_outlined,
                    title: "Leaderboard Rank",
                    trailing: Text(
                      "#--",
                      style: GoogleFonts.poppins(fontWeight: FontWeight.w600, color: const Color(0xFF6C5CE7)),
                    ),
                    onTap: () => context.go('/leaderboard'),
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.wallet,
                    title: "Coin Store",
                    trailing: const Icon(Icons.chevron_right),
                    onTap: () => context.push('/profile/coins'), // â† Changed
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.help_outline,
                    title: "Help & Support",
                    trailing: const Icon(Icons.chevron_right), // Added trailing for consistency
                    onTap: () => context.push('/profile/help'), // â† Changed
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.info_outline,
                    title: "About PrepKing",
                    trailing: const Icon(Icons.chevron_right), // Added trailing for consistency
                    onTap: () => context.push('/profile/about'), // â† Changed
                  ),
                ],
              ),
            ),
            const SizedBox(height: 40),
            // â”€â”€â”€ Logout Button â”€â”€â”€
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 40),
              child: OutlinedButton(
                style: OutlinedButton.styleFrom(
                  foregroundColor: Colors.redAccent,
                  side: const BorderSide(color: Colors.redAccent),
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                ),
                onPressed: onLogout,
                child: Text(
                  "Logout",
                  style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w600),
                ),
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }

  static Widget _buildStat(String value, String label, String lottieAsset) {
    return Column(
      children: [
        Lottie.asset(lottieAsset, height: 60, fit: BoxFit.contain),
        const SizedBox(height: 8),
        Text(
          value,
          style: GoogleFonts.poppins(
            fontSize: 26,
            fontWeight: FontWeight.bold,
            color: const Color(0xFF2D3436),
          ),
        ),
        Text(
          label,
          style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
        ),
      ],
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\quiz_history_screen.dart =====

// lib/screens/profile/quiz_history_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart';
import '../../providers/user_provider.dart';
import '../../providers/quiz_history_provider.dart';

class QuizHistoryScreen extends ConsumerWidget {
  const QuizHistoryScreen({super.key});

  String _formatDate(String? dateStr) {
    if (dateStr == null || dateStr.isEmpty) return 'Unknown Date';
    try {
      final date = DateTime.parse(dateStr.split(' ').first);
      return DateFormat('dd MMM yyyy').format(date);
    } catch (e) {
      return dateStr.split(' ').first;
    }
  }

  Color _getStatusColor(String status) {
    switch (status) {
      case 'completed':
        return Colors.green;
      case 'in_progress':
        return Colors.orange;
      default:
        return Colors.grey;
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(currentUserProvider).value!;
    final historyAsync = ref.watch(quizHistoryProvider(user.id));

    return Scaffold(
      appBar: AppBar(
        title: const Text("Quiz History"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      backgroundColor: const Color(0xFFF8FAFC),
      body: historyAsync.when(
        loading: () => const Center(
          child: CircularProgressIndicator(color: Color(0xFF6C5CE7)),
        ),
        error: (_, __) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text(
                "Failed to load history",
                style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w600),
              ),
              const SizedBox(height: 8),
              ElevatedButton(
                onPressed: () => ref.refresh(quizHistoryProvider(user.id)),
                child: const Text("Retry"),
              ),
            ],
          ),
        ),
        data: (list) => list.isEmpty
            ? Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.history, size: 80, color: Colors.grey[400]),
              const SizedBox(height: 24),
              Text(
                "No quiz attempts yet",
                style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.w600, color: Colors.grey[700]),
              ),
              const SizedBox(height: 12),
              Text(
                "Your completed and in-progress quizzes will appear here",
                style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        )
            : ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: list.length,
          itemBuilder: (context, i) {
            final attempt = list[i];
            final isCompleted = attempt['status'] == 'completed';

            return Card(
              elevation: 4,
              margin: const EdgeInsets.only(bottom: 12),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              child: InkWell(
                borderRadius: BorderRadius.circular(16),
                onTap: isCompleted
                    ? () {
                  context.push('/quiz-review', extra: {
                    'attemptId': attempt['id'],
                    'testName': attempt['quiz_title'],
                  });
                }
                    : null,
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Container(
                            padding: const EdgeInsets.all(8),
                            decoration: BoxDecoration(
                              color: _getStatusColor(attempt['status']).withOpacity(0.1),
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Icon(
                              isCompleted ? Icons.check_circle : Icons.timer,
                              color: _getStatusColor(attempt['status']),
                              size: 28,
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  attempt['quiz_title'] ?? 'Untitled Quiz',
                                  style: GoogleFonts.poppins(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  _formatDate(attempt['display_date']),
                                  style: GoogleFonts.poppins(
                                    fontSize: 13,
                                    color: Colors.grey[600],
                                  ),
                                ),
                              ],
                            ),
                          ),
                          if (isCompleted)
                            Icon(Icons.arrow_forward_ios, color: Colors.grey[400], size: 18),
                        ],
                      ),
                      const SizedBox(height: 12),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          _buildInfoChip(
                            label: "Score",
                            value: attempt['display_score'],
                            icon: Icons.bar_chart,
                            color: isCompleted ? Colors.blue : Colors.grey,
                          ),
                          _buildInfoChip(
                            label: "Status",
                            value: attempt['status'] == 'completed' ? 'Completed' : 'In Progress',
                            icon: isCompleted ? Icons.done_all : Icons.pending,
                            color: _getStatusColor(attempt['status']),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildInfoChip({
    required String label,
    required String value,
    required IconData icon,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: color),
          const SizedBox(width: 6),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: GoogleFonts.poppins(fontSize: 11, color: Colors.grey[600]),
              ),
              Text(
                value,
                style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: color),
              ),
            ],
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\settings_screen.dart =====

// lib/screens/profile/settings_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:url_launcher/url_launcher.dart';
import '../../core/constants/api_constants.dart';
import '../../core/services/api_service.dart';
import '../../providers/user_provider.dart';
class SettingsScreen extends ConsumerStatefulWidget {
  const SettingsScreen({super.key});
  @override
  ConsumerState<SettingsScreen> createState() => _SettingsScreenState();
}
class _SettingsScreenState extends ConsumerState<SettingsScreen> {
  bool _isLoading = false;
  bool? _localNotificationValue;
  Future<void> _updateUserSettings(Map<String, dynamic> updates) async {
    if (_isLoading) return;
    setState(() => _isLoading = true);
    try {
      // Use .watch to get the latest user value (important for immediate UI feedback)
      final userAsync = ref.watch(currentUserProvider);
      final user = userAsync.value;
      if (user == null) throw Exception('User not logged in');
      final api = ref.read(apiServiceProvider);
      // Map internal keys to exact API field names
      final Map<String, dynamic> payload = {};
      if (updates.containsKey('notifications_enabled')) {
        payload['isNotificationEnabled'] = updates['notifications_enabled'] ? 1 : 0;
      }
      if (updates.containsKey('theme')) {
        payload['theme'] = updates['theme'] == 'dark' ? 'Dark' : 'Light';
      }
      final response = await api.put('/user/${user.id}', payload);
      if (response['success'] == true) {
        // Force refresh user data so the switch updates immediately
        ref.read(refreshUserDataProvider)();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Settings updated successfully'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        throw Exception(response['message'] ?? 'Update failed');
      }
    } catch (e) {
      debugPrint('Settings update error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to update settings: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
  Future<void> _launchPrivacyPolicy() async {
    // Replace with your actual privacy policy URL
    //const urlString = 'https://prepking.in/privacy-policy';
    final url = Uri.parse(ApiConstants.privacyUrl);
    if (await canLaunchUrl(url)) {
      await launchUrl(url, mode: LaunchMode.externalApplication);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Could not open privacy policy')),
      );
    }
  }
  @override
  Widget build(BuildContext context) {
    final userAsync = ref.watch(currentUserProvider);
    return Scaffold(
      appBar: AppBar(
        title: Text('Settings', style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        backgroundColor: Colors.transparent,
        elevation: 0,
      ),
      body: userAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (err, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text('Error loading settings: $err'),
            ],
          ),
        ),
        data: (user) {
          if (user == null) {
            return const Center(child: Text('User not logged in'));
          }
          return Stack(
            children: [
              ListView(
                padding: const EdgeInsets.all(16),
                children: [
                  // â”€â”€â”€ Notifications â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: SwitchListTile(
                      title: Text(
                        'Enable Notifications',
                        style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w500),
                      ),
                      subtitle: Text(
                        'Receive quiz reminders and updates',
                        style: GoogleFonts.poppins(color: Colors.grey[600]),
                      ),
                      value: _localNotificationValue ?? user.notificationsEnabled,
                      onChanged: _isLoading
                          ? null
                          : (bool value) async {
                        setState(() {
                          _localNotificationValue = value; // instant UI
                        });
                        await _updateUserSettings({'notifications_enabled': value});
                        _localNotificationValue = null; // reset after sync
                      },
                      activeColor: const Color(0xFF6C5CE7),
                    ),
                  ),
                  const SizedBox(height: 12),
                  // â”€â”€â”€ Theme â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: ListTile(
                      title: Text(
                        'Theme',
                        style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w500),
                      ),
                      subtitle: Text(
                        'Choose your preferred appearance',
                        style: GoogleFonts.poppins(color: Colors.grey[600]),
                      ),
                      trailing: DropdownButton<String>(
                        value: user.theme.toLowerCase(),
                        underline: const SizedBox(),
                        items: const [
                          DropdownMenuItem(value: 'light', child: Text('Light')),
                          DropdownMenuItem(value: 'dark', child: Text('Dark')),
                        ],
                        onChanged: _isLoading
                            ? null
                            : (String? value) {
                          if (value != null) {
                            _updateUserSettings({'theme': value});
                          }
                        },
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  // â”€â”€â”€ Privacy Policy â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: ListTile(
                      leading: const Icon(Icons.policy, color: Color(0xFF6C5CE7)),
                      title: Text(
                        'Privacy Policy',
                        style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w500),
                      ),
                      trailing: const Icon(Icons.open_in_new),
                      onTap: _launchPrivacyPolicy,
                    ),
                  ),
                  const SizedBox(height: 20),
                ],
              ),
              // Loading overlay
              if (_isLoading)
                Container(
                  color: Colors.black26,
                  child: const Center(
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF6C5CE7)),
                    ),
                  ),
                ),
            ],
          );
        },
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\daily_quizzes_screen.dart =====

// lib/screens/quizzes/daily_quizzes_screen.dart â€” FINAL VERSION WITH NORMALIZATION FIX
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import '../../core/services/api_service.dart';

/// Provider for fetching Daily Quizzes
/// Endpoint: https://quizard.in/api_002.php/saved_quiz?type=quiz_daily
final dailyQuizzesProvider = FutureProvider<List<dynamic>>((ref) async {
  final api = ref.read(apiServiceProvider);
  final response = await api.get('/saved_quiz', query: {'type': 'quiz_daily'});
  if (response is Map<String, dynamic> &&
      response['success'] == true &&
      response['data'] is List) {
    return List<dynamic>.from(response['data']);
  }
  return [];
});

class DailyQuizzesScreen extends ConsumerStatefulWidget {
  const DailyQuizzesScreen({super.key});

  @override
  ConsumerState<DailyQuizzesScreen> createState() => _DailyQuizzesScreenState();
}

class _DailyQuizzesScreenState extends ConsumerState<DailyQuizzesScreen> {
  @override
  Widget build(BuildContext context) {
    final quizzesAsync = ref.watch(dailyQuizzesProvider);

    return Scaffold(
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            expandedHeight: 150,
            flexibleSpace: FlexibleSpaceBar(
              title: Text(
                "Daily Quizzes",
                style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
              ),
              background: Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    colors: [Color(0xFF6C5CE7), Color(0xFF4A3CB7)],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                ),
              ),
            ),
            pinned: true,
          ),
          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: quizzesAsync.when(
              loading: () => const SliverToBoxAdapter(
                child: Center(
                  child: CircularProgressIndicator(color: Color(0xFF6C5CE7)),
                ),
              ),
              error: (error, stack) => SliverToBoxAdapter(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.wifi_off, size: 64, color: Colors.grey),
                      const SizedBox(height: 16),
                      Text(
                        "No internet connection",
                        style: GoogleFonts.poppins(fontSize: 18),
                      ),
                      const SizedBox(height: 8),
                      TextButton(
                        onPressed: () => ref.refresh(dailyQuizzesProvider),
                        child: const Text("Retry"),
                      ),
                    ],
                  ),
                ),
              ),
              data: (quizzes) {
                if (quizzes.isEmpty) {
                  return SliverToBoxAdapter(
                    child: Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Lottie.asset(
                            'assets/lottie/empty.json',
                            width: 200,
                            errorBuilder: (context, error, stack) {
                              return const Icon(Icons.folder_open,
                                  size: 80, color: Colors.grey);
                            },
                          ),
                          const SizedBox(height: 20),
                          Text(
                            "No daily quiz available today",
                            style: GoogleFonts.poppins(fontSize: 18),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            "Check back tomorrow!",
                            style: GoogleFonts.poppins(
                                fontSize: 14, color: Colors.grey[600]),
                          ),
                        ],
                      ),
                    ),
                  );
                }

                return SliverList(
                  delegate: SliverChildBuilderDelegate(
                        (context, index) {
                      final quiz = quizzes[index];

                      // âœ… Robust Instant Quiz Detection (for list UI only)
                      final bool isInstant = () {
                        final value = quiz['isInstantQuiz'] ?? quiz['instantquiz'];
                        if (value is bool) return value;
                        if (value is int && value == 1) return true;
                        if (value is String &&
                            (value == "1" || value.toLowerCase() == "true")) {
                          return true;
                        }
                        final type = quiz['type']?.toString().trim();
                        return type == 'quiz_daily';
                      }();

                      // Safe difficulty handling
                      final String difficultyText = () {
                        final raw = quiz['difficulty'];
                        if (raw == null) return "Medium";
                        final diff = raw.toString().trim();
                        if (diff.isEmpty || diff.toLowerCase() == "null") {
                          return "Medium";
                        }
                        if (diff.length == 1) return diff.toUpperCase();
                        return diff[0].toUpperCase() +
                            diff.substring(1).toLowerCase();
                      }();

                      return Container(
                        margin: const EdgeInsets.only(bottom: 16),
                        child: Card(
                          elevation: 6,
                          shape: const RoundedRectangleBorder(
                            borderRadius: BorderRadius.all(Radius.circular(20)),
                          ),
                          child: InkWell(
                            borderRadius: const BorderRadius.all(Radius.circular(20)),
                            // ðŸ”¥ KEY FIX: Normalize quiz object BEFORE navigation
                            onTap: () {
                              final Map<String, dynamic> normalizedQuiz = {
                                ...quiz,
                                'isInstantQuiz': 1,     // Force instant behavior
                                'instantquiz': 1,       // Backward compatibility
                                // 'type' remains 'quiz_daily' if needed elsewhere
                              };
                              context.push('/quizzes/detail', extra: normalizedQuiz);
                            },
                            child: Padding(
                              padding: const EdgeInsets.all(20),
                              child: Row(
                                children: [
                                  Container(
                                    padding: const EdgeInsets.all(16),
                                    decoration: BoxDecoration(
                                      gradient: LinearGradient(
                                        colors: isInstant
                                            ? [Colors.pinkAccent, Colors.purple]
                                            : [const Color(0xFF6C5CE7), const Color(0xFF4A3CB7)],
                                      ),
                                      borderRadius: const BorderRadius.all(Radius.circular(16)),
                                    ),
                                    child: Lottie.asset(
                                      isInstant ? 'assets/lottie/lightning.json' : 'assets/lottie/quiz.json',
                                      width: 60,
                                      errorBuilder: (context, error, stack) {
                                        return Icon(
                                          isInstant ? Icons.flash_on : Icons.quiz_rounded,
                                          size: 40,
                                          color: Colors.white,
                                        );
                                      },
                                    ),
                                  ),
                                  const SizedBox(width: 16),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment: CrossAxisAlignment.start,
                                      children: [
                                        Text(
                                          quiz['quiz_title'] ?? "Daily Quiz",
                                          style: GoogleFonts.poppins(
                                              fontSize: 18,
                                              fontWeight: FontWeight.bold),
                                          maxLines: 2,
                                          overflow: TextOverflow.ellipsis,
                                        ),
                                        const SizedBox(height: 8),
                                        Row(
                                          children: [
                                            const Icon(Icons.timer,
                                                size: 16,
                                                color: Colors.grey),
                                            const SizedBox(width: 4),
                                            Text(
                                              "${quiz['duration_minutes'] ?? 30} mins",
                                              style: GoogleFonts.poppins(fontSize: 14),
                                            ),
                                            const SizedBox(width: 16),
                                            const Icon(Icons.bar_chart,
                                                size: 16,
                                                color: Colors.grey),
                                            const SizedBox(width: 4),
                                            Text(
                                              difficultyText,
                                              style: GoogleFonts.poppins(
                                                  fontSize: 14,
                                                  fontWeight: FontWeight.w600),
                                            ),
                                          ],
                                        ),
                                        if (isInstant) ...[
                                          const SizedBox(height: 8),
                                          Container(
                                            padding: const EdgeInsets.symmetric(
                                                horizontal: 12, vertical: 6),
                                            decoration: BoxDecoration(
                                              color: Colors.pink.withOpacity(0.2),
                                              borderRadius: const BorderRadius.all(Radius.circular(20)),
                                            ),
                                            child: Text(
                                              "Instant Quiz",
                                              style: GoogleFonts.poppins(
                                                color: Colors.pink,
                                                fontWeight: FontWeight.w600,
                                                fontSize: 13,
                                              ),
                                            ),
                                          ),
                                        ],
                                      ],
                                    ),
                                  ),
                                  const Icon(Icons.arrow_forward_ios,
                                      color: Colors.grey),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                    childCount: quizzes.length,
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\instant_quiz_player_screen.dart =====

// lib/screens/quizzes/instant_quiz_player_screen.dart
import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:vibration/vibration.dart';
import 'dart:developer' as developer;
import '../../core/services/api_service.dart';
import '../../providers/user_provider.dart';

/// âœ… UNIVERSAL SAFE INT PARSER - PREVENTS ALL TYPE ERRORS
int safeIntParse(dynamic value, {String? context, required int defaultValue}) {
  if (value == null) {
    developer.log('âŒ NULL VALUE ERROR | Context: $context | Using default: $defaultValue');
    return defaultValue;
  }
  if (value is int) {
    developer.log('âœ… INT VALUE OK | Context: $context | Value: $value');
    return value;
  }
  if (value is String) {
    final parsed = int.tryParse(value);
    if (parsed != null) {
      developer.log('âœ… STRINGâ†’INT SUCCESS | Context: $context | "$value" â†’ $parsed');
      return parsed;
    } else {
      developer.log('âŒ INVALID STRING ERROR | Context: $context | "$value" â†’ Using default: $defaultValue');
      return defaultValue;
    }
  }
  developer.log('âŒ TYPE MISMATCH ERROR | Context: $context | Type: ${value.runtimeType} | Value: $value â†’ Using default: $defaultValue');
  return defaultValue;
}

class InstantQuizPlayerScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> quiz;
  final int attemptId;
  const InstantQuizPlayerScreen({
    super.key,
    required this.quiz,
    required this.attemptId,
  });

  @override
  ConsumerState<InstantQuizPlayerScreen> createState() => _InstantQuizPlayerScreenState();
}

class _InstantQuizPlayerScreenState extends ConsumerState<InstantQuizPlayerScreen>
    with TickerProviderStateMixin {
  // Timer & Quiz State
  late Timer _timer;
  int _remainingSeconds = 0;
  int _currentIndex = 0;
  int _score = 0;
  List<Map<String, dynamic>> _questions = [];
  List<String?> _selectedAnswers = [];
  List<bool?> _answerResults = [];
  bool _isLoading = true;
  bool _isSubmitting = false;
  bool _isResuming = false;

  // UI State - INSTANT QUIZ SPECIFIC
  bool _isAnswered = false;
  bool _isLocked = false;
  bool _showFeedback = false;
  String? _correctAnswer;
  String? _userAnswer;
  bool _isTransitioning = false;

  // Instant Quiz Touch State
  bool _isTouchState = false;
  String? _touchedOption;

  // Animation Controllers
  late AnimationController _questionController;
  late AnimationController _optionsController;
  late AnimationController _feedbackController;
  late AnimationController _timerController;
  late AnimationController _shakeController;
  late AnimationController _exitController;
  late AnimationController _touchController;

  // Animations
  late Animation<Offset> _questionSlideAnimation;
  late Animation<double> _optionsFadeAnimation;
  late Animation<double> _feedbackScaleAnimation;
  late Animation<double> _timerAnimation;
  late Animation<double> _shakeAnimation;
  late Animation<Offset> _exitSlideAnimation;

  // Question Progress
  List<bool> _visitedQuestions = [];
  List<bool> _answeredQuestions = [];

  // â­ COLORS FROM CODE 2 (DARK THEME)
  final Color _primaryColor = const Color(0xFF6C5CE7);
  final Color _touchColor = const Color(0xFF8B78FF);
  final Color _correctColor = const Color(0xFF4CAF50);
  final Color _wrongColor = const Color(0xFFF44336);
  final Color _dullColor = Colors.grey.withOpacity(0.7);
  final Color _timerPausedColor = Colors.grey;

  final int _perQuestionTime = 30;

  /// âœ… SAFE QUIZ ID EXTRACTION
  int get _quizId {
    return safeIntParse(
        widget.quiz['id'],
        context: 'InstantQuizPlayerScreen._quizId',
        defaultValue: 0
    );
  }

  @override
  void initState() {
    super.initState();
    developer.log('ðŸ” Validating attemptId: ${widget.attemptId} (Type: ${widget.attemptId.runtimeType})');
    if (widget.attemptId <= 0) {
      developer.log('âŒ CRITICAL ERROR: Invalid attemptId: ${widget.attemptId}');
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('âŒ Invalid quiz attempt. Please start a new quiz.'),
              backgroundColor: Colors.red,
              duration: Duration(seconds: 4),
            ),
          );
          context.pop();
        }
      });
      return;
    }
    developer.log('âœ… Valid attemptId confirmed: ${widget.attemptId}');
    _initializeAnimations();
    _loadAttemptAndQuestions();
  }

  /// âœ… PERFECT API 0-3 â†’ UI 1-4 CONVERSION
  int convertCorrectAnswer(dynamic value) {
    final v = safeIntParse(value, context: 'convertCorrectAnswer', defaultValue: -1);
    if (v >= 0 && v <= 3) {
      final converted = v + 1;
      developer.log('ðŸ”¥ CONVERSION: API $v â†’ UI $converted');
      return converted;
    }
    developer.log('âš ï¸ Invalid correct_answer: $value â†’ Using -1');
    return -1;
  }

  /// âœ… COMPLETE QUESTION NORMALIZATION WITH ERROR HANDLING
  Map<String, dynamic> normalizeQuestion(Map<String, dynamic> q) {
    try {
      return {
        'id': safeIntParse(q['id'], context: 'Question ID', defaultValue: 0),
        'quiz_id': safeIntParse(q['quiz_id'], context: 'Question Quiz ID', defaultValue: 0),
        'question': q['question']?.toString() ?? "Question unavailable",
        'option1': q['option1']?.toString() ?? "",
        'option2': q['option2']?.toString() ?? "",
        'option3': q['option3']?.toString() ?? "",
        'option4': q['option4']?.toString() ?? "",
        'correct_answer': convertCorrectAnswer(q['correct_answer']),
        'order': safeIntParse(q['order'], context: 'Question Order', defaultValue: 0),
      };
    } catch (e, stackTrace) {
      developer.log('âŒ Question normalization error: $e\nStack: $stackTrace');
      return {
        'id': 0,
        'quiz_id': 0,
        'question': 'Question unavailable due to data error',
        'option1': '',
        'option2': '',
        'option3': '',
        'option4': '',
        'correct_answer': -1,
        'order': 0,
      };
    }
  }

  /// âœ… SAFE CORRECT ANSWER GETTER
  int _getCorrectAnswer(Map<String, dynamic> question) {
    final ans = question['correct_answer'];
    final correctInt = safeIntParse(ans, context: 'getCorrectAnswer', defaultValue: -1);
    if (correctInt >= 1 && correctInt <= 4) {
      return correctInt;
    }
    developer.log('âš ï¸ Invalid correct_answer in question ${question['id']}: $ans');
    return -1;
  }

  /// âœ… COMPLETE LOAD WITH MAXIMUM ERROR PROTECTION
  Future<void> _loadAttemptAndQuestions() async {
    try {
      developer.log('ðŸš€ Loading quiz ${_quizId} with attempt ${widget.attemptId}');
      final api = ref.read(apiServiceProvider);
      final questionsResponse = await api.get('/saved_question/quiz/$_quizId');
      if (questionsResponse['success'] != true) {
        throw Exception('Failed to load questions: ${questionsResponse['message'] ?? 'Unknown error'}');
      }
      final List<dynamic> questionsData = questionsResponse['data'] ?? [];
      developer.log('ðŸ“š Raw questions loaded: ${questionsData.length}');

      final questions = <Map<String, dynamic>>[];
      for (int i = 0; i < questionsData.length; i++) {
        try {
          final rawQuestion = questionsData[i] as Map<String, dynamic>;
          final normalized = normalizeQuestion(rawQuestion);
          if (normalized['id'] > 0 &&
              normalized['correct_answer'] >= 1 &&
              normalized['correct_answer'] <= 4 &&
              [normalized['option1'], normalized['option2'], normalized['option3'], normalized['option4']]
                  .where((o) => o.isNotEmpty).length >= 2) {
            questions.add(normalized);
          } else {
            developer.log('âš ï¸ Skipping invalid question ${normalized['id']}');
          }
        } catch (e) {
          developer.log('âŒ Failed to normalize question $i: $e');
        }
      }
      if (questions.isEmpty) {
        throw Exception('No valid questions found after processing');
      }
      developer.log('âœ… Loaded ${questions.length} VALID normalized questions');

      Map<String, dynamic>? attempt;
      try {
        final attemptResponse = await api.get('/quiz_attempt/${widget.attemptId}');
        if (attemptResponse['success'] == true) {
          attempt = attemptResponse['data'];
          developer.log('âœ… Attempt details loaded: ${attempt?['id']}');
        }
      } catch (e) {
        developer.log('âš ï¸ Could not load attempt details: $e');
      }

      if (!mounted) return;

      setState(() {
        _questions = questions;
        _selectedAnswers = List.filled(questions.length, null);
        _answerResults = List.filled(questions.length, null);
        _visitedQuestions = List.filled(questions.length, false);
        _answeredQuestions = List.filled(questions.length, false);
        _isLoading = false;
      });

      if (_questions.isEmpty) {
        throw Exception('No questions available after processing');
      }

      if (attempt != null && attempt['status']?.toString() == 'in_progress') {
        await _resumeAttempt(attempt);
      } else {
        setState(() {
          _currentIndex = 0;
          _visitedQuestions[0] = true;
        });
        _startQuestionAnimations();
        _startPerQuestionTimer();
        developer.log('ðŸŽ¯ New attempt started at question 1');
      }
    } catch (e, stackTrace) {
      developer.log("âŒ LOAD ATTEMPT ERROR: $e\nSTACK: $stackTrace");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error_outline, color: Colors.white),
              const SizedBox(width: 8),
              Expanded(child: Text('Failed to load quiz: ${e.toString()}')),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 5),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
        ),
      );
      setState(() => _isLoading = false);
    }
  }

  /// âœ… RESUME ATTEMPT WITH SAFE INDEXING
  Future<void> _resumeAttempt(Map<String, dynamic> attempt) async {
    try {
      setState(() => _isResuming = true);
      final currentQuestionIndex = safeIntParse(
          attempt['current_question_index'],
          context: 'Resume current_question_index',
          defaultValue: 0
      );
      final score = safeIntParse(
          attempt['obtained_marks'],
          context: 'Resume obtained_marks',
          defaultValue: 0
      );
      developer.log('ðŸ”„ Resuming attempt ${widget.attemptId} at question $currentQuestionIndex');
      developer.log('ðŸ“Š Current score: $score');

      await _loadAttemptReviewAnswers(widget.attemptId);

      if (!mounted) return;
      final clampedIndex = currentQuestionIndex.clamp(0, _questions.length - 1);
      setState(() {
        _currentIndex = clampedIndex;
        _score = score;
        _visitedQuestions[_currentIndex] = true;
        _answeredQuestions[_currentIndex] = _selectedAnswers[_currentIndex] != null;
        _isAnswered = _answeredQuestions[_currentIndex];
        _isLocked = _isAnswered;
        _isResuming = false;
      });

      if (mounted) {
        _showResumeSnackBar(clampedIndex + 1, _questions.length, _score);
      }

      _startQuestionAnimations();
      if (!_isAnswered) {
        _startPerQuestionTimer();
      }
    } catch (e, stackTrace) {
      developer.log('âŒ Resume attempt error: $e\nStack: $stackTrace');
      setState(() => _isResuming = false);
      _startQuestionAnimations();
      _startPerQuestionTimer();
    }
  }

  /// âœ… LOAD PREVIOUS ANSWERS WITH SAFE INT COMPARISONS
  Future<void> _loadAttemptReviewAnswers(int attemptId) async {
    try {
      final api = ref.read(apiServiceProvider);
      final response = await api.get('/attempt_review', query: {
        'result_id': attemptId.toString(),
      });
      if (response['success'] == true) {
        final List<dynamic> reviews = response['data'] ?? [];
        int loadedCount = 0;
        for (var review in reviews) {
          try {
            final questionId = safeIntParse(
                review['question_id'],
                context: 'Review question_id',
                defaultValue: 0
            );
            if (questionId == 0) continue;
            final selectedOption = review['selected_option']?.toString();

            final questionIndex = _questions.indexWhere((q) {
              final qId = safeIntParse(q['id'], context: 'Question ID lookup', defaultValue: 0);
              return qId == questionId;
            });
            if (questionIndex == -1) {
              developer.log('âš ï¸ Question ID $questionId not found');
              continue;
            }

            _selectedAnswers[questionIndex] = selectedOption;
            _answeredQuestions[questionIndex] = true;
            _visitedQuestions[questionIndex] = true;

            final question = _questions[questionIndex];
            final correctInt = _getCorrectAnswer(question);
            final selectedInt = int.tryParse(selectedOption ?? '') ?? -1;
            final isCorrect = selectedInt == correctInt;
            _answerResults[questionIndex] = isCorrect;
            if (isCorrect) _score += 10;
            loadedCount++;
          } catch (e) {
            developer.log('âŒ Error processing review: $e');
          }
        }
        developer.log('âœ… Loaded $loadedCount previous answers with PERFECT INT matching');
      }
    } catch (e) {
      developer.log('âš ï¸ Could not load attempt reviews: $e');
    }
  }

  /// âœ… UPDATE ATTEMPT PROGRESS
  Future<void> _updateAttemptProgress() async {
    try {
      final api = ref.read(apiServiceProvider);
      final questionsData = <Map<String, dynamic>>[];
      for (int i = 0; i < _questions.length; i++) {
        questionsData.add({
          'question_index': i,
          'question_id': _questions[i]['id'],
          'selected_option': _selectedAnswers[i],
          'is_correct': _answerResults[i],
          'answered': _answeredQuestions[i],
        });
      }
      final timeSpent = (_perQuestionTime * _currentIndex + (_perQuestionTime - _remainingSeconds));
      await api.put('/quiz_attempt/${widget.attemptId}', {
        'current_question_index': _currentIndex.toString(),
        'questions_data': jsonEncode(questionsData),
        'time_spent_total': timeSpent.toString(),
        'obtained_marks': _score.toString(),
        'correct_answers': _answerResults.where((r) => r == true).length.toString(),
        'incorrect_answers': _answerResults.where((r) => r == false).length.toString(),
        'unanswered_questions': _questions.length - _answeredQuestions.where((a) => a).length,
        'status': _currentIndex < _questions.length - 1 ? 'in_progress' : 'completed',
      });
      developer.log('âœ… Progress saved: Q$_currentIndex | Score: $_score | Time: $timeSpent');
    } catch (e) {
      developer.log('âš ï¸ Failed to save progress: $e');
    }
  }

  void _initializeAnimations() {
    _questionController = AnimationController(duration: const Duration(milliseconds: 700), vsync: this);
    _optionsController = AnimationController(duration: const Duration(milliseconds: 500), vsync: this);
    _feedbackController = AnimationController(duration: const Duration(milliseconds: 300), vsync: this);
    _timerController = AnimationController(duration: Duration(seconds: _perQuestionTime), vsync: this);
    _shakeController = AnimationController(duration: const Duration(milliseconds: 500), vsync: this);
    _exitController = AnimationController(duration: const Duration(milliseconds: 400), vsync: this);
    _touchController = AnimationController(duration: const Duration(milliseconds: 300), vsync: this);

    _questionSlideAnimation = Tween<Offset>(begin: const Offset(0, 0.3), end: Offset.zero)
        .animate(CurvedAnimation(parent: _questionController, curve: Curves.easeOut));

    _optionsFadeAnimation = Tween<double>(begin: 0.0, end: 1.0)
        .animate(CurvedAnimation(parent: _optionsController, curve: Curves.easeIn));

    _feedbackScaleAnimation = Tween<double>(begin: 0.0, end: 1.0)
        .animate(CurvedAnimation(parent: _feedbackController, curve: Curves.elasticOut));

    _timerAnimation = Tween<double>(begin: 1.0, end: 0.0).animate(_timerController);

    _shakeAnimation = TweenSequence<double>([
      TweenSequenceItem(tween: Tween<double>(begin: 0, end: -10), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: -10, end: 10), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: 10, end: -10), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: -10, end: 10), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: 10, end: 0), weight: 1),
    ]).animate(_shakeController);

    _exitSlideAnimation = Tween<Offset>(begin: Offset.zero, end: const Offset(-1, 0))
        .animate(CurvedAnimation(parent: _exitController, curve: Curves.easeInOut));
  }

  void _startQuestionAnimations() {
    _questionController.forward().then((_) {
      Future.delayed(const Duration(milliseconds: 100), () {
        if (mounted) _optionsController.forward();
      });
    });
    _timerController.duration = Duration(seconds: _perQuestionTime);
    _timerController.forward(from: 0.0);
  }

  void _startPerQuestionTimer() {
    _remainingSeconds = _perQuestionTime;
    _timerController.reset();
    _timerController.duration = Duration(seconds: _perQuestionTime);
    _timerController.forward();
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) return;
      setState(() {
        if (_remainingSeconds > 0) {
          _remainingSeconds--;
          _timerController.value = _remainingSeconds / _perQuestionTime;
        } else {
          timer.cancel();
          _handleTimeOut();
        }
      });
    });
  }

  void _handleTimeOut() {
    if (!_isAnswered) {
      final question = _questions[_currentIndex];
      final correctInt = _getCorrectAnswer(question);
      setState(() {
        _isAnswered = true;
        _isLocked = true;
        _correctAnswer = correctInt.toString();
        _answerResults[_currentIndex] = false;
        _timerController.stop();
      });
      _saveAnswerToServer("", false);
      _showTimeOutFeedback();
      _updateAttemptProgress();
    }
  }

  void _selectAnswer(String selectedOption) {
    if (_isAnswered || _isLocked) return;
    final selectedInt = int.tryParse(selectedOption);
    if (selectedInt == null || selectedInt < 1 || selectedInt > 4) {
      developer.log("âŒ Invalid option selected: $selectedOption");
      return;
    }
    final question = _questions[_currentIndex];
    final correctInt = _getCorrectAnswer(question);
    final isCorrect = selectedInt == correctInt;

    setState(() {
      _touchedOption = selectedOption;
      _isTouchState = true;
      _selectedAnswers[_currentIndex] = selectedOption;
      _userAnswer = selectedOption;
      _correctAnswer = correctInt.toString();
    });
    _touchController.forward();

    _timer.cancel();
    _timerController.stop();

    Future.delayed(const Duration(milliseconds: 300), () {
      if (!mounted) return;
      setState(() {
        _isTouchState = false;
        _isAnswered = true;
        _isLocked = true;
        _answeredQuestions[_currentIndex] = true;
        _answerResults[_currentIndex] = isCorrect;
        if (isCorrect) _score += 10;
        _showFeedback = true;
      });
      _feedbackController.forward();
      _provideHapticFeedback(isCorrect);
      if (!isCorrect) {
        _shakeController.forward();
      }
      _saveAnswerToServer(selectedOption, isCorrect);
      _updateAttemptProgress();

      Future.delayed(const Duration(seconds: 2), () {
        if (mounted) _goToNextQuestion();
      });
    });
  }

  void _provideHapticFeedback(bool isCorrect) async {
    if (await Vibration.hasVibrator() ?? false) {
      if (!isCorrect) {
        Vibration.vibrate(duration: 200, amplitude: 100);
      } else {
        Vibration.vibrate(pattern: [0, 50, 50, 50]);
      }
    }
  }

  void _showTimeOutFeedback() {
    setState(() => _showFeedback = true);
    _feedbackController.forward();
    Future.delayed(const Duration(seconds: 2), () {
      if (mounted) _goToNextQuestion();
    });
  }

  void _goToNextQuestion() {
    _updateAttemptProgress();
    if (_currentIndex < _questions.length - 1) {
      setState(() => _isTransitioning = true);
      _exitController.forward().then((_) {
        _questionController.reset();
        _optionsController.reset();
        _feedbackController.reset();
        _exitController.reset();
        _shakeController.reset();
        _touchController.reset();
        if (!mounted) return;
        setState(() {
          _currentIndex++;
          _isAnswered = _selectedAnswers[_currentIndex] != null;
          _isLocked = _isAnswered;
          _showFeedback = false;
          _isTransitioning = false;
          _isTouchState = false;
          _touchedOption = null;
          _userAnswer = null;
          _correctAnswer = null;
          _visitedQuestions[_currentIndex] = true;
        });
        _startQuestionAnimations();
        if (!_isAnswered) {
          _startPerQuestionTimer();
        }
        developer.log('âž¡ï¸ Moved to question ${_currentIndex + 1}/${_questions.length}');
      });
    } else {
      developer.log('ðŸ All questions completed! Submitting...');
      _submitQuiz();
    }
  }

  /// âœ… BULLETPROOF SAVE ANSWER - USES PUT INSTEAD OF POST FOR EXISTING ATTEMPTS
  Future<void> _saveAnswerToServer(String selected, bool isCorrect) async {
    try {
      final user = ref.read(currentUserProvider).asData?.value;
      if (user?.id == null) {
        developer.log("âŒ User ID missing");
        return;
      }
      final question = _questions[_currentIndex];
      final questionId = safeIntParse(question['id'],
          context: 'Save question_id',
          defaultValue: 0
      );
      if (questionId == 0) {
        developer.log("âŒ Invalid question ID for saving");
        return;
      }
      final correctInt = _getCorrectAnswer(question);
      final selectedInt = int.tryParse(selected) ?? -1;

      final api = ref.read(apiServiceProvider);
      Map<String, dynamic>? existingAttempt;
      try {
        final attemptResponse = await api.get('/quiz_attempt/${widget.attemptId}');
        if (attemptResponse['success'] == true) {
          existingAttempt = attemptResponse['data'];
        }
      } catch (e) {
        developer.log("âš ï¸ Could not load existing attempt: $e");
      }

      List<Map<String, dynamic>> questionsData = [];
      if (existingAttempt != null && existingAttempt['questions_data'] != null) {
        try {
          if (existingAttempt['questions_data'] is String) {
            questionsData = List<Map<String, dynamic>>.from(
                jsonDecode(existingAttempt['questions_data'])
            );
          } else if (existingAttempt['questions_data'] is List) {
            questionsData = List<Map<String, dynamic>>.from(
                existingAttempt['questions_data']
            );
          }
        } catch (e) {
          developer.log("âš ï¸ Error parsing existing questions_data: $e");
        }
      }

      final questionIndex = questionsData.indexWhere(
              (q) => safeIntParse(q['question_id'],
              context: 'Find question_id',
              defaultValue: 0
          ) == questionId
      );

      final questionPayload = {
        'question_index': _currentIndex,
        'question_id': questionId,
        'selected_option': selectedInt >= 1 ? selectedInt.toString() : null,
        'is_correct': isCorrect,
        'answered': selectedInt >= 1,
        'correct_option': correctInt,
        'question_text': question['question'] ?? 'Question unavailable',
        'options_provided': [
          question['option1'] ?? '',
          question['option2'] ?? '',
          question['option3'] ?? '',
          question['option4'] ?? ''
        ],
        'time_spent': _perQuestionTime - _remainingSeconds,
      };

      if (questionIndex >= 0) {
        questionsData[questionIndex] = questionPayload;
      } else {
        questionsData.add(questionPayload);
      }

      final timeSpent = (_perQuestionTime * _currentIndex +
          (_perQuestionTime - _remainingSeconds));
      final updatePayload = {
        'current_question_index': _currentIndex,
        'questions_data': jsonEncode(questionsData),
        'time_spent_total': timeSpent,
        'obtained_marks': _score,
        'correct_answers': _answerResults.where((r) => r == true).length,
        'incorrect_answers': _answerResults.where((r) => r == false).length,
        'unanswered_questions': _questions.length -
            _answeredQuestions.where((a) => a).length,
        'status': _currentIndex < _questions.length - 1 ?
        'in_progress' : 'completed',
      };

      developer.log("ðŸ’¾ Updating attempt ${widget.attemptId} with: ${jsonEncode(updatePayload)}");

      final response = await api.put('/quiz_attempt/${widget.attemptId}', updatePayload);
      if (response['success'] == true) {
        developer.log("âœ… Answer saved successfully in attempt ${widget.attemptId}");
      } else {
        developer.log("âš ï¸ Update warning: ${response['message']}");
      }
    } catch (e, stackTrace) {
      developer.log("âŒ Save error: $e\nStack: $stackTrace");
    }
  }

  /// âœ… COMPLETE QUIZ SUBMISSION WITH CORRECT DATA TYPES
  Future<void> _submitQuiz() async {
    if (_isSubmitting) return;
    _isSubmitting = true;
    try {
      if (_timer.isActive) _timer.cancel();
      _timerController.stop();

      await _updateAttemptProgress();

      final user = ref.read(currentUserProvider).asData?.value;
      if (user?.id == null) throw Exception("User not found");

      final totalQuestions = _questions.length;
      final fullMarks = totalQuestions * 10;
      final totalTime = (_perQuestionTime * totalQuestions);

      final resultPayload = {
        'quiz_id': _quizId,
        'user_id': user!.id,
        'attempt_id': widget.attemptId,
        'score': _score,
        'full_marks': fullMarks,
        'time_taken': totalTime,
      };

      developer.log("ðŸ“¤ Submitting result: ${jsonEncode(resultPayload)}");
      final resultResponse = await ref.read(apiServiceProvider).post('/result', resultPayload);
      if (resultResponse['success'] != true) {
        throw Exception(resultResponse['message'] ?? 'Failed to create result');
      }

      final resultId = safeIntParse(
          resultResponse['id'] ?? resultResponse['data']?['id'],
          context: 'Submit result_id',
          defaultValue: 0
      );
      if (resultId == 0) {
        throw Exception('Invalid result ID returned from server');
      }

      await ref.read(apiServiceProvider).put('/quiz_attempt/${widget.attemptId}', {
        'status': 'completed',
        'completed_at': DateTime.now().toIso8601String(),
      });

      developer.log("ðŸŽ‰ QUIZ COMPLETED! Result ID: $resultId | Score: $_score/$fullMarks (${(_score / fullMarks * 100).toStringAsFixed(1)}%)");

      if (!mounted) return;
      context.go('/quizzes/result', extra: {
        'result_id': resultId,
        'attempt_id': widget.attemptId,
        'score': _score,
        'total_questions': totalQuestions,
        'total_marks': fullMarks,
        'quiz_title': widget.quiz['quiz_title'] ?? widget.quiz['title'],
        'percentage': (_score / fullMarks * 100).toStringAsFixed(1),
        'time_taken': totalTime,
        'passed': _score >= (fullMarks * 0.6),
        'slug': widget.quiz['slug']?.toString().trim().isNotEmpty == true
            ? widget.quiz['slug']
            : widget.quiz['id'].toString(),
      });
    } catch (e, stackTrace) {
      developer.log("âŒ Submit error: $e\nStack: $stackTrace");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error_outline, color: Colors.white),
              const SizedBox(width: 8),
              Expanded(child: Text('Submit failed: ${e.toString()}')),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 5),
          behavior: SnackBarBehavior.floating,
        ),
      );
      await _fallbackSubmit();
    } finally {
      _isSubmitting = false;
    }
  }

  /// âœ… FALLBACK: Alternative submission method
  Future<void> _fallbackSubmit() async {
    try {
      final user = ref.read(currentUserProvider).asData?.value;
      if (user?.id == null) return;
      final totalQuestions = _questions.length;
      final fullMarks = totalQuestions * 10;

      final altPayload = {
        'quiz_id': _quizId.toString(),
        'user_id': user!.id.toString(),
        'score': _score.toString(),
        'full_marks': fullMarks.toString(),
        'time_taken': (_perQuestionTime * totalQuestions).toString(),
        'completed_at': DateTime.now().toIso8601String(),
      };

      developer.log("ðŸ”„ Trying fallback submission: ${jsonEncode(altPayload)}");
      final response = await ref.read(apiServiceProvider).post('/result', altPayload);
      if (response['success'] == true) {
        final resultId = safeIntParse(
            response['id'],
            context: 'Fallback result_id',
            defaultValue: 0
        );
        if (resultId > 0 && mounted) {
          context.go('/quizzes/result', extra: {
            'result_id': resultId,
            'attempt_id': widget.attemptId,
            'score': _score,
            'total_questions': totalQuestions,
            'total_marks': fullMarks,
            'quiz_title': widget.quiz['quiz_title'] ?? widget.quiz['title'],
            'percentage': (_score / fullMarks * 100).toStringAsFixed(1),
            'time_taken': _perQuestionTime * totalQuestions,
            'passed': _score >= (fullMarks * 0.6),
            'slug': widget.quiz['slug']?.toString().trim().isNotEmpty == true
                ? widget.quiz['slug']
                : widget.quiz['id'].toString(),
          });
        }
      }
    } catch (e) {
      developer.log("âŒ Fallback submit also failed: $e");
    }
  }

  /// âœ… RESUME SNACKBAR
  void _showResumeSnackBar(int current, int total, int score) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.play_arrow, color: Colors.white),
            const SizedBox(width: 8),
            Text('Resumed from question $current/$total â€¢ Score: $score'),
          ],
        ),
        backgroundColor: Colors.orange,
        duration: const Duration(seconds: 3),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    );
  }

  Future<bool> _onWillPop() async {
    await _updateAttemptProgress();
    final shouldQuit = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text("Quit Quiz?", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: Text(
          "Your progress is saved. You can resume later from question ${_currentIndex + 1}!",
          style: GoogleFonts.poppins(),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text("Continue", style: GoogleFonts.poppins(color: Colors.grey[700])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),
            onPressed: () => Navigator.pop(context, true),
            child: Text("Quit", style: GoogleFonts.poppins(color: Colors.white)),
          ),
        ],
      ),
    );
    return shouldQuit ?? false;
  }

  // ==================== UI FROM CODE 2 ====================

  Widget _buildTopBar() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text('COINS\n0',
                  textAlign: TextAlign.center,
                  style: GoogleFonts.poppins(fontSize: 14, color: Colors.white70)),
              Stack(
                alignment: Alignment.center,
                children: [
                  SizedBox(
                    width: 80,
                    height: 80,
                    child: CircularProgressIndicator(
                      value: _timerAnimation.value.clamp(0.0, 1.0),
                      strokeWidth: 6,
                      backgroundColor: Colors.grey[800],
                      valueColor: AlwaysStoppedAnimation<Color>(
                        _isLocked
                            ? _timerPausedColor
                            : (_remainingSeconds < 10 ? Colors.red : _primaryColor),
                      ),
                    ),
                  ),
                  Text('$_remainingSeconds',
                      style: GoogleFonts.poppins(
                          fontSize: 24, fontWeight: FontWeight.bold, color: Colors.white)),
                ],
              ),
              Text('SCORE\n$_score',
                  textAlign: TextAlign.center,
                  style: GoogleFonts.poppins(fontSize: 14, color: Colors.white70)),
            ],
          ),
          const SizedBox(height: 8),
          Text('${_currentIndex + 1}/${_questions.length}',
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.white60)),
        ],
      ),
    );
  }

  Widget _buildOptionButton(int index, List<dynamic> options, int correctAnswer) {
    final optionLetter = (index + 1).toString();
    final optionText = options[index]?.toString() ?? '';
    final isTouched = _touchedOption == optionLetter && _isTouchState;
    final isSelected = _selectedAnswers[_currentIndex] == optionLetter;
    final isCorrectOption = (index + 1) == correctAnswer;

    Color backgroundColor() {
      if (_showFeedback) {
        if (isCorrectOption) return _correctColor;
        if (isSelected && !isCorrectOption) return _wrongColor;
        return Colors.grey[800]!.withOpacity(0.6);
      }
      if (isTouched) return _touchColor;
      return Colors.grey[800]!;
    }

    Color textColor() => (_showFeedback || isTouched) ? Colors.white : Colors.white;

    double opacity() => (_isTouchState && !isTouched) ? 0.7 : 1.0;

    Widget? trailingIcon() {
      if (!_showFeedback) return null;
      if (isCorrectOption) {
        return ScaleTransition(
            scale: _feedbackScaleAnimation,
            child: const Icon(Icons.check, color: Colors.white, size: 28));
      }
      if (isSelected && !isCorrectOption) {
        return ScaleTransition(
            scale: _feedbackScaleAnimation,
            child: const Icon(Icons.close, color: Colors.white, size: 28));
      }
      return null;
    }

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
      child: AnimatedBuilder(
        animation: Listenable.merge([_touchController, _feedbackController]),
        builder: (context, child) {
          final double touchScale = isTouched
              ? (1.0 + 0.03 * Curves.easeOut.transform(_touchController.value))
              : 1.0;
          return Transform.scale(
            scale: touchScale,
            child: Opacity(
              opacity: opacity(),
              child: Material(
                color: backgroundColor(),
                borderRadius: BorderRadius.circular(30),
                child: InkWell(
                  borderRadius: BorderRadius.circular(30),
                  onTap: _isLocked ? null : () => _selectAnswer(optionLetter),
                  child: Container(
                    padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
                    child: Row(
                      children: [
                        CircleAvatar(
                          radius: 18,
                          backgroundColor: textColor().withOpacity(0.3),
                          child: Text(optionLetter,
                              style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                            child: Text(optionText,
                                style: GoogleFonts.poppins(fontSize: 16, color: textColor()))),
                        if (trailingIcon() != null) ...[
                          const SizedBox(width: 8),
                          trailingIcon()!,
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading || _questions.isEmpty) {
      return Scaffold(
        backgroundColor: const Color(0xFF121212),
        body: Center(child: Lottie.asset('assets/lottie/loading.json')),
      );
    }

    final question = _questions[_currentIndex];
    final List<dynamic> options = ['1', '2', '3', '4']
        .map((i) => question['option$i'])
        .where((o) => o != null && o.toString().isNotEmpty)
        .toList();
    final correctAnswer = _getCorrectAnswer(question);

    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        backgroundColor: const Color(0xFF121212),
        body: SafeArea(
          child: Column(
            children: [
              _buildTopBar(),
              const SizedBox(height: 30),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                child: SlideTransition(
                  position: _questionSlideAnimation,
                  child: Card(
                    color: const Color(0xFF1E1E1E),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                    child: Padding(
                      padding: const EdgeInsets.all(24),
                      child: Text(
                        question['question'] ?? "Question unavailable",
                        style: GoogleFonts.poppins(
                            fontSize: 20, fontWeight: FontWeight.w600, color: Colors.white),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 40),
              Expanded(
                child: FadeTransition(
                  opacity: _optionsFadeAnimation,
                  child: ListView.builder(
                    itemCount: options.length,
                    itemBuilder: (context, index) => _buildOptionButton(index, options, correctAnswer),
                  ),
                ),
              ),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _updateAttemptProgress();
    _questionController.dispose();
    _optionsController.dispose();
    _feedbackController.dispose();
    _timerController.dispose();
    _shakeController.dispose();
    _exitController.dispose();
    _touchController.dispose();
    if (_timer.isActive) _timer.cancel();
    super.dispose();
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\quizzes_screen.dart =====

// lib/screens/quizzes/quizzes_screen.dart â€” UPDATED & CRASH-PROOF
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import '../../core/services/api_service.dart';

// âœ… UPDATED quizzesProvider - CRASH PROOF
final quizzesProvider = FutureProvider<List<dynamic>>((ref) async {
  final api = ref.read(apiServiceProvider);
  final response = await api.get('/saved_quiz');
  if (response is Map && response['data'] is List) {
    return response['data'];
  }
  return [];
});

class QuizzesScreen extends ConsumerStatefulWidget {
  const QuizzesScreen({super.key});

  @override
  ConsumerState<QuizzesScreen> createState() => _QuizzesScreenState();
}

class _QuizzesScreenState extends ConsumerState<QuizzesScreen> {
  @override
  Widget build(BuildContext context) {
    final quizzesAsync = ref.watch(quizzesProvider);

    return Scaffold(
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            expandedHeight: 150,
            flexibleSpace: FlexibleSpaceBar(
              title: Text("Quizzes", style: GoogleFonts.poppins(fontWeight: FontWeight.bold)),
              background: Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    colors: [Color(0xFF6C5CE7), Color(0xFF4A3CB7)],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                ),
              ),
            ),
            pinned: true,
          ),

          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: quizzesAsync.when(
              loading: () => SliverToBoxAdapter(
                child: Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
              ),
              error: (error, stack) => SliverToBoxAdapter(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.wifi_off, size: 64, color: Colors.grey),
                      const SizedBox(height: 16),
                      Text("No internet connection", style: GoogleFonts.poppins(fontSize: 18)),
                      const SizedBox(height: 8),
                      TextButton(
                        onPressed: () => ref.refresh(quizzesProvider),
                        child: const Text("Retry"),
                      ),
                    ],
                  ),
                ),
              ),
              data: (quizzes) {
                if (quizzes.isEmpty) {
                  return SliverToBoxAdapter(
                    child: Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Lottie.asset(
                            'assets/lottie/empty.json',
                            width: 200,
                            errorBuilder: (context, error, stack) {
                              return const Icon(Icons.folder_open, size: 80, color: Colors.grey);
                            },
                          ),
                          const SizedBox(height: 20),
                          Text("No quizzes available", style: GoogleFonts.poppins(fontSize: 18)),
                        ],
                      ),
                    ),
                  );
                }
                return SliverList(
                  delegate: SliverChildBuilderDelegate(
                        (context, index) {
                      final quiz = quizzes[index];
                      // âœ… FIX 2 â€” Safe isInstantQuiz parsing
                      final isInstant = quiz['isInstantQuiz']?.toString() == "1";
                      // âœ… FIX 1 â€” Crash-proof difficulty handling
                      final String difficultyText = () {
                        final raw = quiz['difficulty'];
                        // If null, return default value
                        if (raw == null) return "Easy";
                        final diff = raw.toString().trim();
                        // If empty or "null", return default
                        if (diff.isEmpty || diff.toLowerCase() == "null") return "Easy";
                        // If only one letter
                        if (diff.length == 1) return diff.toUpperCase();
                        // Normal case
                        return diff[0].toUpperCase() + diff.substring(1).toLowerCase();
                      }();

                      return Container(
                        margin: const EdgeInsets.only(bottom: 16),
                        child: Card(
                          elevation: 6,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                          child: InkWell(
                            borderRadius: BorderRadius.circular(20),
                            onTap: () {
                              debugPrint("Opening Quiz ID: ${quiz['id']} - ${quiz['quiz_title']}");
                              context.push('/quizzes/detail', extra: quiz);
                            },
                            child: Padding(
                              padding: const EdgeInsets.all(20),
                              child: Row(
                                children: [
                                  Container(
                                    padding: const EdgeInsets.all(16),
                                    decoration: BoxDecoration(
                                      gradient: LinearGradient(
                                        colors: isInstant
                                            ? [Colors.pinkAccent, Colors.purple]
                                            : [const Color(0xFF6C5CE7), const Color(0xFF4A3CB7)],
                                      ),
                                      borderRadius: BorderRadius.circular(16),
                                    ),
                                    child: Lottie.asset(
                                      isInstant ? 'assets/lottie/lightning.json' : 'assets/lottie/quiz.json',
                                      width: 60,
                                      // âœ… FIX 3 â€” Prevent crash if Lottie asset missing
                                      errorBuilder: (context, error, stack) {
                                        return Icon(
                                            isInstant ? Icons.flash_on : Icons.quiz_rounded,
                                            size: 40,
                                            color: Colors.white
                                        );
                                      },
                                    ),
                                  ),
                                  const SizedBox(width: 16),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment: CrossAxisAlignment.start,
                                      children: [
                                        Text(
                                          quiz['quiz_title'] ?? "Untitled Quiz",
                                          style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.bold),
                                          maxLines: 2,
                                          overflow: TextOverflow.ellipsis,
                                        ),
                                        const SizedBox(height: 8),
                                        Row(
                                          children: [
                                            Icon(Icons.timer, size: 16, color: Colors.grey[600]),
                                            const SizedBox(width: 4),
                                            Text("${quiz['duration_minutes'] ?? 10} mins", style: GoogleFonts.poppins(fontSize: 14)),
                                            const SizedBox(width: 16),
                                            Icon(Icons.bar_chart, size: 16, color: Colors.grey[600]),
                                            const SizedBox(width: 4),
                                            Text(
                                              difficultyText,
                                              style: GoogleFonts.poppins(fontSize: 14, fontWeight: FontWeight.w600),
                                            ),
                                          ],
                                        ),
                                        // âœ… FIX 4 â€” Null-safe date formatting (if you have date display)
                                        if (quiz['notifyDate'] != null)
                                          Text(
                                            "Date: ${quiz['notifyDate']?.toString().trim().isEmpty ?? true ? "N/A" : quiz['notifyDate']}",
                                            style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey),
                                          ),
                                        if (isInstant)
                                          Container(
                                            margin: const EdgeInsets.only(top: 8),
                                            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                                            decoration: BoxDecoration(
                                              color: Colors.pink.withOpacity(0.2),
                                              borderRadius: BorderRadius.circular(20),
                                            ),
                                            child: Text(
                                              "Instant Quiz",
                                              style: GoogleFonts.poppins(
                                                  color: Colors.pink,
                                                  fontWeight: FontWeight.w600,
                                                  fontSize: 13
                                              ),
                                            ),
                                          ),
                                      ],
                                    ),
                                  ),
                                  const Icon(Icons.arrow_forward_ios, color: Colors.grey),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                    childCount: quizzes.length,
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\quiz_detail_screen.dart =====

// lib/screens/quizzes/quiz_detail_screen.dart â€” UPDATED TO TREAT DAILY QUIZZES LIKE INSTANT QUIZZES
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:share_plus/share_plus.dart';
import 'dart:developer' as developer;
import '../../core/services/api_service.dart';
import '../../providers/user_provider.dart';
import '../../providers/quiz_attempts_provider.dart';

/// âœ… UNIVERSAL SAFE INT PARSER - PREVENTS ALL TYPE ERRORS
int safeIntParse(dynamic value, {String? context, required int defaultValue}) {
  if (value == null) {
    developer.log('âŒ NULL VALUE ERROR | Context: $context | Using default: $defaultValue');
    return defaultValue;
  }
  if (value is int) {
    developer.log('âœ… INT VALUE OK | Context: $context | Value: $value');
    return value;
  }
  if (value is String) {
    final parsed = int.tryParse(value);
    if (parsed != null) {
      developer.log('âœ… STRINGâ†’INT SUCCESS | Context: $context | "$value" â†’ $parsed');
      return parsed;
    } else {
      developer.log('âŒ INVALID STRING ERROR | Context: $context | "$value" â†’ Using default: $defaultValue');
      return defaultValue;
    }
  }
  developer.log('âŒ TYPE MISMATCH ERROR | Context: $context | Type: ${value.runtimeType} | Value: $value â†’ Using default: $defaultValue');
  return defaultValue;
}

class QuizDetailScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> quiz;
  const QuizDetailScreen({super.key, required this.quiz});

  @override
  ConsumerState<QuizDetailScreen> createState() => _QuizDetailScreenState();
}

class _QuizDetailScreenState extends ConsumerState<QuizDetailScreen> {
  bool isStarting = false;

  /// âœ… SAFE QUIZ ID EXTRACTION
  int get _quizId {
    return safeIntParse(
        widget.quiz['id'],
        context: 'QuizDetailScreen._quizId',
        defaultValue: 0
    );
  }

  /// âœ… UPDATED: Treat type=="quiz_daily" exactly like isInstantQuiz==1
  bool _isInstantQuiz(Map<String, dynamic> quiz) {
    // First check explicit instant flags
    final instantValue = quiz['isInstantQuiz'] ?? quiz['instantquiz'];
    if (instantValue != null) {
      if (instantValue is bool) return instantValue;
      if (instantValue is int) return instantValue == 1;
      if (instantValue is String) {
        return instantValue == "1" || instantValue.toLowerCase() == "true";
      }
    }

    // NEW: Daily quizzes (from type=quiz_daily endpoint) behave like instant quizzes
    final type = quiz['type']?.toString().trim();
    return type == "quiz_daily";
  }

  /// âœ… SAFE ATTEMPT NUMBER EXTRACTION
  int _safeGetAttemptNumber(Map<String, dynamic> attempt) {
    return safeIntParse(
        attempt['attempt_number'],
        context: 'Attempt #${attempt['id'] ?? 'unknown'} - attempt_number',
        defaultValue: 1
    );
  }

  /// âœ… SAFE ATTEMPT ID EXTRACTION
  int _safeGetAttemptId(Map<String, dynamic> attempt) {
    return safeIntParse(
        attempt['id'],
        context: 'Attempt ID extraction',
        defaultValue: 0
    );
  }

  Future<void> _startQuiz() async {
    if (isStarting) return;
    setState(() => isStarting = true);

    try {
      developer.log('ðŸš€ Starting quiz ID: $_quizId');

      if (_quizId == 0) {
        throw Exception("âŒ INVALID QUIZ ID: ${widget.quiz['id']} (Type: ${widget.quiz['id'].runtimeType})");
      }

      final userAsync = ref.read(currentUserProvider);
      final user = userAsync.asData?.value;
      if (user == null || user.id == 0) {
        throw Exception("Profile loading... Try again.");
      }

      final api = ref.read(apiServiceProvider);

      Map<String, dynamic>? latestAttempt;

      try {
        final latestAttemptAsync = ref.read(latestQuizAttemptProvider(_quizId));
        if (latestAttemptAsync.hasValue && latestAttemptAsync.value != null) {
          latestAttempt = latestAttemptAsync.value;
          developer.log('âœ… Provider found latest attempt: ${latestAttempt?['id']}');
        }
      } catch (e) {
        developer.log('âš ï¸ Provider error, trying manual fetch: $e');
      }

      if (latestAttempt == null) {
        try {
          developer.log('ðŸ” Manual attempt fetch for quiz $_quizId');
          final attemptsResponse = await api.get('/quiz_attempt', query: {
            'course_quiz_id': _quizId.toString(),
            'user_id': user.id.toString(),
          });
          if (attemptsResponse['success'] == true) {
            final attemptsData = attemptsResponse['data'] ?? [];
            final attempts = List<Map<String, dynamic>>.from(attemptsData);
            if (attempts.isNotEmpty) {
              latestAttempt = attempts.reduce((a, b) {
                final idA = _safeGetAttemptId(a);
                final idB = _safeGetAttemptId(b);
                return idA > idB ? a : b;
              });
              developer.log('âœ… Manual latest attempt found: ${_safeGetAttemptId(latestAttempt!)}');
            }
          }
        } catch (e) {
          developer.log('âš ï¸ Manual attempt fetch failed: $e');
        }
      }

      int attemptId;
      int nextAttemptNumber;

      if (latestAttempt != null) {
        final latestStatus = latestAttempt['status']?.toString() ?? '';
        if (latestStatus == 'in_progress') {
          attemptId = _safeGetAttemptId(latestAttempt);
          nextAttemptNumber = _safeGetAttemptNumber(latestAttempt);
          developer.log('ðŸ”„ RESUMING existing attempt: ID $attemptId (Attempt #$nextAttemptNumber)');
          if (mounted) {
            _showResumeSnackBar(nextAttemptNumber);
          }
        } else {
          developer.log('â„¹ï¸ Latest attempt completed (${latestStatus}), creating new one');
          latestAttempt = null;
        }
      }

      if (latestAttempt == null) {
        final List<Map<String, dynamic>> existingAttempts = [];
        try {
          final attemptsResponse = await api.get('/quiz_attempt', query: {
            'course_quiz_id': _quizId.toString(),
            'user_id': user.id.toString(),
          });
          if (attemptsResponse['success'] == true) {
            final attemptsData = attemptsResponse['data'] ?? [];
            existingAttempts.addAll(List<Map<String, dynamic>>.from(attemptsData));
            developer.log('ðŸ“Š Found ${existingAttempts.length} existing attempts');
          }
        } catch (e) {
          developer.log("âš ï¸ Could not fetch existing attempts: $e");
        }

        nextAttemptNumber = 1;
        if (existingAttempts.isNotEmpty) {
          try {
            final validAttemptNumbers = <int>[];
            for (var attempt in existingAttempts) {
              final attemptNum = _safeGetAttemptNumber(attempt);
              if (attemptNum > 0) {
                validAttemptNumbers.add(attemptNum);
              }
            }
            if (validAttemptNumbers.isNotEmpty) {
              nextAttemptNumber = validAttemptNumbers.reduce((a, b) => a > b ? a : b) + 1;
              developer.log('ðŸ“ˆ Next attempt calculated: $nextAttemptNumber');
            }
          } catch (e) {
            developer.log('âŒ Error calculating next attempt number: $e');
            nextAttemptNumber = 1;
          }
        }

        developer.log("ðŸ“Š Creating NEW attempt #$nextAttemptNumber for quiz $_quizId");
        final response = await api.post('/quiz_attempt', {
          'course_quiz_id': _quizId.toString(),
          'user_id': user.id.toString(),
          'attempt_number': nextAttemptNumber.toString(),
          'status': 'in_progress',
          'current_question_index': '0',
          'time_spent_total': '0',
          'score': '0.00',
          'total_marks': '0.00',
          'obtained_marks': '0.00',
          'correct_answers': '0',
          'incorrect_answers': '0',
          'unanswered_questions': '0',
          'questions_data': '[]',
        });

        if (response['success'] != true) {
          throw Exception('Failed to start quiz: ${response['message'] ?? 'Unknown error'}');
        }

        attemptId = safeIntParse(
            response['data']?['id'] ?? response['id'],
            context: 'New attempt ID from API response',
            defaultValue: 0
        );

        if (attemptId == 0) {
          throw Exception("âŒ NO VALID ATTEMPT ID RETURNED!");
        }

        developer.log("âœ… NEW ATTEMPT CREATED: ID $attemptId (Attempt #$nextAttemptNumber)");
      } else {
        attemptId = _safeGetAttemptId(latestAttempt!);
      }

      final isInstantQuiz = _isInstantQuiz(widget.quiz);
      if (!mounted) return;

      final routeData = {
        'quiz': widget.quiz,
        'attempt_id': attemptId,
      };

      developer.log('ðŸŽ¯ Navigating to ${isInstantQuiz ? "Instant" : "Standard"} Quiz Player with attempt ID: $attemptId');

      if (isInstantQuiz) {
        context.go('/quizzes/instant-player', extra: routeData);
      } else {
        context.go('/quizzes/standard-player', extra: routeData);
      }
    } catch (e, stackTrace) {
      developer.log("âŒ START QUIZ ERROR: $e\nSTACK TRACE:\n$stackTrace");
      if (!mounted) return;
      _showErrorSnackBar("Failed to start quiz: ${e.toString().split('\n').first}");
    } finally {
      if (mounted) {
        setState(() => isStarting = false);
      }
    }
  }

  void _showResumeSnackBar(int attemptNumber) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.play_arrow, color: Colors.white),
            const SizedBox(width: 8),
            Text('Resuming your previous attempt #$attemptNumber'),
          ],
        ),
        backgroundColor: Colors.orange,
        duration: const Duration(seconds: 2),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    );
  }

  void _showErrorSnackBar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.error_outline, color: Colors.white),
            const SizedBox(width: 8),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 4),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    );
  }

  void _shareQuiz() {
    try {
      final slug = widget.quiz['slug'] ?? widget.quiz['id'].toString();
      final shareUrl = "https://prepking.online/q/$slug";
      final title = widget.quiz['quiz_title'] ?? "Check out this quiz!";
      Share.share(
        "Hey! Try this amazing quiz on PrepKing:\n\n$title\n\n$shareUrl",
        subject: title,
      );
    } catch (e) {
      developer.log('âŒ Share error: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to share quiz'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Widget _buildAttemptHistory() {
    return Consumer(
      builder: (context, ref, child) {
        final attemptsAsync = ref.watch(quizAttemptsProvider(_quizId));
        return attemptsAsync.when(
          data: (attempts) {
            if (attempts.isEmpty) return const SizedBox.shrink();

            List<Map<String, dynamic>> sortedAttempts;
            try {
              sortedAttempts = List.from(attempts);
              sortedAttempts.sort((a, b) {
                final idA = safeIntParse(a['id'], context: 'History sort A', defaultValue: 0);
                final idB = safeIntParse(b['id'], context: 'History sort B', defaultValue: 0);
                return idB.compareTo(idA);
              });
            } catch (e) {
              developer.log('âŒ Attempt history sorting error: $e');
              sortedAttempts = List.from(attempts);
            }

            return Card(
              margin: const EdgeInsets.only(top: 16, bottom: 8),
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Icon(Icons.history, color: Color(0xFF6C5CE7)),
                        const SizedBox(width: 8),
                        Text(
                          'ðŸ“‹ Attempt History',
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.w600,
                            color: Colors.black87,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    ...sortedAttempts.take(5).map((attempt) {
                      try {
                        final status = attempt['status']?.toString() ?? 'unknown';
                        final attemptNum = _safeGetAttemptNumber(attempt);
                        final score = attempt['score']?.toString() ?? '0.00';
                        final startedAt = attempt['started_at']?.toString();

                        Color getStatusColor() {
                          if (status == 'in_progress') return Colors.orange;
                          if (score != '0.00') {
                            final scoreNum = double.tryParse(score);
                            if (scoreNum != null && scoreNum > 0) return Colors.green;
                          }
                          return Colors.grey;
                        }

                        String getStatusText() {
                          switch (status) {
                            case 'in_progress':
                              return 'In Progress';
                            case 'completed':
                              return 'Completed';
                            default:
                              return status;
                          }
                        }

                        return Padding(
                          padding: const EdgeInsets.symmetric(vertical: 4),
                          child: ListTile(
                            dense: true,
                            contentPadding: EdgeInsets.zero,
                            leading: CircleAvatar(
                              radius: 16,
                              backgroundColor: getStatusColor(),
                              child: Text(
                                '$attemptNum',
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                  fontSize: 12,
                                ),
                              ),
                            ),
                            title: Text(
                              'Attempt #$attemptNum',
                              style: GoogleFonts.poppins(
                                fontWeight: FontWeight.w600,
                                fontSize: 14,
                              ),
                            ),
                            subtitle: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  getStatusText(),
                                  style: GoogleFonts.poppins(
                                    fontSize: 12,
                                    color: getStatusColor(),
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                                if (startedAt != null && startedAt.isNotEmpty)
                                  Text(
                                    _formatDateTime(startedAt),
                                    style: GoogleFonts.poppins(
                                      fontSize: 11,
                                      color: Colors.grey[600],
                                    ),
                                  ),
                              ],
                            ),
                            trailing: status == 'in_progress'
                                ? const Icon(Icons.play_arrow_rounded, color: Colors.orange, size: 20)
                                : Text(
                              score,
                              style: GoogleFonts.poppins(
                                fontWeight: FontWeight.bold,
                                fontSize: 14,
                                color: getStatusColor(),
                              ),
                            ),
                          ),
                        );
                      } catch (e) {
                        developer.log('âŒ Error building attempt item: $e');
                        return const SizedBox.shrink();
                      }
                    }),
                    if (sortedAttempts.length > 5)
                      Padding(
                        padding: const EdgeInsets.only(top: 12),
                        child: TextButton.icon(
                          onPressed: () {
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Full history feature coming soon!'),
                                  duration: Duration(seconds: 2),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.arrow_forward_ios, size: 14),
                          label: Text(
                            'View all ${sortedAttempts.length} attempts',
                            style: GoogleFonts.poppins(fontWeight: FontWeight.w500),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            );
          },
          loading: () => const SizedBox.shrink(),
          error: (error, stack) {
            developer.log('âŒ Attempt history error: $error\n$stack');
            return const SizedBox.shrink();
          },
        );
      },
    );
  }

  String _formatDateTime(String dateTimeString) {
    try {
      final dateTime = DateTime.parse(dateTimeString);
      return '${_getRelativeTime(dateTime)} â€¢ ${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
    } catch (e) {
      developer.log('âŒ DateTime parse error: $e');
      return dateTimeString;
    }
  }

  String _getRelativeTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    if (difference.inDays > 0) return '${difference.inDays}d ago';
    if (difference.inHours > 0) return '${difference.inHours}h ago';
    if (difference.inMinutes > 0) return '${difference.inMinutes}m ago';
    return 'Just now';
  }

  @override
  Widget build(BuildContext context) {
    final quiz = widget.quiz;
    final isInstant = _isInstantQuiz(quiz);

    if (_quizId == 0) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('Invalid Quiz'),
          backgroundColor: Colors.red,
        ),
        body: const Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error_outline, size: 80, color: Colors.red),
              SizedBox(height: 16),
              Text('Invalid quiz data', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              SizedBox(height: 8),
              Text('Please try again or contact support', style: TextStyle(color: Colors.grey)),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        title: Text(
          quiz['quiz_title'] ?? "Quiz",
          style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
        ),
        backgroundColor: Colors.transparent,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [const Color(0xFF6C5CE7), const Color(0xFF8B78FF)],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => context.pop(),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.share_rounded, color: Colors.white),
            onPressed: _shareQuiz,
            tooltip: "Share Quiz",
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            Card(
              elevation: 8,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
              child: Padding(
                padding: const EdgeInsets.all(24),
                child: Column(
                  children: [
                    Text(
                      quiz['quiz_title'] ?? "Quiz",
                      style: GoogleFonts.poppins(
                        fontSize: 28,
                        fontWeight: FontWeight.bold,
                        color: Colors.black87,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 20),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        _infoChip(
                          Icons.timer,
                          isInstant
                              ? "30 sec per Q"
                              : "${safeIntParse(quiz['duration_minutes'], context: 'duration_minutes', defaultValue: 10)} mins",
                        ),
                        _infoChip(
                          Icons.quiz,
                          "${safeIntParse(quiz['total_questions'], context: 'total_questions', defaultValue: 10)} Qs",
                        ),
                        _infoChip(
                          Icons.star,
                          "${safeIntParse(quiz['passing_criteria'], context: 'passing_criteria', defaultValue: 60)}% Pass",
                        ),
                      ],
                    ),
                    if (isInstant) ...[
                      const SizedBox(height: 20),
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [Colors.orange.shade400, Colors.orange.shade600],
                          ),
                          borderRadius: BorderRadius.circular(20),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.orange.withOpacity(0.3),
                              blurRadius: 10,
                              spreadRadius: 2,
                            ),
                          ],
                        ),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(Icons.flash_on, color: Colors.white, size: 20),
                            const SizedBox(width: 8),
                            Text(
                              "Instant Quiz Mode",
                              style: GoogleFonts.poppins(
                                fontWeight: FontWeight.bold,
                                color: Colors.white,
                                fontSize: 14,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                    if (quiz['description'] != null && quiz['description'].toString().isNotEmpty) ...[
                      const SizedBox(height: 20),
                      Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Colors.grey[50],
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(color: Colors.grey[200]!),
                        ),
                        child: Text(
                          quiz['description']!,
                          style: GoogleFonts.poppins(
                            fontSize: 14,
                            color: Colors.grey[600],
                            height: 1.5,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
            _buildAttemptHistory(),
            const SizedBox(height: 24),
            Card(
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Icon(Icons.info_outline, color: Color(0xFF6C5CE7)),
                        const SizedBox(width: 8),
                        Text(
                          "Instructions",
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.black87,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    ...[
                      _buildInstructionItem(
                        isInstant
                            ? "âš¡ 30 seconds per question with instant feedback"
                            : "â±ï¸ ${safeIntParse(quiz['duration_minutes'], context: 'instruction_duration', defaultValue: 10)} minutes total time",
                      ),
                      _buildInstructionItem(
                        isInstant
                            ? "ðŸŽ¯ Auto-advance to next question"
                            : "ðŸ“ Review and change answers before submitting",
                      ),
                      _buildInstructionItem("âœ… No negative marking"),
                      _buildInstructionItem("ðŸŽ® Complete in one session"),
                      _buildInstructionItem("ðŸ’¾ Progress automatically saved"),
                    ],
                  ],
                ),
              ),
            ),
            const SizedBox(height: 32),
            Consumer(
              builder: (context, ref, child) {
                final latestAttemptAsync = ref.watch(latestQuizAttemptProvider(_quizId));
                String buttonText = isInstant ? "ðŸš€ Start Instant Quiz" : "ðŸš€ Start Quiz Now";
                Color buttonColor = const Color(0xFF6C5CE7);
                IconData buttonIcon = isInstant ? Icons.flash_on : Icons.play_arrow_rounded;

                if (latestAttemptAsync.asData?.value != null) {
                  final latestAttempt = latestAttemptAsync.asData!.value!;
                  final status = latestAttempt['status']?.toString() ?? '';
                  if (status == 'in_progress') {
                    buttonText = "ðŸ“± Resume Previous Attempt";
                    buttonColor = Colors.orange;
                    buttonIcon = Icons.play_arrow_rounded;
                  }
                }

                return Column(
                  children: [
                    SizedBox(
                      width: double.infinity,
                      height: 65,
                      child: ElevatedButton.icon(
                        onPressed: isStarting ? null : _startQuiz,
                        icon: isStarting
                            ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(
                            color: Colors.white,
                            strokeWidth: 2,
                          ),
                        )
                            : Icon(buttonIcon),
                        label: Text(
                          isStarting ? "Starting Quiz..." : buttonText,
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.white,
                          ),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: isStarting ? Colors.grey : buttonColor,
                          foregroundColor: Colors.white,
                          elevation: isStarting ? 0 : 10,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(30),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 16),
                        ),
                      ),
                    ),
                    Consumer(
                      builder: (context, ref, child) {
                        final latestAttemptAsync = ref.watch(latestQuizAttemptProvider(_quizId));
                        if (latestAttemptAsync.asData?.value != null) {
                          final latestAttempt = latestAttemptAsync.asData!.value!;
                          final status = latestAttempt['status']?.toString() ?? '';
                          if (status == 'in_progress' && !isStarting) {
                            return Padding(
                              padding: const EdgeInsets.only(top: 12),
                              child: Container(
                                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                decoration: BoxDecoration(
                                  color: Colors.orange.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(20),
                                  border: Border.all(color: Colors.orange.withOpacity(0.3)),
                                ),
                                child: Row(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    Icon(Icons.info_outline, size: 16, color: Colors.orange),
                                    const SizedBox(width: 6),
                                    Text(
                                      "Your previous attempt is still in progress. Tap to resume!",
                                      style: GoogleFonts.poppins(
                                        fontSize: 12,
                                        color: Colors.orange[700],
                                        fontWeight: FontWeight.w500,
                                      ),
                                      textAlign: TextAlign.center,
                                    ),
                                  ],
                                ),
                              ),
                            );
                          }
                        }
                        return const SizedBox.shrink();
                      },
                    ),
                    const SizedBox(height: 20),
                  ],
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _infoChip(IconData icon, String text) {
    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: const Color(0xFF6C5CE7).withOpacity(0.1),
            shape: BoxShape.circle,
          ),
          child: Icon(icon, color: const Color(0xFF6C5CE7), size: 28),
        ),
        const SizedBox(height: 8),
        Text(
          text,
          style: GoogleFonts.poppins(
            fontSize: 13,
            fontWeight: FontWeight.w600,
            color: Colors.black87,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildInstructionItem(String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 20,
            height: 20,
            decoration: const BoxDecoration(
              color: Color(0xFF6C5CE7),
              shape: BoxShape.circle,
            ),
            child: const Icon(
              Icons.check,
              color: Colors.white,
              size: 12,
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              text,
              style: GoogleFonts.poppins(
                fontSize: 14,
                height: 1.4,
                color: Colors.black87,
              ),
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\quiz_result_screen.dart =====

// lib/screens/quizzes/quiz_result_screen.dart
import 'dart:convert';
import 'dart:io';
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:path_provider/path_provider.dart';
import 'package:screenshot/screenshot.dart';
import 'package:share_plus/share_plus.dart';
import 'dart:developer' as developer;

class QuizResultScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> result;
  const QuizResultScreen({super.key, required this.result});

  @override
  ConsumerState<QuizResultScreen> createState() => _QuizResultScreenState();
}

class _QuizResultScreenState extends ConsumerState<QuizResultScreen> {
  late final ConfettiController _confettiController;
  final ScreenshotController _screenshotController = ScreenshotController();

  double _score = 0.0;
  double _fullMarks = 50.0;
  double _percentage = 0.0;
  String _quizTitle = "Quiz";
  int _attemptId = 0;

  @override
  void initState() {
    super.initState();
    _confettiController = ConfettiController(duration: const Duration(seconds: 5));
    _extractResultData();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      Future.delayed(const Duration(milliseconds: 800), () {
        if (mounted && _percentage >= 60) {
          _confettiController.play();
        }
      });
    });
  }

  void _extractResultData() {
    try {
      final data = widget.result['data'] ?? widget.result;

      final String? idStr = data['id']?.toString() ??
          data['attempt_id']?.toString() ??
          data['attemptId']?.toString();
      _attemptId = int.tryParse(idStr ?? '') ?? 0;

      _quizTitle = data['quiz_title']?.toString() ??
          data['title']?.toString() ??
          "Quiz Result";

      final String? scoreStr = data['obtained_marks']?.toString() ??
          data['score']?.toString() ??
          data['result_score']?.toString();
      final String? totalStr = data['total_marks']?.toString() ??
          data['full_marks']?.toString() ??
          '50';

      _score = double.tryParse(scoreStr ?? '0') ?? 0.0;
      _fullMarks = double.tryParse(totalStr ?? '50') ?? 50.0;
      _percentage = _fullMarks > 0 ? (_score / _fullMarks) * 100 : 0.0;

      developer.log(
          'QuizResult â†’ attemptId: $_attemptId | Score: $_score/$_fullMarks (${_percentage.toStringAsFixed(1)}%)');
      setState(() {});
    } catch (e, s) {
      developer.log('Error extracting result data', error: e, stackTrace: s);
      setState(() {});
    }
  }

  Future<void> _shareScreenshot() async {
    // Critical: Delay to ensure full layout + confetti render
    await Future.delayed(const Duration(milliseconds: 800));

    try {
      final imageBytes = await _screenshotController.capture(
        delay: const Duration(milliseconds: 400),
        pixelRatio: MediaQuery.of(context).devicePixelRatio * 1.5, // High quality
      );

      if (imageBytes == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Failed to capture screenshot")),
        );
        return;
      }

      final quizData = widget.result['data'] ?? widget.result;
      final String slugOrId = () {
        final slug = quizData['slug']?.toString().trim();
        if (slug != null && slug.isNotEmpty) return slug;
        final quizId = quizData['quiz_id'] ?? quizData['id'];
        return quizId?.toString() ?? 'unknown';
      }();

      final String shareUrl = "https://prepking.online/q/$slugOrId";
      final directory = await getTemporaryDirectory();
      final path =
          '${directory.path}/quiz_result_${DateTime.now().millisecondsSinceEpoch}.png';
      final file = File(path)..writeAsBytesSync(imageBytes);

      await Share.shareXFiles(
        [XFile(path)],
        text:
        "I scored ${_score.toInt()}/${_fullMarks.toInt()} (${_percentageString}%) in \"$_quizTitle\" on PrepKing!\n\nCan you beat my score?\n\n$shareUrl",
        subject: "My Quiz Result - PrepKing",
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("Share failed: $e")),
        );
      }
    }
  }

  String get _percentageString => _percentage.toStringAsFixed(1);

  void _navigateToReview() {
    if (_attemptId <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Review not available for this attempt")),
      );
      return;
    }
    context.push(
      '/quiz-review',
      extra: {
        'attemptId': _attemptId,
        'testName': _quizTitle,
      },
    );
  }

  @override
  void dispose() {
    _confettiController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final passed = _percentage >= 60;
    final totalQuestions =
    (widget.result['data']?['total_questions'] ?? 5).toString();

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      body: SafeArea(
        child: SingleChildScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // ==================== FULL SCORECARD (CAPTURED AREA) ====================
              Screenshot(
                controller: _screenshotController,
                child: Container(
                  color: const Color(0xFFF8FAFC),
                  child: Stack(
                    children: [
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.stretch,
                        children: [
                          // Header: Lottie + Message
                          Container(
                            padding: const EdgeInsets.fromLTRB(20, 40, 20, 30),
                            decoration: BoxDecoration(
                              gradient: LinearGradient(
                                begin: Alignment.topCenter,
                                end: Alignment.bottomCenter,
                                colors: [
                                  const Color(0xFF6C5CE7).withOpacity(0.15),
                                  Colors.white.withOpacity(0.9),
                                  Colors.white,
                                ],
                              ),
                            ),
                            child: Column(
                              children: [
                                Lottie.asset(
                                  passed
                                      ? 'assets/lottie/trophy.json'
                                      : 'assets/lottie/sad.json',
                                  width: 260,
                                  height: 260,
                                  fit: BoxFit.contain,
                                  repeat: true,
                                  errorBuilder: (_, __, ___) => Icon(
                                    passed ? Icons.celebration : Icons.sentiment_dissatisfied,
                                    size: 160,
                                    color: passed ? Colors.amber.shade700 : Colors.orange.shade700,
                                  ),
                                ),
                                const SizedBox(height: 20),
                                Container(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 36, vertical: 18),
                                  decoration: BoxDecoration(
                                    color:
                                    passed ? Colors.green.shade600 : Colors.orange.shade600,
                                    borderRadius: BorderRadius.circular(32),
                                    boxShadow: [
                                      BoxShadow(
                                        color: (passed ? Colors.green : Colors.orange)
                                            .withOpacity(0.5),
                                        blurRadius: 16,
                                        offset: const Offset(0, 8),
                                      ),
                                    ],
                                  ),
                                  child: Text(
                                    passed
                                        ? "Congratulations! You Passed!"
                                        : "Better Luck Next Time!",
                                    style: GoogleFonts.poppins(
                                      fontSize: 26,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white,
                                    ),
                                    textAlign: TextAlign.center,
                                  ),
                                ),
                              ],
                            ),
                          ),

                          // Score & Stats
                          Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 20),
                            child: Column(
                              children: [
                                // Final Score Card
                                Card(
                                  elevation: 14,
                                  shadowColor: const Color(0xFF6C5CE7).withOpacity(0.35),
                                  shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(28)),
                                  child: Padding(
                                    padding: const EdgeInsets.all(32.0),
                                    child: Column(
                                      children: [
                                        Text(
                                          "Your Final Score",
                                          style: GoogleFonts.poppins(
                                            fontSize: 22,
                                            color: Colors.grey[700],
                                            fontWeight: FontWeight.w600,
                                          ),
                                        ),
                                        const SizedBox(height: 28),
                                        FittedBox(
                                          child: Row(
                                            mainAxisAlignment: MainAxisAlignment.center,
                                            children: [
                                              Text(
                                                _score.toStringAsFixed(0),
                                                style: GoogleFonts.poppins(
                                                  fontSize: 84,
                                                  fontWeight: FontWeight.bold,
                                                  color: const Color(0xFF6C5CE7),
                                                ),
                                              ),
                                              Text(
                                                " / ${_fullMarks.toStringAsFixed(0)}",
                                                style: GoogleFonts.poppins(
                                                  fontSize: 38,
                                                  color: Colors.grey[600],
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                        const SizedBox(height: 24),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                              horizontal: 44, vertical: 16),
                                          decoration: BoxDecoration(
                                            color: passed
                                                ? Colors.green.shade600
                                                : Colors.orange.shade600,
                                            borderRadius: BorderRadius.circular(32),
                                          ),
                                          child: Text(
                                            "${_percentageString}%",
                                            style: GoogleFonts.poppins(
                                              fontSize: 38,
                                              fontWeight: FontWeight.bold,
                                              color: Colors.white,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ),

                                const SizedBox(height: 28),

                                // Quiz Info + Stats Card
                                Card(
                                  elevation: 10,
                                  shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(20)),
                                  child: Padding(
                                    padding: const EdgeInsets.all(24.0),
                                    child: Column(
                                      children: [
                                        Row(
                                          children: [
                                            Container(
                                              padding: const EdgeInsets.all(14),
                                              decoration: BoxDecoration(
                                                color: const Color(0xFF6C5CE7)
                                                    .withOpacity(0.12),
                                                borderRadius:
                                                BorderRadius.circular(16),
                                              ),
                                              child: const Icon(Icons.quiz_outlined,
                                                  color: Color(0xFF6C5CE7), size: 32),
                                            ),
                                            const SizedBox(width: 16),
                                            Expanded(
                                              child: Column(
                                                crossAxisAlignment:
                                                CrossAxisAlignment.start,
                                                children: [
                                                  Text(
                                                    _quizTitle,
                                                    style: GoogleFonts.poppins(
                                                        fontSize: 20,
                                                        fontWeight:
                                                        FontWeight.w600),
                                                  ),
                                                  Text(
                                                    "$totalQuestions Questions â€¢ Instant Quiz",
                                                    style: GoogleFonts.poppins(
                                                        fontSize: 15,
                                                        color: Colors.grey[600]),
                                                  ),
                                                ],
                                              ),
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 28),
                                        Row(
                                          mainAxisAlignment:
                                          MainAxisAlignment.spaceEvenly,
                                          children: [
                                            _buildStatCard(Icons.timer_outlined,
                                                "Time Taken", "2m 30s"),
                                            _buildStatCard(Icons.trending_up,
                                                "Accuracy", "${_percentageString}%"),
                                            _buildStatCard(Icons.star,
                                                "Points", _score.toStringAsFixed(0)),
                                          ],
                                        ),
                                      ],
                                    ),
                                  ),
                                ),

                                const SizedBox(height: 80), // Clean bottom padding for share
                              ],
                            ),
                          ),
                        ],
                      ),

                      // Confetti (inside screenshot)
                      if (passed)
                        ConfettiWidget(
                          confettiController: _confettiController,
                          blastDirectionality: BlastDirectionality.explosive,
                          emissionFrequency: 0.04,
                          numberOfParticles: 80,
                          gravity: 0.18,
                          shouldLoop: false,
                          colors: const [
                            Colors.red,
                            Colors.blue,
                            Colors.green,
                            Colors.yellow,
                            Colors.purple,
                            Colors.orange,
                            Colors.pink
                          ],
                        ),
                    ],
                  ),
                ),
              ),

              // ==================== ACTION BUTTONS (OUTSIDE SCREENSHOT) ====================
              Padding(
                padding: const EdgeInsets.fromLTRB(20, 40, 20, 50),
                child: Column(
                  children: [
                    SizedBox(
                      width: double.infinity,
                      height: 60,
                      child: ElevatedButton.icon(
                        onPressed: _shareScreenshot,
                        icon: const Icon(Icons.share, size: 28),
                        label: Text(
                          "Share My Result",
                          style: GoogleFonts.poppins(
                              fontSize: 19, fontWeight: FontWeight.w600),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.green.shade600,
                          elevation: 8,
                          shadowColor: Colors.green.withOpacity(0.5),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(30)),
                        ),
                      ),
                    ),
                    const SizedBox(height: 18),
                    SizedBox(
                      width: double.infinity,
                      height: 60,
                      child: ElevatedButton.icon(
                        onPressed: _attemptId > 0 ? _navigateToReview : null,
                        icon: const Icon(Icons.remove_red_eye_outlined, size: 28),
                        label: Text(
                          _attemptId > 0 ? "Review Answers" : "Review Not Available",
                          style: GoogleFonts.poppins(
                              fontSize: 19, fontWeight: FontWeight.w600),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _attemptId > 0
                              ? const Color(0xFF6C5CE7)
                              : Colors.grey.shade400,
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(30)),
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),
                    SizedBox(
                      width: double.infinity,
                      height: 60,
                      child: OutlinedButton.icon(
                        onPressed: () => context.go('/quizzes'),
                        icon: const Icon(Icons.arrow_back_ios_new, size: 22),
                        label: Text(
                          "Back to Quizzes",
                          style: GoogleFonts.poppins(
                              fontSize: 19, fontWeight: FontWeight.w600),
                        ),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: const Color(0xFF6C5CE7),
                          side: const BorderSide(
                              color: Color(0xFF6C5CE7), width: 2.8),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(30)),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildStatCard(IconData icon, String label, String value) {
    return Column(
      children: [
        Container(
          width: 70,
          height: 70,
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                const Color(0xFF6C5CE7).withOpacity(0.2),
                const Color(0xFF5A4FCF).withOpacity(0.1)
              ],
            ),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(color: const Color(0xFF6C5CE7).withOpacity(0.4)),
          ),
          child: Icon(icon, color: const Color(0xFF6C5CE7), size: 34),
        ),
        const SizedBox(height: 14),
        Text(
          value,
          style: GoogleFonts.poppins(
              fontSize: 20, fontWeight: FontWeight.bold, color: const Color(0xFF6C5CE7)),
        ),
        Text(
          label,
          style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade600),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\quiz_review_screen.dart =====

import 'package:flutter/material.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';

class QuizReviewScreen extends StatefulWidget {
  final int attemptId; // Only this is required now
  final String? testName;

  const QuizReviewScreen({
    Key? key,
    required this.attemptId,
    this.testName,
  }) : super(key: key);

  @override
  _QuizReviewScreenState createState() => _QuizReviewScreenState();
}

class _QuizReviewScreenState extends State<QuizReviewScreen> {
  List<Map<String, dynamic>> _questions = [];
  Map<String, dynamic> _testStats = {};
  Map<String, dynamic> _metaData = {};
  bool _isLoading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _fetchReviewData();
  }

  Future<void> _fetchReviewData() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final url =
          'https://quizard.in/api_002.php/attempt_review/fulldata/${widget.attemptId}';
      final response = await http.get(Uri.parse(url)).timeout(
        Duration(seconds: 15),
      );

      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);

        if (jsonResponse['success'] == true) {
          final data = jsonResponse['data'];

          // Extract metadata
          _metaData = {
            'quiz_title': data['quiz_title'] ?? 'Quiz Review',
            'score': data['obtained_marks'] ?? '0',
            'total_marks': data['total_marks'] ?? '0',
            'percentage': data['result_percentage'] ?? '0',
            'time_taken': data['time_spent_total'] ?? 0,
            'completed_at': data['completed_at'] ?? '',
            'user_name': data['user_name'] ?? '',
          };

          final List<dynamic> rawQuestions = data['questions_data'] ?? [];

          final List<Map<String, dynamic>> parsedQuestions = rawQuestions.map((item) {
            final fullQ = item['full_question'] as Map<String, dynamic>;

            // Convert option1, option2, option3, option4 â†’ List<String>
            List<String> options = [];
            for (int i = 1; i <= 4; i++) {
              String? opt = fullQ['option$i'];
              if (opt != null && opt.toString().trim().isNotEmpty) {
                options.add(opt.toString().trim());
              }
            }

            // Correct answer is 1-based in API, but we convert to 0-based letter (A, B, C, D)
            int correctIdx = (fullQ['correct_answer'] is num)
                ? (fullQ['correct_answer'] as num).toInt()
                : 0;
            String correctOptionLetter = correctIdx >= 0 && correctIdx < 4
                ? String.fromCharCode(65 + correctIdx)
                : '?';

            // Selected option is string like "1", "2", etc. â†’ convert to "A", "B"
            String? selectedLetter;
            if (item['selected_option'] != null) {
              int sel = int.tryParse(item['selected_option'].toString()) ?? -1;
              if (sel >= 1 && sel <= 4) {
                selectedLetter = String.fromCharCode(64 + sel);
              }
            }

            return {
              'question_index': item['question_index'] ?? 0,
              'question_text': fullQ['question']?.toString() ?? 'Question not available',
              'options': options,
              'correct_answer': correctOptionLetter,
              'selected_option': selectedLetter,
              'is_correct': item['is_correct'] == true,
              'answered': item['answered'] == true,
              'marked': false, // not supported in new API, kept for compatibility
              'explanation': fullQ['explanation']?.toString(),
              'difficulty': fullQ['difficulty']?.toString() ?? 'Medium',
            };
          }).toList();

          final stats = _calculateTestStats(parsedQuestions);

          setState(() {
            _questions = parsedQuestions;
            _testStats = stats;
            _isLoading = false;
          });
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to load review');
        }
      } else {
        throw Exception('Server error: ${response.statusCode}');
      }
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  Map<String, dynamic> _calculateTestStats(List<Map<String, dynamic>> questions) {
    int total = questions.length;
    int correct = questions.where((q) => q['is_correct'] == true).length;
    int answered = questions.where((q) => q['answered'] == true).length;
    int incorrect = answered - correct;
    int unanswered = total - answered;

    double accuracy = total > 0 ? (correct / total) * 100 : 0.0;

    return {
      'total': total,
      'correct': correct,
      'incorrect': incorrect,
      'unanswered': unanswered,
      'accuracy': accuracy,
      'score': _metaData['score'] ?? '$correct/ $total',
    };
  }

  Future<void> _saveReview() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final reviews = prefs.getStringList('saved_reviews') ?? [];

      final reviewToSave = {
        'timestamp': DateTime.now().toIso8601String(),
        'attempt_id': widget.attemptId,
        'test_name': widget.testName ?? _metaData['quiz_title'],
        'stats': _testStats,
        'meta': _metaData,
        'questions': _questions,
      };

      reviews.add(jsonEncode(reviewToSave));
      await prefs.setStringList('saved_reviews', reviews);

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Review saved offline!'), backgroundColor: Colors.green),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Save failed'), backgroundColor: Colors.red),
      );
    }
  }

  // === UI Widgets (same beautiful design as before) ===

  Widget _buildStatsCard() {
    return Card(
      elevation: 6,
      margin: EdgeInsets.all(16),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: EdgeInsets.all(20),
        child: Column(
          children: [
            Text(
              _metaData['quiz_title'] ?? 'Quiz Review',
              style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: Colors.indigo),
            ),
            SizedBox(height: 12),
            Text(
              'Score: ${_metaData['score']} / ${_metaData['total_marks']}  â€¢  ${_metaData['percentage']}%',
              style: TextStyle(fontSize: 18, color: Colors.blueGrey),
            ),
            SizedBox(height: 20),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _buildStatItem('Correct', '${_testStats['correct']}', Colors.green),
                _buildStatItem('Wrong', '${_testStats['incorrect']}', Colors.red),
                _buildStatItem('Skipped', '${_testStats['unanswered']}', Colors.orange),
                _buildStatItem('Accuracy', '${_testStats['accuracy'].toStringAsFixed(1)}%', Colors.blue),
              ],
            ),
            SizedBox(height: 16),
            LinearProgressIndicator(
              value: _testStats['correct'] / _testStats['total'],
              backgroundColor: Colors.red.shade100,
              valueColor: AlwaysStoppedAnimation(Colors.green),
              minHeight: 10,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(String label, String value, Color color) {
    return Column(
      children: [
        Text(value, style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: color)),
        Text(label, style: TextStyle(color: Colors.grey.shade600)),
      ],
    );
  }

  Widget _buildQuestionCard(Map<String, dynamic> q, int index) {
    final selected = q['selected_option'] as String?;
    final correct = q['correct_answer'] as String;
    final options = q['options'] as List<String>;

    return Card(
      margin: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                CircleAvatar(
                  backgroundColor: q['is_correct']
                      ? Colors.green
                      : q['answered']
                      ? Colors.red
                      : Colors.grey,
                  child: Text('${q['question_index'] + 1}', style: TextStyle(color: Colors.white)),
                ),
                SizedBox(width: 12),
                Expanded(
                  child: Text(
                    'Question ${q['question_index'] + 1}',
                    style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                  ),
                ),
              ],
            ),
            SizedBox(height: 12),
            Text(q['question_text'], style: TextStyle(fontSize: 15, height: 1.5)),
            SizedBox(height: 20),

            // Options
            ...options.asMap().entries.map((e) {
              int idx = e.key;
              String text = e.value;
              String letter = String.fromCharCode(65 + idx);

              bool isCorrect = letter == correct;
              bool isSelected = letter == selected;

              return Container(
                margin: EdgeInsets.only(bottom: 8),
                padding: EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                decoration: BoxDecoration(
                  color: isCorrect
                      ? Colors.green.withOpacity(0.1)
                      : isSelected
                      ? Colors.red.withOpacity(0.1)
                      : null,
                  border: Border.all(
                    color: isCorrect
                        ? Colors.green
                        : isSelected
                        ? Colors.red
                        : Colors.grey.shade300,
                    width: isCorrect || isSelected ? 2 : 1,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    CircleAvatar(
                      radius: 14,
                      backgroundColor: isCorrect
                          ? Colors.green
                          : isSelected
                          ? Colors.red
                          : Colors.grey.shade300,
                      child: Text(letter, style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                    ),
                    SizedBox(width: 12),
                    Expanded(child: Text(text)),
                    if (isCorrect) Icon(Icons.check_circle, color: Colors.green),
                    if (isSelected && !isCorrect) Icon(Icons.cancel, color: Colors.red),
                  ],
                ),
              );
            }).toList(),

            SizedBox(height: 16),
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: q['is_correct']
                    ? Colors.green.withOpacity(0.1)
                    : q['answered']
                    ? Colors.red.withOpacity(0.1)
                    : Colors.grey.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    q['is_correct']
                        ? Icons.check_circle
                        : q['answered']
                        ? Icons.cancel
                        : Icons.help_outline,
                    color: q['is_correct']
                        ? Colors.green
                        : q['answered']
                        ? Colors.red
                        : Colors.grey,
                  ),
                  SizedBox(width: 12),
                  Text(
                    q['is_correct']
                        ? 'Correct Answer'
                        : q['answered']
                        ? 'Wrong Answer'
                        : 'Not Attempted',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  Spacer(),
                  Text('Correct: $correct', style: TextStyle(color: Colors.green, fontWeight: FontWeight.bold)),
                ],
              ),
            ),

            if (q['explanation'] != null && q['explanation'].toString().trim().isNotEmpty)
              Padding(
                padding: EdgeInsets.only(top: 16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(children: [Icon(Icons.lightbulb, color: Colors.amber), SizedBox(width: 8), Text('Explanation', style: TextStyle(fontWeight: FontWeight.bold))]),
                    SizedBox(height: 8),
                    Container(
                      width: double.infinity,
                      padding: EdgeInsets.all(12),
                      decoration: BoxDecoration(color: Colors.amber.shade50, borderRadius: BorderRadius.circular(8)),
                      child: Text(q['explanation'], style: TextStyle(height: 1.5)),
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.testName ?? 'Review'),
        actions: [
          IconButton(icon: Icon(Icons.save), onPressed: _saveReview),
          IconButton(icon: Icon(Icons.refresh), onPressed: _fetchReviewData),
        ],
      ),
      body: _isLoading
          ? Center(child: CircularProgressIndicator())
          : _error != null
          ? Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error, size: 64, color: Colors.red),
            SizedBox(height: 16),
            Text('Failed to load review', style: TextStyle(fontSize: 18)),
            Text(_error!, style: TextStyle(color: Colors.red)),
            ElevatedButton(onPressed: _fetchReviewData, child: Text('Retry')),
          ],
        ),
      )
          : Column(
        children: [
          _buildStatsCard(),
          Expanded(
            child: ListView.builder(
              itemCount: _questions.length,
              itemBuilder: (ctx, i) => _buildQuestionCard(_questions[i], i),
            ),
          ),
        ],
      ),
      floatingActionButton: _questions.isNotEmpty
          ? FloatingActionButton(
        child: Icon(Icons.arrow_upward),
        onPressed: () => PrimaryScrollController.of(context).animateTo(0, duration: Duration(milliseconds: 400), curve: Curves.ease),
      )
          : null,
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\standard_quiz_player_screen.dart =====

import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'dart:developer' as developer;
import '../../core/services/api_service.dart';
import '../../providers/user_provider.dart';

class StandardQuizPlayerScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> quiz;
  final int attemptId;

  const StandardQuizPlayerScreen({
    super.key,
    required this.quiz,
    required this.attemptId,
  });

  @override
  ConsumerState<StandardQuizPlayerScreen> createState() => _StandardQuizPlayerScreenState();
}

class _StandardQuizPlayerScreenState extends ConsumerState<StandardQuizPlayerScreen>
    with TickerProviderStateMixin, WidgetsBindingObserver {
  // Timer & Quiz State
  late Timer _timer;
  int _remainingSeconds = 0;
  int _originalDurationSeconds = 0;
  int _currentIndex = 0;
  int _score = 0;
  List<Map<String, dynamic>> _questions = [];
  List<String?> _selectedAnswers = [];
  bool _isLoading = true;
  bool _isSubmitting = false;
  bool _isResuming = false;

  // Quiz Mode
  late final bool _isSequential;

  // UI State
  bool _isAnswered = false;
  bool _isLocked = false;
  bool _isTransitioning = false;

  // Animation Controllers
  late AnimationController _questionController;
  late AnimationController _optionsController;
  late AnimationController _exitController;

  // Animations
  late Animation<Offset> _questionSlideAnimation;
  late Animation<double> _optionsFadeAnimation;
  late Animation<Offset> _exitSlideAnimation;

  // Question Palette
  bool _showPalette = false;
  List<bool> _visitedQuestions = [];
  List<bool> _answeredQuestions = [];
  List<bool> _markedQuestions = [];

  // Colors
  final Color _primaryColor = const Color(0xFF6C5CE7);

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeAnimations();
    _initQuizType();
    _loadAttemptAndQuestions();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _updateAttemptProgress();
    _questionController.dispose();
    _optionsController.dispose();
    _exitController.dispose();
    if (_timer.isActive) _timer.cancel();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.paused || state == AppLifecycleState.inactive) {
      _updateAttemptProgress();
    }
  }

  /// ðŸ”¥ STEP 1: MAGIC CONVERTER FUNCTION âœ… IMPLEMENTED
  int convertCorrectAnswer(dynamic value) {
    final v = int.tryParse(value?.toString() ?? '-1') ?? -1;
    if (v >= 0 && v <= 3) {
      return v + 1; // ðŸ”¥ Magic: 0â†’1, 1â†’2, 2â†’3, 3â†’4
    }
    return -1;
  }

  /// âœ… STEP 2: COMPLETE NORMALIZER WITH MAGIC CONVERSION
  Map<String, dynamic> normalizeQuestion(Map<String, dynamic> q) {
    return {
      'id': int.tryParse(q['id']?.toString() ?? '0') ?? 0,
      'quiz_id': int.tryParse(q['quiz_id']?.toString() ?? '0') ?? 0,
      'question': q['question']?.toString() ?? "",
      'option1': q['option1']?.toString() ?? "",
      'option2': q['option2']?.toString() ?? "",
      'option3': q['option3']?.toString() ?? "",
      'option4': q['option4']?.toString() ?? "",
      // ðŸ”¥ ONE LINE MAGIC! Handles ALL server formats
      'correct_answer': convertCorrectAnswer(q['correct_answer']),
      'order': int.tryParse(q['order']?.toString() ?? '0') ?? 0,
    };
  }

  /// âœ… STEP 3: SIMPLIFIED - Always returns clean INT (1-4 or -1)
  int _getCorrectAnswer(Map<String, dynamic> question) {
    final ans = question['correct_answer'];
    if (ans is int && ans >= 1 && ans <= 4) return ans;
    return -1;
  }

  void _initializeAnimations() {
    _questionController = AnimationController(
      duration: const Duration(milliseconds: 700),
      vsync: this,
    );
    _optionsController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );
    _exitController = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );

    _questionSlideAnimation = Tween<Offset>(
      begin: const Offset(0, 0.5),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _questionController,
      curve: Curves.elasticOut,
    ));

    _optionsFadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _optionsController,
      curve: Curves.easeIn,
    ));

    _exitSlideAnimation = Tween<Offset>(
      begin: Offset.zero,
      end: const Offset(-1.0, 0.0),
    ).animate(CurvedAnimation(
      parent: _exitController,
      curve: Curves.easeInOut,
    ));
  }

  void _initQuizType() {
    _isSequential = widget.quiz['is_sequential'] == "1" || widget.quiz['is_sequential'] == 1;
    final durationMinutes = int.tryParse(widget.quiz['duration_minutes']?.toString() ?? '10') ?? 10;
    _remainingSeconds = durationMinutes * 60;
    _originalDurationSeconds = durationMinutes * 60;
  }

  /// âœ… STEP 2 APPLIED: Full normalization in action
  Future<void> _loadAttemptAndQuestions() async {
    try {
      final api = ref.read(apiServiceProvider);

      // Step 1: Load raw questions from server
      final questionsResponse = await api.get('/saved_question/quiz/${widget.quiz['id']}');
      if (questionsResponse['success'] != true) {
        throw Exception(questionsResponse['message'] ?? 'Failed to load questions');
      }

      final List<dynamic> rawQuestions = questionsResponse['data'] ?? [];

      // ðŸ”¥ MAGIC HAPPENS HERE: FULL NORMALIZATION
      final questions = rawQuestions
          .map((q) => normalizeQuestion(q as Map<String, dynamic>))
          .toList();

      // âœ… VERIFICATION LOGGING
      developer.log('ðŸŽ¯ NORMALIZATION COMPLETE: ${questions.length} questions');
      for (int i = 0; i < questions.length && i < 3; i++) {
        final q = questions[i];
        developer.log('ðŸ“‹ Q${i + 1}: correct_answer = ${q['correct_answer']} (type: ${q['correct_answer'].runtimeType})');
      }

      // Step 2: Try to load attempt details
      Map<String, dynamic>? attempt;
      try {
        final attemptResponse = await api.get('/quiz_attempt/${widget.attemptId}');
        if (attemptResponse['success'] == true) {
          attempt = attemptResponse['data'];
        }
      } catch (e) {
        developer.log('âš ï¸ Could not load attempt details: $e');
      }

      if (!mounted) return;

      setState(() {
        _questions = questions;
        _selectedAnswers = List.filled(questions.length, null);
        _visitedQuestions = List.filled(questions.length, false);
        _answeredQuestions = List.filled(questions.length, false);
        _markedQuestions = List.filled(questions.length, false);
        _isLoading = false;
      });

      if (_questions.isEmpty) return;

      // âœ… RESUME LOGIC
      if (attempt != null && attempt['status'] == 'in_progress') {
        await _resumeAttempt(attempt);
      } else {
        // New attempt - start from beginning
        setState(() {
          _currentIndex = 0;
          _visitedQuestions[0] = true;
        });
        _startQuestionAnimations();
        _startMainTimer();
      }
    } catch (e) {
      developer.log("âŒ Load attempt error: $e");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("Failed to load quiz: $e")),
      );
      setState(() => _isLoading = false);
    }
  }

  Future<void> _resumeAttempt(Map<String, dynamic> attempt) async {
    try {
      setState(() => _isResuming = true);
      final currentQuestionIndex = int.tryParse(attempt['current_question_index']?.toString() ?? '0') ?? 0;
      final score = double.tryParse(attempt['obtained_marks']?.toString() ?? '0') ?? 0.0;
      developer.log('ðŸ”„ Resuming attempt ${attempt['id']} at question $currentQuestionIndex');
      developer.log('ðŸ“Š Current score: $score');

      // Load previous answers from attempt_review
      await _loadAttemptReviewAnswers(attempt['id'] as int);

      if (!mounted) return;

      setState(() {
        _currentIndex = currentQuestionIndex.clamp(0, _questions.length - 1);
        _score = score.toInt();
        _visitedQuestions[_currentIndex] = true;
        _answeredQuestions[_currentIndex] = _selectedAnswers[_currentIndex] != null;
        _isAnswered = _answeredQuestions[_currentIndex];
        _isResuming = false;
      });

      // Show resume message
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Row(
              children: [
                const Icon(Icons.play_arrow, color: Colors.white),
                const SizedBox(width: 8),
                Text('Resumed from question ${_currentIndex + 1}/${_questions.length} â€¢ Score: $_score'),
              ],
            ),
            backgroundColor: Colors.orange,
            duration: const Duration(seconds: 3),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
          ),
        );
      }

      _startQuestionAnimations();
      _startMainTimer();
    } catch (e) {
      developer.log('âŒ Resume attempt error: $e');
      setState(() => _isResuming = false);
      _startQuestionAnimations();
      _startMainTimer();
    }
  }

  Future<void> _loadAttemptReviewAnswers(int attemptId) async {
    try {
      final api = ref.read(apiServiceProvider);
      final response = await api.get('/attempt_review', query: {
        'result_id': attemptId.toString(),
      });
      if (response['success'] == true) {
        final List<dynamic> reviews = response['data'] ?? [];
        int loadedCount = 0;
        for (var review in reviews) {
          final questionId = review['question_id'] as int?;
          final selectedOption = review['selected_option'];
          final questionIndex = _questions.indexWhere((q) => (q['id'] as int) == questionId);
          if (questionIndex == -1) {
            developer.log('âš ï¸ Question ID $questionId not found');
            continue;
          }
          final selectedStr = selectedOption?.toString();
          _selectedAnswers[questionIndex] = selectedStr;
          _answeredQuestions[questionIndex] = true;
          _visitedQuestions[questionIndex] = true;
          loadedCount++;
        }
        developer.log('âœ… Loaded $loadedCount previous answers');
      }
    } catch (e) {
      developer.log('âš ï¸ Could not load attempt reviews: $e');
    }
  }

  Future<void> _updateAttemptProgress() async {
    try {
      final api = ref.read(apiServiceProvider);
      final questionsData = [];
      for (int i = 0; i < _questions.length; i++) {
        questionsData.add({
          'question_index': i,
          'question_id': _questions[i]['id'],
          'selected_option': _selectedAnswers[i],
          'answered': _answeredQuestions[i],
          'marked': _markedQuestions[i],
        });
      }
      await api.put('/quiz_attempt/${widget.attemptId}', {
        'current_question_index': _currentIndex.toString(),
        'questions_data': jsonEncode(questionsData),
        'time_spent_total': (_originalDurationSeconds - _remainingSeconds).toString(),
        'obtained_marks': _score.toString(),
        'correct_answers': _answeredQuestions.where((a) => a).length,
        'status': 'in_progress',
      });
      developer.log('âœ… Progress saved: Question $_currentIndex');
    } catch (e) {
      developer.log('âš ï¸ Failed to save progress: $e');
    }
  }

  void _startQuestionAnimations() {
    _questionController.forward().then((_) {
      Future.delayed(const Duration(milliseconds: 100), () {
        _optionsController.forward();
      });
    });
  }

  void _startMainTimer() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) return;
      setState(() {
        if (_remainingSeconds > 0) {
          _remainingSeconds--;
        } else {
          timer.cancel();
          _submitQuiz();
        }
      });
    });
  }

  /// âœ… STEP 4: PERFECT INT COMPARISON
  void _selectAnswer(String selectedOption) {
    if (_isAnswered || _isLocked) return;

    final selectedInt = int.tryParse(selectedOption);
    if (selectedInt == null || selectedInt < 1 || selectedInt > 4) {
      developer.log("âŒ Invalid option: $selectedOption");
      return;
    }

    final question = _questions[_currentIndex];
    final correctInt = _getCorrectAnswer(question); // Always 1-4 or -1
    final isCorrect = selectedInt == correctInt; // âœ… PURE INT COMPARISON

    developer.log('ðŸŽ¯ Answer Check: Selected=$selectedInt, Correct=$correctInt, Result=${isCorrect ? "âœ…" : "âŒ"}');

    setState(() {
      _selectedAnswers[_currentIndex] = selectedOption;
      _answeredQuestions[_currentIndex] = true;
      _isAnswered = true;
      _isLocked = true;
      if (isCorrect) _score += 10;
    });

    // Save answer immediately
    _saveAnswerToServer(selectedOption, isCorrect);
    _updateAttemptProgress();

    // Auto next after 1 second (optional)
    Future.delayed(const Duration(seconds: 1), () {
      if (mounted && _isAnswered && !_isTransitioning) {
        _goToNextQuestion();
      }
    });
  }

  void _goToNextQuestion() {
    _updateAttemptProgress();
    if (_currentIndex < _questions.length - 1) {
      setState(() => _isTransitioning = true);
      _exitController.forward().then((_) {
        _questionController.reset();
        _optionsController.reset();
        _exitController.reset();
        setState(() {
          _currentIndex++;
          _isAnswered = _selectedAnswers[_currentIndex] != null;
          _isLocked = false;
          _isTransitioning = false;
          _visitedQuestions[_currentIndex] = true;
        });
        _startQuestionAnimations();
      });
    } else {
      _showSubmitConfirmation();
    }
  }

  void _goToPreviousQuestion() {
    if (_currentIndex > 0) {
      _updateAttemptProgress();
      setState(() {
        _currentIndex--;
        _visitedQuestions[_currentIndex] = true;
        _isAnswered = _selectedAnswers[_currentIndex] != null;
        _isLocked = false;
      });
      _startQuestionAnimations();
    }
  }

  void _resetCurrentAnswer() {
    if (_selectedAnswers[_currentIndex] != null) {
      final question = _questions[_currentIndex];
      final correctInt = _getCorrectAnswer(question);
      final selectedInt = int.tryParse(_selectedAnswers[_currentIndex]!) ?? -1;
      final wasCorrect = selectedInt == correctInt;
      setState(() {
        _selectedAnswers[_currentIndex] = null;
        _answeredQuestions[_currentIndex] = false;
        _isAnswered = false;
        _isLocked = false;
        if (wasCorrect) _score -= 10;
      });
      _updateAttemptProgress();
    }
  }

  void _jumpToQuestion(int index) {
    _updateAttemptProgress();
    setState(() {
      _currentIndex = index;
      _visitedQuestions[_currentIndex] = true;
      _showPalette = false;
      _isAnswered = _selectedAnswers[_currentIndex] != null;
      _isLocked = false;
    });
    _startQuestionAnimations();
  }

  void _toggleMarkQuestion() {
    setState(() {
      _markedQuestions[_currentIndex] = !_markedQuestions[_currentIndex];
    });
    _updateAttemptProgress();
  }

  void _showQuestionPalette() {
    setState(() => _showPalette = true);
  }

  /// âœ… STEP 5: BULLETPROOF SERVER SAVE WITH INT VALUES
  Future<void> _saveAnswerToServer(String selected, bool isCorrect) async {
    try {
      final user = ref.read(currentUserProvider).asData?.value;
      if (user?.id == null) {
        developer.log("âŒ User ID missing");
        return;
      }

      final question = _questions[_currentIndex];
      final questionId = question['id'] as int;
      if (questionId == 0) {
        developer.log("âŒ Invalid question ID");
        return;
      }

      // âœ… DIRECT INT ACCESS - ZERO PARSING
      final correctInt = _getCorrectAnswer(question);
      final selectedInt = int.tryParse(selected) ?? -1;

      if (selectedInt < 1 || selectedInt > 4) {
        developer.log("âš ï¸ Invalid selected option: $selectedInt");
        return;
      }

      final Map<String, dynamic> payload = {
        'result_id': widget.attemptId,
        'quiz_id': widget.quiz['id'],
        'question_id': questionId,
        'user_id': user!.id,
        'question_text': question['question'] ?? 'Question unavailable',
        // ðŸ”¥ CLEAN INT VALUES
        'selected_option': selectedInt, // 1, 2, 3, or 4
        'correct_option': correctInt,   // 1, 2, 3, 4, or -1
        'is_correct': isCorrect ? 1 : 0,
        'question_marks': 10.00,
        'obtained_marks': isCorrect ? 10.00 : 0.00,
        'options_provided': [
          question['option1'] ?? '',
          question['option2'] ?? '',
          question['option3'] ?? '',
          question['option4'] ?? ''
        ],
        'time_spent': 45,
        'student_id': null,
      };

      developer.log("ðŸ“¤ Saving: Q$questionId | Selected: $selectedInt | Correct: $correctInt");

      final response = await ref.read(apiServiceProvider).post('/attempt_review', payload);
      if (response['success'] == true) {
        developer.log("âœ… Saved: Q$questionId | Result: ${isCorrect ? 'âœ…' : 'âŒ'}");
      } else {
        developer.log("âš ï¸ Save warning: ${response['message']}");
      }
    } catch (e, stackTrace) {
      developer.log("âŒ Save error: $e\n$stackTrace");
    }
  }

  Future<void> _submitQuiz() async {
    if (_isSubmitting) return;
    _isSubmitting = true;
    if (_timer.isActive) _timer.cancel();

    await _updateAttemptProgress();

    try {
      final userId = ref.read(currentUserProvider).asData?.value?.id;
      if (userId == null) throw Exception("User not found");

      // âœ… FINAL SCORE CALCULATION WITH INT COMPARISON
      int calculatedScore = 0;
      for (int i = 0; i < _questions.length; i++) {
        if (_selectedAnswers[i] != null) {
          final question = _questions[i];
          final correctInt = _getCorrectAnswer(question);
          final selectedInt = int.tryParse(_selectedAnswers[i]!) ?? -1;
          final isCorrect = selectedInt == correctInt;
          if (isCorrect) calculatedScore += 10;
        }
      }

      final fullMarks = _questions.length * 10;
      final totalTimeTaken = (_originalDurationSeconds - _remainingSeconds);

      final resultResponse = await ref.read(apiServiceProvider).post('/result', {
        'quiz_id': widget.quiz['id'].toString(),
        'user_id': userId.toString(),
        'attempt_id': widget.attemptId.toString(),
        'score': calculatedScore.toString(),
        'full_marks': fullMarks.toString(),
        'time_taken': totalTimeTaken.toString(),
      });

      if (resultResponse['success'] != true) {
        throw Exception(resultResponse['message'] ?? 'Failed to create result');
      }

      final resultId = resultResponse['id'];
      final linkedAttemptId = resultResponse['attempt_id'] ?? widget.attemptId;
      developer.log("âœ… Quiz completed! Result ID: $resultId, Score: $calculatedScore/$fullMarks");

      if (!mounted) return;

      // Mark attempt as completed
      await ref.read(apiServiceProvider).put('/quiz_attempt/${widget.attemptId}', {
        'status': 'completed',
        'completed_at': DateTime.now().toIso8601String(),
      });

      context.go('/quizzes/result', extra: {
        'result_id': resultId,
        'attempt_id': linkedAttemptId,
        'score': calculatedScore,
        'total_questions': _questions.length,
        'total_marks': fullMarks,
        'quiz_title': widget.quiz['quiz_title'] ?? widget.quiz['title'],
        'percentage': (calculatedScore / fullMarks * 100).toStringAsFixed(1),
        'time_taken': totalTimeTaken,
        'passed': calculatedScore >= (fullMarks * 0.6),
        'slug': widget.quiz['slug']?.toString().trim().isNotEmpty == true
            ? widget.quiz['slug']
            : widget.quiz['id'].toString(),   // fallback to quiz ID if no slug
      });
    } catch (e) {
      developer.log("âŒ Submit error: $e");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("Submit failed: $e")),
      );
      setState(() => _isSubmitting = false);
    }
  }

  void _showSubmitConfirmation() {
    final answeredCount = _selectedAnswers.where((answer) => answer != null).length;
    final unansweredCount = _questions.length - answeredCount;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text("Submit Quiz?", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Summary:", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            const SizedBox(height: 8),
            Text("âœ… Answered: $answeredCount", style: GoogleFonts.poppins()),
            Text(
              unansweredCount > 0
                  ? "âŒ Unanswered: $unansweredCount"
                  : "âœ… All questions answered!",
              style: GoogleFonts.poppins(
                color: unansweredCount > 0 ? Colors.orange : Colors.green,
              ),
            ),
            const SizedBox(height: 12),
            Text(
              "Are you sure you want to submit your answers?",
              style: GoogleFonts.poppins(),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text("Go Back", style: GoogleFonts.poppins(color: Colors.grey[700])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: _primaryColor,
              foregroundColor: Colors.white,
            ),
            onPressed: () {
              Navigator.pop(context);
              _submitQuiz();
            },
            child: Text("Submit Quiz", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          ),
        ],
      ),
    );
  }

  Future<bool> _onWillPop() async {
    await _updateAttemptProgress();
    final shouldQuit = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text("Leave Quiz?", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Your progress is saved.", style: GoogleFonts.poppins()),
            const SizedBox(height: 8),
            Text(
              "You can resume later from where you left off.",
              style: GoogleFonts.poppins(color: Colors.grey[600]),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text("Stay", style: GoogleFonts.poppins(color: Colors.grey[700])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: _primaryColor),
            onPressed: () => Navigator.pop(context, true),
            child: Text("Leave", style: GoogleFonts.poppins(color: Colors.white)),
          ),
        ],
      ),
    );
    if (shouldQuit == true && mounted) {
      context.go('/quizzes');
    }
    return shouldQuit ?? false;
  }

  String _formatTime(int seconds) {
    final mins = seconds ~/ 60;
    final secs = seconds % 60;
    return '${mins.toString().padLeft(2, '0')}:${secs.toString().padLeft(2, '0')}';
  }

  Widget _buildTopBar() {
    final totalTime = _originalDurationSeconds;
    return Column(
      children: [
        // Attempt info bar
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          margin: const EdgeInsets.only(bottom: 8),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.orange.shade100, Colors.orange.shade50],
            ),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(color: Colors.orange.withOpacity(0.3)),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.history, color: Colors.orange.shade700, size: 16),
              const SizedBox(width: 6),
              Text(
                'Attempt #${widget.attemptId}',
                style: GoogleFonts.poppins(
                  fontSize: 12,
                  fontWeight: FontWeight.w600,
                  color: Colors.orange.shade700,
                ),
              ),
              const SizedBox(width: 16),
              Icon(Icons.star, color: _primaryColor, size: 16),
              const SizedBox(width: 4),
              Text(
                '$_score pts',
                style: GoogleFonts.poppins(
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                  color: _primaryColor,
                ),
              ),
            ],
          ),
        ),
        LinearProgressIndicator(
          value: 1.0 - (_remainingSeconds / totalTime),
          backgroundColor: Colors.grey[300],
          color: _primaryColor,
          minHeight: 6,
        ),
        const SizedBox(height: 16),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Q ${_currentIndex + 1}/${_questions.length}',
              style: GoogleFonts.poppins(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: _remainingSeconds < 60 ? Colors.red : _primaryColor,
                borderRadius: BorderRadius.circular(20),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.timer, color: Colors.white, size: 18),
                  const SizedBox(width: 6),
                  Text(
                    _formatTime(_remainingSeconds),
                    style: GoogleFonts.poppins(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
            ),
            IconButton(
              icon: const Icon(Icons.grid_view_rounded),
              onPressed: _showQuestionPalette,
            ),
          ],
        ),
      ],
    );
  }

  /// âœ… UPDATED: Option buttons with perfect INT logic
  Widget _buildOptionButton(int index, String optionText, int correctAnswer) {
    final optionLetter = (index + 1).toString();
    final isSelected = _selectedAnswers[_currentIndex] == optionLetter;
    final selectedInt = int.tryParse(optionLetter) ?? -1;
    final isCorrect = selectedInt == correctAnswer;
    final isWrong = isSelected && selectedInt != correctAnswer && _isAnswered;

    Color getBackgroundColor() {
      if (_isAnswered) {
        if (isCorrect) return Colors.green.shade400;
        if (isWrong) return Colors.red.shade400;
        return Colors.grey[200]!;
      }
      return isSelected ? _primaryColor : Colors.grey[100]!;
    }

    Color getTextColor() {
      if (_isAnswered) {
        if (isCorrect || isWrong) return Colors.white;
        return Colors.black87;
      }
      return isSelected ? Colors.white : Colors.black87;
    }

    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      margin: const EdgeInsets.only(bottom: 12),
      child: Transform.scale(
        scale: isSelected ? 1.02 : 1.0,
        child: ElevatedButton(
          onPressed: _isLocked ? null : () => _selectAnswer(optionLetter),
          style: ElevatedButton.styleFrom(
            backgroundColor: getBackgroundColor(),
            foregroundColor: getTextColor(),
            elevation: isSelected ? 8 : (_isAnswered ? 4 : 2),
            padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 16),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          ),
          child: Row(
            children: [
              Container(
                width: 36,
                height: 36,
                decoration: BoxDecoration(
                  color: isSelected
                      ? Colors.white24
                      : (_isAnswered && isCorrect
                      ? Colors.green.shade600
                      : _primaryColor),
                  shape: BoxShape.circle,
                ),
                child: Center(
                  child: Text(
                    optionLetter,
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                      fontSize: isCorrect && _isAnswered ? 18 : 16,
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Text(
                  optionText,
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildNavigation() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          children: [
            if (_selectedAnswers[_currentIndex] != null && !_isLocked)
              ElevatedButton(
                onPressed: _resetCurrentAnswer,
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
                child: const Icon(Icons.refresh, size: 20),
              ),
            const SizedBox(width: 8),
            if (_currentIndex > 0 || !_isSequential)
              ElevatedButton.icon(
                onPressed: _goToPreviousQuestion,
                icon: const Icon(Icons.arrow_back),
                label: const Text("Previous"),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.grey[300],
                  foregroundColor: Colors.black87,
                  padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
              ),
          ],
        ),
        ElevatedButton.icon(
          onPressed: _currentIndex < _questions.length - 1
              ? _goToNextQuestion
              : _showSubmitConfirmation,
          icon: Icon(_currentIndex < _questions.length - 1
              ? Icons.arrow_forward
              : Icons.send),
          label: Text(
            _currentIndex < _questions.length - 1 ? "Next" : "Submit Quiz",
          ),
          style: ElevatedButton.styleFrom(
            backgroundColor: _primaryColor,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        ),
      ],
    );
  }

  Widget _buildQuestionPalette() {
    if (!_showPalette) return const SizedBox.shrink();

    return GestureDetector(
      onTap: () => setState(() => _showPalette = false),
      child: Container(
        color: Colors.black54,
        child: GestureDetector(
          onTap: () {}, // Prevent closing when tapping inside
          child: DraggableScrollableSheet(
            initialChildSize: 0.7,
            minChildSize: 0.5,
            maxChildSize: 0.9,
            builder: (context, scrollController) {
              return Container(
                decoration: const BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                ),
                child: SingleChildScrollView(
                  controller: scrollController,
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            'Question Palette',
                            style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.bold),
                          ),
                          ElevatedButton.icon(
                            onPressed: _showSubmitConfirmation,
                            icon: const Icon(Icons.send, size: 18),
                            label: Text('Submit Quiz', style: GoogleFonts.poppins(fontSize: 14)),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: _primaryColor,
                              foregroundColor: Colors.white,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          _buildStatusIndicator('Answered', Colors.blue),
                          _buildStatusIndicator('Not Answered', Colors.yellow[700]!),
                          _buildStatusIndicator('Not Visited', Colors.grey),
                          _buildStatusIndicator('Marked', Colors.purple),
                        ],
                      ),
                      const SizedBox(height: 20),
                      GridView.builder(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(),
                        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                          crossAxisCount: 5,
                          crossAxisSpacing: 8,
                          mainAxisSpacing: 8,
                          childAspectRatio: 1,
                        ),
                        itemCount: _questions.length,
                        itemBuilder: (context, index) {
                          return _buildPaletteNumber(index);
                        },
                      ),
                      const SizedBox(height: 20),
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          onPressed: () => setState(() => _showPalette = false),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: _primaryColor,
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(vertical: 16),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          ),
                          child: Text('Close Palette', style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
      ),
    );
  }

  Widget _buildPaletteNumber(int index) {
    Color getColor() {
      if (_markedQuestions[index]) return Colors.purple;
      if (_answeredQuestions[index]) return Colors.blue;
      if (_visitedQuestions[index]) return Colors.yellow[700]!;
      return Colors.grey;
    }

    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      child: GestureDetector(
        onTap: () => _jumpToQuestion(index),
        child: Container(
          decoration: BoxDecoration(
            color: getColor(),
            borderRadius: BorderRadius.circular(8),
            border: _currentIndex == index
                ? Border.all(color: Colors.black, width: 2)
                : null,
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.1),
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Center(
            child: Text(
              '${index + 1}',
              style: GoogleFonts.poppins(
                color: Colors.white,
                fontWeight: FontWeight.bold,
                fontSize: 16,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildStatusIndicator(String text, Color color) {
    return Expanded(
      child: Row(
        children: [
          Container(
            width: 16,
            height: 16,
            decoration: BoxDecoration(
              color: color,
              borderRadius: BorderRadius.circular(4),
            ),
          ),
          const SizedBox(width: 4),
          Text(
            text,
            style: GoogleFonts.poppins(fontSize: 12),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Scaffold(
        backgroundColor: const Color(0xFFF8FAFC),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              if (_isResuming)
                Column(
                  children: [
                    Lottie.asset('assets/lottie/loading.json', width: 80, height: 80),
                    const SizedBox(height: 16),
                    Text(
                      "Resuming your progress...",
                      style: GoogleFonts.poppins(fontSize: 16, color: _primaryColor),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      "Loading question ${_currentIndex + 1}...",
                      style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
                    ),
                  ],
                )
              else ...[
                Lottie.asset('assets/lottie/loading.json', width: 120, height: 120),
                const SizedBox(height: 20),
                Text(
                  "Loading Questions...",
                  style: GoogleFonts.poppins(fontSize: 18, color: _primaryColor),
                ),
              ],
            ],
          ),
        ),
      );
    }

    if (_questions.isEmpty) {
      return Scaffold(
        backgroundColor: const Color(0xFFF8FAFC),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.quiz_outlined, size: 100, color: Colors.grey[400]),
              const SizedBox(height: 20),
              Text(
                "No questions available for this quiz",
                style: GoogleFonts.poppins(fontSize: 18, color: Colors.grey[600]),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () => context.pop(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: _primaryColor,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
                child: Text(
                  "Back to Quizzes",
                  style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
                ),
              ),
            ],
          ),
        ),
      );
    }

    final question = _questions[_currentIndex];
    final correctAnswer = _getCorrectAnswer(question); // âœ… Always INT

    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        backgroundColor: const Color(0xFFF8FAFC),
        appBar: AppBar(
          backgroundColor: Colors.transparent,
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back, color: Colors.black87),
            onPressed: () => _onWillPop().then((shouldPop) {
              if (shouldPop) {
                // Navigation handled in _onWillPop
              }
            }),
          ),
          title: const SizedBox.shrink(),
          actions: [
            IconButton(
              icon: Icon(
                _markedQuestions[_currentIndex] ? Icons.bookmark : Icons.bookmark_border,
                color: _markedQuestions[_currentIndex] ? Colors.purple : Colors.grey,
              ),
              onPressed: _toggleMarkQuestion,
            ),
          ],
        ),
        body: GestureDetector(
          onHorizontalDragEnd: (details) {
            if (!_isLocked) {
              if (details.primaryVelocity! < 0 && _currentIndex < _questions.length - 1) {
                _goToNextQuestion();
              } else if (details.primaryVelocity! > 0 && _currentIndex > 0) {
                _goToPreviousQuestion();
              }
            }
          },
          child: Stack(
            children: [
              Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    _buildTopBar(),
                    const SizedBox(height: 30),
                    AnimatedSwitcher(
                      duration: const Duration(milliseconds: 400),
                      child: _isTransitioning
                          ? const SizedBox.shrink()
                          : SlideTransition(
                        key: ValueKey(_currentIndex),
                        position: _isTransitioning
                            ? _exitSlideAnimation
                            : _questionSlideAnimation,
                        child: FadeTransition(
                          opacity: _isTransitioning
                              ? ReverseAnimation(_exitController)
                              : _questionController,
                          child: Card(
                            elevation: 8,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                            child: Padding(
                              padding: const EdgeInsets.all(24),
                              child: Text(
                                question['question'] ?? "Question?",
                                style: GoogleFonts.poppins(
                                  fontSize: 20,
                                  fontWeight: FontWeight.w600,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(height: 30),
                    Expanded(
                      child: AnimatedSwitcher(
                        duration: const Duration(milliseconds: 300),
                        child: _isTransitioning
                            ? const SizedBox.shrink()
                            : FadeTransition(
                          key: ValueKey('options_$_currentIndex'),
                          opacity: _optionsFadeAnimation,
                          child: ListView(
                            padding: EdgeInsets.zero,
                            children: [
                              _buildOptionButton(0, question['option1'] ?? '', correctAnswer),
                              _buildOptionButton(1, question['option2'] ?? '', correctAnswer),
                              _buildOptionButton(2, question['option3'] ?? '', correctAnswer),
                              _buildOptionButton(3, question['option4'] ?? '', correctAnswer),
                            ],
                          ),
                        ),
                      ),
                    ),
                    if (!_isSubmitting) ...[
                      const SizedBox(height: 20),
                      _buildNavigation(),
                    ],
                  ],
                ),
              ),
              _buildQuestionPalette(),
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\widgets\profile_menu_tile.dart =====

// lib/widgets/profile_menu_tile.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class ProfileMenuTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final Widget? trailing;
  final VoidCallback onTap;

  const ProfileMenuTile({
    super.key,
    required this.icon,
    required this.title,
    this.trailing,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: Icon(icon, color: const Color(0xFF6C5CE7), size: 28),
      title: Text(
        title,
        style: GoogleFonts.poppins(
          fontSize: 16,
          fontWeight: FontWeight.w500,
        ),
      ),
      trailing: trailing ?? const Icon(Icons.chevron_right, color: Colors.grey),
      onTap: onTap,
      contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 4),
    );
  }
}




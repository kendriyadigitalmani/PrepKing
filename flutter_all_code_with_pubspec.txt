===== FILE: pubspec.yaml =====

name: prepking_online
description: A modern, animated learning app â€“ PrepKing
publish_to: "none"
version: 1.0.0+4

environment:
  sdk: ">=3.4.0 <4.0.0"
  flutter: ">=3.22.0"

dependencies:
  flutter:
    sdk: flutter

  # Core & State Management
  flutter_riverpod: ^2.6.1
  go_router: ^14.8.1

  # Networking
  dio: ^5.7.0
  retrofit: ^4.4.1
  json_annotation: ^4.9.0

  # UI & Animations
  lottie: ^3.1.2
  animate_do: ^3.3.9
  google_fonts: ^6.2.1
  flutter_svg: ^2.0.10+1
  cached_network_image: ^3.4.1
  shimmer: ^3.0.0
  confetti: ^0.8.0

  # Utils
  share_plus: ^12.0.1
  screenshot: ^3.0.0
  path_provider: ^2.1.4
  shared_preferences: ^2.3.2
  intl: ^0.20.2
  uuid: ^4.5.0
  vibration: ^3.1.4
  cupertino_icons: ^1.0.8

  # Firebase
  firebase_core: ^3.6.0
  firebase_auth: ^5.3.1
  google_sign_in: ^6.2.1

  # Content Viewers
  flutter_html: ^3.0.0-beta.1
  flutter_markdown: ^0.7.7+1
  youtube_player_flutter: ^9.1.3

  # Syncfusion PDF Viewer - Upgraded to latest (supports intl 0.20+)
  syncfusion_flutter_pdfviewer: ^31.2.18  # Or simply "^31.0.0" to get the absolute latest

  # URL Launcher
  url_launcher: ^6.3.1

  just_audio: ^0.9.39
  rxdart: ^0.27.7
  flutter_tts: ^4.0.2
  package_info_plus: ^8.0.2

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0

  # Code Generation
  build_runner: ^2.4.13
  retrofit_generator: ^10.2.0
  json_serializable: ^6.8.0

  freezed: ^3.2.3
  freezed_annotation: ^3.1.0

  # Icons & Splash
  flutter_native_splash: ^2.4.1
  flutter_launcher_icons: ^0.14.1

flutter:
  uses-material-design: true

  assets:
    - assets/images/
    - assets/lottie/
    - assets/lottie/trophy.json
    - assets/lottie/sad.json
    - assets/lottie/splash.json

# Native Splash Configuration
flutter_native_splash:
  color: "#6C5CE7"
  image: assets/images/logo.png  # Keep original for older Android (can be larger/full-screen)
  android: true
  ios: true
  android_12:
    image: assets/images/logo_splash.png  # â† Your new big artwork version
    color: "#6C5CE7"
  fullscreen: true
  # â† Removed deprecated "fill: true" (fullscreen: true already covers it)

# App Icons Configuration
flutter_launcher_icons:
  android: true
  ios: true
  image_path: "assets/images/logo.png"
  adaptive_icon_background: "#6C5CE7"
  adaptive_icon_foreground: "assets/images/logo.png"
  android_generate_legacy_files: true



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\main.dart =====

// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:flutter_native_splash/flutter_native_splash.dart'; // â† NEW IMPORT

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ SCREENS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import 'screens/home/home_screen.dart';
import 'screens/profile/profile_screen.dart';
import 'screens/quizzes/quizzes_screen.dart';
import 'screens/quizzes/daily_quizzes_screen.dart';
import 'screens/quizzes/quiz_detail_screen.dart';
import 'screens/quizzes/standard_quiz_player_screen.dart';
import 'screens/quizzes/instant_quiz_player_screen.dart';
import 'screens/quizzes/quiz_result_screen.dart';
import 'screens/quizzes/quiz_review_screen.dart';
import 'screens/splash_screen.dart';
import 'screens/onboarding_screen.dart';
import 'screens/login_screen.dart';
import 'screens/leaderboard/leaderboard_screen.dart';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ COURSES SCREENS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import 'screens/courses/course_list_screen.dart';
import 'screens/courses/course_detail_screen.dart';
import 'screens/courses/content_list_screen.dart';
import 'screens/courses/contents/pdf_content_screen.dart';
import 'screens/courses/contents/quiz_content_screen.dart';
import 'screens/courses/contents/text_content_screen.dart';
import 'screens/courses/contents/video_content_screen.dart';
import 'screens/courses/contents/audio_player_screen.dart';
import 'screens/courses/contents/text_audio_player_screen.dart'; // â† NEW IMPORT

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ PROFILE SUB-SCREENS (REAL IMPLEMENTATIONS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import 'screens/profile/edit_profile_screen.dart';
import 'screens/profile/certificates_screen.dart';
import 'screens/profile/quiz_history_screen.dart';
import 'screens/profile/coin_store_screen.dart';
import 'screens/profile/help_support_screen.dart';
import 'screens/profile/about_prepking_screen.dart';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ SETTINGS SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import 'screens/profile/settings_screen.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  // â† NEW: Preserve native splash until Flutter renders the first frame
  FlutterNativeSplash.preserve(widgetsBinding: WidgetsFlutterBinding.ensureInitialized());
  // Firebase initialization has been completely removed from here.
  // It is now handled asynchronously inside appInitProvider (triggered from SplashScreen)
  // This ensures the splash animation starts instantly with zero blocking.
  runApp(const ProviderScope(child: PrepKingApp()));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ ROUTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final routerProvider = Provider<GoRouter>((ref) {
  return GoRouter(
    initialLocation: '/splash',
    redirect: (_, __) => null,
    debugLogDiagnostics: false,
    routes: [
      GoRoute(path: '/splash', builder: (_, __) => const SplashScreen()),
      GoRoute(path: '/login', builder: (_, __) => const LoginScreen()),
      GoRoute(path: '/login/email', builder: (_, __) => const EmailLoginScreen()),
      GoRoute(path: '/onboarding', builder: (_, __) => const OnboardingScreen()),
      StatefulShellRoute.indexedStack(
        builder: (context, state, navigationShell) => MainScaffold(navigationShell: navigationShell),
        branches: [
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/home',
                builder: (_, __) => const HomeScreen(),
              ),
            ],
          ),
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/courses',
                builder: (_, __) => const CourseListScreen(),
                routes: [
                  GoRoute(
                    path: 'detail/:id',
                    builder: (context, state) {
                      final idStr = state.pathParameters['id']!;
                      final id = int.tryParse(idStr);
                      if (id == null) {
                        return Scaffold(
                            body: Center(child: Text('Invalid course ID: $idStr')));
                      }
                      return CourseDetailScreen(courseId: id);
                    },
                  ),
                  GoRoute(
                    path: 'content/text',
                    builder: (context, state) {
                      final extra = state.extra;
                      if (extra is! Map<String, dynamic>) {
                        return const Scaffold(
                            body: Center(child: Text('Invalid content data')));
                      }
                      return TextContentScreen(content: extra);
                    },
                  ),
                  GoRoute(
                    path: 'content/video',
                    builder: (context, state) {
                      final extra = state.extra;
                      if (extra is! Map<String, dynamic>) {
                        return const Scaffold(
                            body: Center(child: Text('Invalid content data')));
                      }
                      return VideoContentScreen(content: extra);
                    },
                  ),
                  GoRoute(
                    path: 'content/pdf',
                    builder: (context, state) {
                      final extra = state.extra;
                      if (extra is! Map<String, dynamic>) {
                        return const Scaffold(
                            body: Center(child: Text('Invalid content data')));
                      }
                      return PdfContentScreen(content: extra);
                    },
                  ),
                  GoRoute(
                    path: 'content/quiz',
                    builder: (context, state) {
                      final extra = state.extra;
                      if (extra is! Map<String, dynamic>) {
                        return const Scaffold(
                            body: Center(child: Text('Invalid content data')));
                      }
                      return QuizContentScreen(content: extra);
                    },
                  ),
                  GoRoute(
                    path: 'content/audio',
                    builder: (context, state) {
                      final extra = state.extra;
                      if (extra is! Map<String, dynamic>) {
                        return const Scaffold(
                            body: Center(child: Text('Invalid content data')));
                      }
                      return AudioPlayerScreen(content: extra);
                    },
                  ),
                  // â† NEW ROUTE FOR TEXT-TO-SPEECH PLAYER
                  GoRoute(
                    path: 'content/text-audio',
                    builder: (context, state) {
                      final extra = state.extra;
                      if (extra is! Map<String, dynamic>) {
                        return const Scaffold(
                            body: Center(child: Text('Invalid content data')));
                      }
                      return TextAudioPlayerScreen(
                        title: extra['title'] as String,
                        text: extra['text'] as String,
                      );
                    },
                  ),
                  GoRoute(
                    path: 'content/:courseId',
                    builder: (context, state) {
                      final idStr = state.pathParameters['courseId']!;
                      final courseId = int.tryParse(idStr);
                      if (courseId == null) {
                        return Scaffold(
                          body: Center(child: Text('Invalid course ID: "$idStr"')),
                        );
                      }
                      return ContentListScreen(courseId: courseId);
                    },
                  ),
                ],
              ),
            ],
          ),
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/quizzes',
                builder: (_, __) => const QuizzesScreen(),
                routes: [
                  GoRoute(
                    path: 'daily',
                    builder: (_, __) => const DailyQuizzesScreen(),
                  ),
                  GoRoute(
                      path: 'detail',
                      builder: (context, state) {
                        final extra = state.extra;
                        if (extra is! Map<String, dynamic>) {
                          return const Scaffold(
                              body: Center(child: Text('Invalid quiz data')));
                        }
                        return QuizDetailScreen(quiz: extra);
                      }),
                  GoRoute(path: 'instant-player', builder: (context, state) {
                    final extra = state.extra;
                    if (extra is! Map<String, dynamic>) {
                      return const Scaffold(body: Center(child: Text('Invalid data')));
                    }
                    return InstantQuizPlayerScreen(
                        quiz: extra['quiz'], attemptId: extra['attempt_id']);
                  }),
                  GoRoute(path: 'standard-player', builder: (context, state) {
                    final extra = state.extra;
                    if (extra is! Map<String, dynamic>) {
                      return const Scaffold(body: Center(child: Text('Invalid data')));
                    }
                    return StandardQuizPlayerScreen(
                        quiz: extra['quiz'], attemptId: extra['attempt_id']);
                  }),
                  GoRoute(
                      path: 'result',
                      builder: (context, state) {
                        final extra = state.extra;
                        if (extra is! Map<String, dynamic>) {
                          return const Scaffold(
                              body: Center(child: Text('Invalid result data')));
                        }
                        return QuizResultScreen(result: extra);
                      }),
                ],
              ),
            ],
          ),
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/leaderboard',
                builder: (_, __) => const LeaderboardScreen(),
              ),
            ],
          ),
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/profile',
                builder: (_, __) => const ProfileScreen(),
                routes: [
                  GoRoute(
                      path: 'certificates',
                      builder: (_, __) => const CertificatesScreen()),
                  GoRoute(
                      path: 'history', builder: (_, __) => const QuizHistoryScreen()),
                  GoRoute(
                      path: 'edit', builder: (_, __) => const EditProfileScreen()),
                  GoRoute(
                      path: 'settings',
                      builder: (_, __) => const SettingsScreen()),
                  GoRoute(path: 'coins', builder: (_, __) => const CoinStoreScreen()),
                  GoRoute(path: 'help', builder: (_, __) => const HelpSupportScreen()),
                  GoRoute(path: 'about', builder: (_, __) => const AboutPrepKingScreen()),
                ],
              ),
            ],
          ),
        ],
      ),
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€ Standalone routes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      GoRoute(
          path: '/q/:slug',
          builder: (context, state) => Scaffold(
              body: Center(
                  child: Text('Loading quiz: ${state.pathParameters['slug']}')))),
      GoRoute(path: '/quiz-review', builder: (context, state) {
        final extra = state.extra as Map<String, dynamic>?;
        final attemptId = extra?['attemptId'] ?? extra?['attempt_id'] ?? 0;
        final testName = extra?['testName'] ?? extra?['quiz_title'];
        if (attemptId <= 0) {
          return const Scaffold(
              body: Center(
                  child: Text('Invalid Attempt ID',
                      style: TextStyle(color: Colors.red))));
        }
        return QuizReviewScreen(attemptId: attemptId, testName: testName);
      }),
      GoRoute(path: '/certificate', builder: (context, state) {
        final extra = state.extra as Map<String, dynamic>?;
        final courseId = extra?['courseId'];
        return Scaffold(
          appBar: AppBar(
              title: const Text("Certificate"),
              backgroundColor: const Color(0xFF6C5CE7)),
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Lottie.asset('assets/lottie/certificate.json', width: 200),
                const SizedBox(height: 20),
                Text("Congratulations!",
                    style: GoogleFonts.poppins(
                        fontSize: 28, fontWeight: FontWeight.bold)),
                Text("Course ID: $courseId Completed!",
                    style: GoogleFonts.poppins(fontSize: 18)),
              ],
            ),
          ),
        );
      }),
    ],
  );
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ APP & SCAFFOLD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class PrepKingApp extends ConsumerWidget {
  const PrepKingApp({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp.router(
      title: 'PrepKing',
      debugShowCheckedModeBanner: false,
      routerConfig: ref.watch(routerProvider),
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xFF6C5CE7)),
        useMaterial3: true,
        fontFamily: GoogleFonts.poppins().fontFamily,
      ),
    );
  }
}

class MainScaffold extends ConsumerStatefulWidget {
  final StatefulNavigationShell navigationShell;
  const MainScaffold({super.key, required this.navigationShell});
  @override
  ConsumerState<MainScaffold> createState() => _MainScaffoldState();
}

class _MainScaffoldState extends ConsumerState<MainScaffold> {
  DateTime? _lastBackPressTime;

  Future<bool> _onWillPop() async {
    final now = DateTime.now();
    if (widget.navigationShell.currentIndex != 0) return true;
    if (_lastBackPressTime == null ||
        now.difference(_lastBackPressTime!) > const Duration(seconds: 2)) {
      _lastBackPressTime = now;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text('Press back again to exit'),
            backgroundColor: Color(0xFF6C5CE7)),
      );
      return false;
    }
    return true;
  }

  @override
  Widget build(BuildContext context) {
    final location = GoRouterState.of(context).uri.toString();

    // FIXED: Hide bottom bar on ALL content screens (audio, video, pdf, text, etc.)
    // Now correctly matches routes like /courses/content/audio, /courses/content/pdf, etc.
    final hideBottomBar = location.contains('/content/');

    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        body: widget.navigationShell,
        bottomNavigationBar: hideBottomBar
            ? null
            : BottomNavigationBar(
          currentIndex: widget.navigationShell.currentIndex,
          onTap: (i) {
            widget.navigationShell.goBranch(i);
          },
          type: BottomNavigationBarType.fixed,
          selectedItemColor: const Color(0xFF6C5CE7),
          unselectedItemColor: Colors.grey,
          items: const [
            BottomNavigationBarItem(icon: Icon(Icons.home_rounded), label: 'Home'),
            BottomNavigationBarItem(
                icon: Icon(Icons.menu_book_rounded), label: 'Courses'),
            BottomNavigationBarItem(icon: Icon(Icons.quiz_rounded), label: 'Quizzes'),
            BottomNavigationBarItem(
                icon: Icon(Icons.emoji_events_rounded), label: 'Leaderboard'),
            BottomNavigationBarItem(
                icon: Icon(Icons.person_rounded), label: 'Profile'),
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\constants\api_constants.dart =====

// lib/core/constants/api_constants.dart
class ApiConstants {
  static const String baseUrl = "https://quizard.in/api_002.php";

  // Endpoints
  static const String user = "/user";
  static const String userById = "/user/";
  static const String classEndpoint = "/class";
  static const String content = "/content";
  static const String course = "/course";
  static const String courseQuiz = "/course_quiz";
  static const String quizAttempt = "/quiz_attempt";
  static const String certificate = "/certificate";
  static const String result = "/result";
  static const String savedQuestion = "/saved_question";
  static const String savedQuiz = "/saved_quiz";
  static const String student = "/student";
  static const String userProgress = "/user_progress";
  static const String attemptReview = "/attempt_review";
  static const String firebaseSetting = "/firebase_setting";
  static const String questionPaper = "/question_paper";
  static const privacyUrl = "https://kendriyadigital.blogspot.com/2025/12/privacy-policy-for-prepking-online.html";
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\services\api_service.dart =====

import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../models/app_settings.dart';
import '../constants/api_constants.dart';
import '../utils/current_user_cache.dart';
import '../utils/user_preferences.dart';

// NEW: Custom exception with optional status code for better error handling
class ApiException implements Exception {
  final String message;
  final int? statusCode;
  ApiException(this.message, {this.statusCode});
  @override
  String toString() => statusCode != null
      ? 'ApiException($statusCode): $message'
      : 'ApiException: $message';
}

final apiServiceProvider = Provider((ref) => ApiService());

class ApiService {
  late final Dio _dio;

  // List of endpoints that should NOT receive the userid parameter
  final _skipUserIdPaths = [
    '/login',
    '/register',
    '/appsettings',
    '/firebase_setting',
    '/version',
    '/exam/all',
    '/language/all',
    '/class',
  ];

  ApiService() {
    _dio = Dio(BaseOptions(
      baseUrl: ApiConstants.baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      validateStatus: (status) => status != null && status >= 200 && status < 500,
    ));

    // SELECTIVE userid injection
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) async {
          int? userId;
          userId = CurrentUserCache.userId;
          if (userId == null) {
            userId = await UserPreferences().getUserId();
          }

          if (userId != null &&
              !_skipUserIdPaths.any((skipPath) => options.path.startsWith(skipPath))) {
            options.queryParameters ??= {};
            options.queryParameters['userid'] = userId.toString();
          }

          if (kDebugMode) {
            debugPrint('API URL â†’ ${options.uri}');
          }
          return handler.next(options);
        },
      ),
    );

    // Optional: Keep minimal logging (without sensitive bodies)
    if (kDebugMode) {
      _dio.interceptors.add(LogInterceptor(
        request: true,
        requestHeader: true,
        requestBody: false,
        responseBody: false,
        responseHeader: false,
        error: true,
        logPrint: (obj) => debugPrint("API â†’ $obj"),
      ));
    }
  }

  // ==================== App Settings ====================
  Future<Map<String, dynamic>> getAppSettingsRaw({required String packageId}) async {
    try {
      final response = await get('/appsettings', query: {'packageid': packageId});
      return response;
    } catch (e) {
      debugPrint('getAppSettingsRaw error: $e');
      rethrow;
    }
  }

  Future<AppSettings> getAppSettings({required String packageId}) async {
    try {
      final rawResponse = await getAppSettingsRaw(packageId: packageId);
      return AppSettings.fromJson(rawResponse);
    } catch (e) {
      debugPrint('getAppSettings error: $e');
      rethrow;
    }
  }

  // ==================== Generic HTTP Methods ====================
  Future<Map<String, dynamic>> get(String endpoint, {Map<String, dynamic>? query}) async {
    try {
      final response = await _dio.get(
        endpoint,
        queryParameters: query?..map((k, v) => MapEntry(k, v.toString())),
      );
      return _handleResponse(response);
    } catch (e) {
      debugPrint('GET Error [$endpoint]: $e');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> post(
      String endpoint,
      Map<String, dynamic> data, {
        Map<String, dynamic>? query,
      }) async {
    try {
      debugPrint('POST â†’ $endpoint');
      final response = await _dio.post(
        endpoint,
        queryParameters: query?..map((k, v) => MapEntry(k, v.toString())),
        data: data,
      );
      return _handleResponse(response);
    } catch (e) {
      debugPrint('POST Error [$endpoint]: $e');
      if (e is DioException) debugPrint('Response: ${e.response?.data}');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> put(
      String endpoint,
      Map<String, dynamic> data, {
        Map<String, dynamic>? query,
      }) async {
    try {
      final response = await _dio.put(
        endpoint,
        queryParameters: query?..map((k, v) => MapEntry(k, v.toString())),
        data: data,
      );
      return _handleResponse(response);
    } catch (e) {
      debugPrint('PUT Error [$endpoint]: $e');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> delete(
      String endpoint, {
        Map<String, dynamic>? query,
      }) async {
    try {
      final response = await _dio.delete(
        endpoint,
        queryParameters: query?..map((k, v) => MapEntry(k, v.toString())),
      );
      return _handleResponse(response);
    } catch (e) {
      debugPrint('DELETE Error [$endpoint]: $e');
      rethrow;
    }
  }

  // ==================== Content CRUD ====================
  Future<List<Map<String, dynamic>>> getAllContents() async {
    try {
      final response = await get('/content');
      final data = response['data'] as List<dynamic>? ?? [];
      return data.cast<Map<String, dynamic>>();
    } catch (e) {
      debugPrint('getAllContents error: $e');
      return [];
    }
  }

  Future<Map<String, dynamic>?> getContentById(int id) async {
    try {
      final response = await get('/content/$id');
      return response['data'] as Map<String, dynamic>?;
    } catch (e) {
      debugPrint('getContentById($id) error: $e');
      return null;
    }
  }

  Future<Map<String, dynamic>> createContent(Map<String, dynamic> data) async {
    return await post('/content', data);
  }

  Future<Map<String, dynamic>> updateContent(int id, Map<String, dynamic> data) async {
    return await put('/content/$id', data);
  }

  Future<bool> deleteContent(int id) async {
    try {
      await delete('/content/$id');
      return true;
    } catch (e) {
      debugPrint('deleteContent($id) failed: $e');
      return false;
    }
  }

  // ==================== Quiz Attempts ====================
  Future<List<Map<String, dynamic>>> getQuizAttempts({
    required int courseQuizId,
    required int userId,
  }) async {
    final response = await get('/quiz_attempt', query: {
      'course_quiz_id': courseQuizId.toString(),
      'user_id': userId.toString(),
    });
    return (response['data'] as List?)?.cast<Map<String, dynamic>>() ?? [];
  }

  Future<Map<String, dynamic>?> getLatestQuizAttempt({
    required int courseQuizId,
    required int userId,
  }) async {
    final attempts = await getQuizAttempts(courseQuizId: courseQuizId, userId: userId);
    if (attempts.isEmpty) return null;
    return attempts.reduce((a, b) => (a['id'] as int) > (b['id'] as int) ? a : b);
  }

  Future<List<Map<String, dynamic>>> getInProgressAttempts({
    required int courseQuizId,
    required int userId,
  }) async {
    final attempts = await getQuizAttempts(courseQuizId: courseQuizId, userId: userId);
    return attempts.where((a) => a['status'] == 'in_progress').toList();
  }

  Future<Map<String, dynamic>> updateQuizAttempt({
    required int attemptId,
    required String status,
    Map<String, dynamic>? additionalData,
  }) async {
    final payload = {'status': status, ...?additionalData};
    return await put('/quiz_attempt/$attemptId', payload);
  }

  // ==================== User Preferences Update ====================
  Future<Map<String, dynamic>> updateUserLanguage(int userId, int languageId) async {
    try {
      return await put('/user/$userId', {'language_id': languageId});
    } catch (e) {
      debugPrint('updateUserLanguage error: $e');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> updateUserExams(int userId, List<int> examIds) async {
    try {
      return await put('/user/$userId', {'exam_ids': examIds});
    } catch (e) {
      debugPrint('updateUserExams error: $e');
      rethrow;
    }
  }

  // ==================== Central Response Handler ====================
  Map<String, dynamic> _handleResponse(Response response) {
    final method = response.requestOptions.method;
    final path = response.requestOptions.path;
    final statusCode = response.statusCode;

    debugPrint('API SUCCESS: [$method] $path â†’ $statusCode');

    // === NEW: Print RAW response body exactly as received ===
    if (kDebugMode) {
      debugPrint('=== RAW RESPONSE START ===');
      final rawData = response.data;
      if (rawData is String) {
        debugPrint(rawData.isEmpty ? '(empty string)' : rawData);
      } else if (rawData is List<int>) {
        // For binary data (rare in JSON APIs)
        debugPrint('<binary data, length: ${rawData.length}>');
      } else {
        // Try to pretty-print if possible
        try {
          debugPrint(const JsonEncoder.withIndent('  ').convert(rawData));
        } catch (_) {
          debugPrint(rawData.toString());
        }
      }
      debugPrint('=== RAW RESPONSE END ===');
    }
    // ======================================================

    dynamic data = response.data;
    if (data is String) {
      try {
        data = jsonDecode(data);
      } catch (e) {
        debugPrint('JSON Parse failed: $e');
        throw ApiException('Invalid JSON response from server', statusCode: statusCode);
      }
    }

    if (data is! Map<String, dynamic>) {
      debugPrint('Invalid response format: $data');
      throw ApiException('Server returned invalid data format', statusCode: statusCode);
    }

    if (data['success'] == false) {
      final message = data['message'] ?? 'Unknown error occurred';
      if (message.toLowerCase().contains('not found') ||
          message.toLowerCase().contains('resource')) {
        return {'success': true, 'data': null};
      }
      throw ApiException(message, statusCode: statusCode);
    }

    if (data['data'] == null) {
      debugPrint('âš ï¸ API Warning: Success response missing "data" key â†’ $data');
    }

    return data;
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\app_version_validator.dart =====

// lib/core/utils/app_version_validator.dart
import 'package:package_info_plus/package_info_plus.dart';
import '../../models/app_settings.dart';

class AppVersionValidator {
  /// Determines if a forced update is required.
  ///
  /// Updated to use the new fields from the API response:
  /// - settings.version â†’ server app version (e.g., "1.0.1")
  /// - settings.buildNumber â†’ server build number (integer from root "build_number")
  /// - settings.isUpdateMandatory â†’ whether the update should be forced (from "is_update_mandatory")
  ///
  /// Logic:
  /// 1. Compare version strings first (semantic version comparison is not strict here).
  /// 2. If versions differ OR server build number is higher â†’ consider update needed.
  /// 3. Return true (force update) ONLY if isUpdateMandatory is true.
  ///
  /// This gives full control:
  /// - Set is_update_mandatory = 1 on server â†’ forces update dialog even for minor changes.
  /// - Set is_update_mandatory = 0 â†’ users can continue with older version.
  ///
  static Future<bool> isUpdateRequired(AppSettings settings) async {
    final packageInfo = await PackageInfo.fromPlatform();

    final String localVersion = packageInfo.version;
    final int localBuild = int.tryParse(packageInfo.buildNumber) ?? 0;

    final String serverVersion = settings.version;
    final int serverBuild = settings.buildNumber;
    final bool mandatory = settings.isUpdateMandatory;

    // If server version is different OR build number is higher â†’ update is available/needed
    final bool updateAvailable = (localVersion != serverVersion) || (serverBuild > localBuild);

    // Force the update dialog only if the server marks it as mandatory
    return updateAvailable && mandatory;
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\back_button_handler.dart =====

// lib/core/utils/back_button_handler.dart
import 'package:flutter/material.dart';

mixin BackButtonHandlerMixin<T extends StatefulWidget> on State<T> {
  bool _isHandlingBack = false;

  /// Override this method to handle back button press
  Future<bool> onWillPop() async {
    return true; // Default behavior - allow back
  }

  /// Wrap your scaffold with back button handling
  Widget buildWithBackHandler(Widget child) {
    return WillPopScope(
      onWillPop: () async {
        if (_isHandlingBack) return false;
        _isHandlingBack = true;

        final shouldPop = await onWillPop();

        if (mounted) {
          _isHandlingBack = false;
        }

        return shouldPop;
      },
      child: child,
    );
  }

  /// Show exit confirmation dialog
  Future<bool> showExitConfirmation() async {
    final shouldExit = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text("Exit PrepKing?", style: TextStyle(fontFamily: 'Poppins', fontWeight: FontWeight.bold)),
        content: Text("Are you sure you want to exit the app?", style: TextStyle(fontFamily: 'Poppins')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text("Stay", style: TextStyle(fontFamily: 'Poppins', color: Colors.grey[600])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFF6C5CE7)),
            onPressed: () => Navigator.pop(context, true),
            child: Text("Exit", style: TextStyle(fontFamily: 'Poppins', color: Colors.white)),
          ),
        ],
      ),
    );
    return shouldExit ?? false;
  }

  /// Show quit quiz confirmation dialog
  Future<bool> showQuitQuizConfirmation() async {
    final shouldQuit = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text("Quit Quiz?", style: TextStyle(fontFamily: 'Poppins', fontWeight: FontWeight.bold)),
        content: Text("Are you sure you want to quit without completing the quiz?", style: TextStyle(fontFamily: 'Poppins')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text("Cancel", style: TextStyle(fontFamily: 'Poppins', color: Colors.grey[600])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            onPressed: () => Navigator.pop(context, true),
            child: Text("Quit", style: TextStyle(fontFamily: 'Poppins', color: Colors.white)),
          ),
        ],
      ),
    );
    return shouldQuit ?? false;
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\current_user_cache.dart =====

/// Simple in-memory cache for current user ID.
/// Provides fast synchronous access for API interceptors during requests.
/// Cleared on logout to prevent data leaks.
class CurrentUserCache {
  static int? userId;

  /// Sets the current logged-in user ID
  static void setUserId(int id) {
    userId = id;
  }

  /// Clears the cached user ID (call this on logout)
  static void clear() {
    userId = null;
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\network_utils.dart =====

// lib/core/utils/network_utils.dart
import 'dart:async';
import 'dart:io';

class NetworkUtils {
  /// Checks if the device has real internet access by:
  /// 1. Attempting DNS lookup to google.com (reliable global endpoint)
  /// 2. Attempting DNS lookup to your actual API domain (quizard.in)
  /// Both with a 5-second timeout to prevent hanging
  static Future<bool> hasInternet() async {
    try {
      // Step 1: Check connectivity to a reliable public DNS (Google)
      final googleCheck = await InternetAddress.lookup('google.com')
          .timeout(const Duration(seconds: 5));

      if (googleCheck.isEmpty || googleCheck[0].rawAddress.isEmpty) {
        return false;
      }

      // Step 2: Check connectivity specifically to your backend domain
      // This catches cases where internet exists but your server is unreachable
      final apiCheck = await InternetAddress.lookup('quizard.in')
          .timeout(const Duration(seconds: 5));

      return apiCheck.isNotEmpty && apiCheck[0].rawAddress.isNotEmpty;
    } on SocketException {
      // No network connection at all
      return false;
    } on TimeoutException {
      // Took too long â†’ treat as no internet
      return false;
    } catch (_) {
      // Any other error (e.g. permission issues, DNS failure)
      return false;
    }
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\core\utils\user_preferences.dart =====

// lib/core/utils/user_preferences.dart
import 'package:shared_preferences/shared_preferences.dart';

/// A lightweight utility class for storing non-sensitive app preferences.
///
/// IMPORTANT BEST PRACTICE (for Google Play compliance & security):
/// - This class should ONLY store flags, settings, and non-personal data.
/// - NEVER store profile data like name, email, or user_id here for display.
///   Use providers (currentUserProvider / userWithProgressProvider) for all user profile data.
/// - Personal data in SharedPreferences is considered insecure and can cause Play Store rejections.
///
/// Current safe usage:
/// - seenOnboarding (flag)
/// - language_id
/// - exam_ids
/// - user_id (only the integer ID â€“ used for API userid injection, not for display)
class UserPreferences {
  // Keys â€“ keep them private
  static const _seen_onboarding = 'seenOnboarding';

  // NEW: Language and Exams keys
  static const _language_id = 'language_id';
  static const _exam_ids = 'exam_ids';

  // NEW: User ID key (minimal integer only â€“ used for API authentication flow)
  static const _user_id = 'user_id';

  /// Marks onboarding as seen â€“ safe flag
  Future<void> saveOnboardingSeen() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_seen_onboarding, true);
  }

  /// Checks if onboarding has been seen
  Future<bool> hasSeenOnboarding() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(_seen_onboarding) ?? false;
  }

  /// Clears ALL preferences.
  /// Called during full logout to ensure clean state.
  Future<void> clearAll() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.clear();
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€ SELECTIVE CLEAR FOR LOGOUT (NEW) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// Clears only authentication-related data on logout.
  /// This preserves user preferences like language and selected exams
  /// to avoid frustrating the user after they log in again.
  Future<void> clearAuthData() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_user_id);
    // Note: We intentionally do NOT clear language_id, exam_ids, or onboarding flag
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€ NEW: Language and Exams â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// Saves the selected language ID
  Future<void> saveLanguage(int languageId) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_language_id, languageId);
  }

  /// Retrieves the saved language ID (returns null if not set)
  Future<int?> getLanguage() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getInt(_language_id);
  }

  /// Saves the selected exam IDs (list of integers)
  Future<void> saveExams(List<int> examIds) async {
    final prefs = await SharedPreferences.getInstance();
    final stringList = examIds.map((id) => id.toString()).toList();
    await prefs.setStringList(_exam_ids, stringList);
  }

  /// Retrieves the saved exam IDs (returns empty list if none)
  Future<List<int>> getExams() async {
    final prefs = await SharedPreferences.getInstance();
    final stringList = prefs.getStringList(_exam_ids) ?? [];
    return stringList
        .map((str) => int.tryParse(str) ?? 0)
        .where((id) => id > 0)
        .toList();
  }

  /// NEW: Checks if both language and at least one exam are selected
  /// Used to guard Course/Quiz screens from loading when preferences are incomplete
  Future<bool> isPreferencesReady() async {
    final languageId = await getLanguage();
    final examIds = await getExams();
    return languageId != null && examIds.isNotEmpty;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€ NEW: User ID storage (for API userid injection) â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// Saves the logged-in user ID (used for automatically adding ?userid= to API calls)
  Future<void> saveUserId(int userId) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_user_id, userId);
  }

  /// Retrieves the saved user ID (returns null if not logged in)
  Future<int?> getUserId() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getInt(_user_id);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DEPRECATED METHODS (kept temporarily for backward compatibility)
  // These will be removed in future updates.
  // DO NOT USE THEM IN NEW CODE.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  @Deprecated('Use providers instead. This method stores personal data unsafely.')
  Future<void> saveUserData({
    required int userId,
    required String firebaseId,
    required String name,
    required String email,
    bool isFirstTime = false,
    bool isGuest = false,
  }) async {
    // No-op or minimal â€“ do NOT save personal data
    await saveOnboardingSeen();
  }

  @Deprecated('Guest mode should not rely on local storage for profile data.')
  Future<void> saveGuestData({required String firebaseId}) async {
    await saveOnboardingSeen();
  }

  @Deprecated('Do not read profile data from SharedPreferences. Use currentUserProvider.')
  Future<Map<String, dynamic>?> getUserData() async {
    // Return only safe flags â€“ never personal data
    return {
      'seenOnboarding': await hasSeenOnboarding(),
    };
  }

  @Deprecated('Use clearAll() instead.')
  Future<void> clear() async {
    await clearAll();
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\models\app_settings.dart =====

// lib/models/app_settings.dart
import 'dart:convert';

class AppSettings {
  final String version; // e.g., "1.0.0" from root "version"
  final int buildNumber; // e.g., 4 from root "build_number"
  final bool isUpdateMandatory; // true if "is_update_mandatory" == 1
  final String? apkUrl;               // NEW: direct APK download URL
  final String? appStoreUrl;          // NEW: App Store URL (for iOS)
  final Map<String, dynamic> appSettingsJson; // Full parsed "app_settings" object
  final Map<String, dynamic> firebaseSettings; // Full parsed "firebase_settings" object
  final List<Map<String, dynamic>> firebaseClients; // "firebase_clients" array

  AppSettings({
    required this.version,
    required this.buildNumber,
    required this.isUpdateMandatory,
    this.apkUrl,
    this.appStoreUrl,
    required this.appSettingsJson,
    required this.firebaseSettings,
    required this.firebaseClients,
  });

  factory AppSettings.fromJson(Map<String, dynamic> json) {
    // API response structure: {"success": true, "data": { ... }}
    final data = json['data'] as Map<String, dynamic>;

    // Safely decode fields that might be either String (JSON encoded) or already Map
    Map<String, dynamic> safeJsonDecode(dynamic value) {
      if (value == null) return {};
      if (value is Map<String, dynamic>) {
        return value; // Already decoded
      }
      if (value is String) {
        try {
          final decoded = jsonDecode(value);
          if (decoded is Map<String, dynamic>) {
            return decoded;
          }
        } catch (e) {
          // Invalid JSON string â†’ return empty map
        }
      }
      return {};
    }

    // Parse firebase_clients â€“ it's a List of Maps directly from the server
    List<Map<String, dynamic>> parseFirebaseClients(dynamic clients) {
      if (clients is List) {
        return clients
            .where((item) => item is Map<String, dynamic>)
            .cast<Map<String, dynamic>>()
            .toList();
      }
      return [];
    }

    return AppSettings(
      version: data['version'] as String? ?? '1.0.0',
      buildNumber: data['build_number'] as int? ?? 1,
      isUpdateMandatory: (data['is_update_mandatory'] as int? ?? 0) == 1,
      apkUrl: data['apk_url'] as String?,
      appStoreUrl: data['app_store_url'] as String?,
      appSettingsJson: safeJsonDecode(data['app_settings']),
      firebaseSettings: safeJsonDecode(data['firebase_settings']),
      firebaseClients: parseFirebaseClients(data['firebase_clients']),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\models\user_model.dart =====

// lib/models/user_model.dart

class UserModel {
  final int id;
  final String email;
  final String name;
  final String? mobile;
  final String? profilePicture;
  final int coins;
  final int streak;

  // Progress fields â€“ populated dynamically via userWithProgressProvider
  final Map<String, double> courseProgress; // courseId â†’ progress (0.0 to 1.0)
  final Set<String> completedContentIds;

  // User settings
  final bool notificationsEnabled;
  final String theme; // 'light' or 'dark'

  // Language and Exam preferences
  final int? languageId;
  final List<int> examIds;

  UserModel({
    required this.id,
    required this.email,
    required this.name,
    this.mobile,
    this.profilePicture,
    this.coins = 0,
    this.streak = 0,
    Map<String, double>? courseProgress,
    Set<String>? completedContentIds,
    this.notificationsEnabled = true,
    this.theme = 'light',
    this.languageId,
    List<int>? examIds,
  })  : courseProgress = courseProgress ?? {},
        completedContentIds = Set<String>.from(completedContentIds ?? {}),
        examIds = List<int>.unmodifiable(examIds ?? []);

  /// Factory constructor â€“ handles multiple API response formats safely
  factory UserModel.fromJson(Map<String, dynamic> json) {
    // Normalize input: handle {success: true, data: {...}}, direct map, or list
    Map<String, dynamic> data = {};

    if (json.containsKey('data') && json['data'] is Map<String, dynamic>) {
      data = json['data'];
    } else if (json.containsKey('id')) {
      // Direct response (e.g., after login or create)
      data = Map<String, dynamic>.from(json);
    } else if (json is List && json.isNotEmpty) {
      data = Map<String, dynamic>.from(json[0]);
    } else {
      throw Exception('Invalid user JSON: no valid data found');
    }

    if (data['id'] == null) {
      throw Exception('User JSON missing required "id" field');
    }

    // Safely parse basic fields
    final int id = int.parse(data['id'].toString());
    final String email = data['email']?.toString().trim() ?? '';
    final String name = data['name']?.toString().trim() ?? 'User';

    // Optional fields
    final String? mobile = data['mobile']?.toString().trim();
    final String? profilePicture = data['profile_picture']?.toString().trim();

    // Coins & streak
    final int coins = int.tryParse(data['coins']?.toString() ?? '0') ?? 0;
    final int streak = int.tryParse(data['streak']?.toString() ?? '0') ?? 0;

    // Notifications (support multiple possible field names)
    final bool notificationsEnabled = [
      data['isNotificationEnabled'],
      data['notifications_enabled'],
      data['notification_enabled'],
    ].any((v) => v == true || v == 1 || v?.toString().toLowerCase() == 'true');

    // Theme
    final String theme = (data['theme']?.toString().toLowerCase() == 'dark') ? 'dark' : 'light';

    // Language ID
    final int? languageId = data['language_id'] is int
        ? data['language_id']
        : int.tryParse(data['language_id']?.toString() ?? '');

    // Exam IDs â€“ support list or comma-separated string
    final List<int> examIds = [];
    final examRaw = data['exam_ids'];
    if (examRaw != null) {
      if (examRaw is List) {
        examIds.addAll(
          examRaw.map((e) => int.tryParse(e.toString()) ?? 0).where((id) => id > 0),
        );
      } else if (examRaw is String && examRaw.trim().isNotEmpty) {
        examIds.addAll(
          examRaw
              .split(',')
              .map((s) => int.tryParse(s.trim()) ?? 0)
              .where((id) => id > 0),
        );
      }
    }

    // Note: courseProgress and completedContentIds are NOT parsed here
    // because they are injected separately via userWithProgressProvider.copyWith()
    return UserModel(
      id: id,
      email: email,
      name: name,
      mobile: mobile,
      profilePicture: profilePicture,
      coins: coins,
      streak: streak,
      notificationsEnabled: notificationsEnabled,
      theme: theme,
      languageId: languageId,
      examIds: examIds,
    );
  }

  /// CopyWith â€“ essential for merging progress data
  UserModel copyWith({
    int? id,
    String? email,
    String? name,
    String? mobile,
    String? profilePicture,
    int? coins,
    int? streak,
    Map<String, double>? courseProgress,
    Set<String>? completedContentIds,
    bool? notificationsEnabled,
    String? theme,
    int? languageId,
    List<int>? examIds,
  }) {
    return UserModel(
      id: id ?? this.id,
      email: email ?? this.email,
      name: name ?? this.name,
      mobile: mobile ?? this.mobile,
      profilePicture: profilePicture ?? this.profilePicture,
      coins: coins ?? this.coins,
      streak: streak ?? this.streak,
      courseProgress: courseProgress ?? this.courseProgress,
      completedContentIds: completedContentIds ?? this.completedContentIds,
      notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
      theme: theme ?? this.theme,
      languageId: languageId ?? this.languageId,
      examIds: examIds ?? this.examIds,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
          other is UserModel &&
              runtimeType == other.runtimeType &&
              id == other.id &&
              email == other.email &&
              name == other.name;

  @override
  int get hashCode => Object.hash(id, email, name);
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\app_init_provider.dart =====

// lib/providers/app_init_provider.dart
import 'dart:developer' as developer;

import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../core/utils/app_version_validator.dart';
import '../core/utils/network_utils.dart';
import '../core/utils/user_preferences.dart';
import '../models/app_settings.dart';
import 'app_settings_provider.dart';
import 'user_provider.dart';

/// This provider completes ONLY when the app is fully ready to proceed.
/// It handles:
/// - Network check
/// - Parallel Firebase init + App Settings fetch
/// - Version validation (throws UPDATE_REQUIRED if needed)
/// - Local preferences loading
/// - User session fetch (if logged in)
final appInitProvider = FutureProvider<void>((ref) async {
  try {
    // 1ï¸âƒ£ CHECK NETWORK FIRST (critical for all subsequent operations)
    final hasInternet = await NetworkUtils.hasInternet();
    if (!hasInternet) {
      developer.log('No internet connection detected during app init');
      throw Exception('NO_NETWORK');
    }

    // 2ï¸âƒ£ START BOTH FIREBASE INITIALIZATION AND APP SETTINGS FETCH IN PARALLEL
    // FIXED: Guard against duplicate Firebase initialization
    final firebaseFuture = (Firebase.apps.isEmpty)
        ? Firebase.initializeApp().catchError((e) {
      developer.log('Firebase initialization failed: $e');
      throw Exception('Firebase init failed: $e');
    })
        : Future.value(Firebase.app());

    final appSettingsFuture = ref.read(appSettingsProvider.future).catchError((e) {
      developer.log('App settings fetch failed: $e');
      throw Exception('App settings fetch failed: $e');
    });

    // 3ï¸âƒ£ WAIT FOR BOTH TO COMPLETE IN PARALLEL
    final List<dynamic> results = await Future.wait([firebaseFuture, appSettingsFuture]);

    // results[0] = FirebaseApp (from firebaseFuture)
    // results[1] = AppSettings (from appSettingsFuture)
    final AppSettings settings = results[1] as AppSettings;

    // 4ï¸âƒ£ VERSION VALIDATION â€” If update required, throw specific exception
    final updateRequired = await AppVersionValidator.isUpdateRequired(settings);
    if (updateRequired) {
      developer.log('Update required detected');
      throw Exception('UPDATE_REQUIRED');
    }

    // 5ï¸âƒ£ LOAD LOCAL PREFERENCES (e.g., onboarding seen flag)
    final prefs = UserPreferences();
    await prefs.hasSeenOnboarding(); // Just ensure it's loaded

    // 6ï¸âƒ£ IF USER IS LOGGED IN, FETCH THEIR DETAILS FROM BACKEND
    final firebaseUser = FirebaseAuth.instance.currentUser;
    if (firebaseUser != null) {
      developer.log('User logged in, fetching profile data');
      try {
        await ref.read(currentUserProvider.future);
      } catch (e) {
        developer.log('User fetch failed during init: $e');
        // Critical recovery: if backend user is missing (401/404), sign out Firebase
        // This prevents getting stuck on splash with an invalid session
        if (e is Exception && e.toString().contains('401')) {
          developer.log('Backend user not found (401) â†’ signing out Firebase');
          await FirebaseAuth.instance.signOut();
        } else if (e is Exception && e.toString().contains('404')) {
          developer.log('Backend user not found (404) â†’ signing out Firebase');
          await FirebaseAuth.instance.signOut();
        }
        // Re-throw to show error dialog in splash (user can retry)
        rethrow;
      }
    }

    // All checks passed â†’ app is ready for navigation
    developer.log('App initialization completed successfully');
  } catch (e, stack) {
    developer.log('App init failed: $e\n$stack');
    rethrow; // Let the error bubble up to the splash screen listener
  }
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\app_settings_provider.dart =====

// lib/providers/app_settings_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:package_info_plus/package_info_plus.dart';
import '../core/services/api_service.dart';
import '../models/app_settings.dart';

/// Provides the app settings fetched from the server.
/// Dynamically uses the current app's package name (no hardcoding).
final appSettingsProvider = FutureProvider<AppSettings>((ref) async {
  // Get package info at runtime (works on Android & iOS)
  final packageInfo = await PackageInfo.fromPlatform();
  final String packageId = packageInfo.packageName;

  // Fetch app settings using the actual package ID
  final apiService = ref.read(apiServiceProvider);

  // Use the public method that returns the parsed AppSettings model
  return await apiService.getAppSettings(packageId: packageId);
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\certificate_provider.dart =====

// lib/providers/certificate_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

final certificatesProvider = FutureProvider.family<List<dynamic>, int>((ref, userId) async {
  final api = ref.read(apiServiceProvider);
  final res = await api.get('/certificate', query: {'user_id': userId.toString()});
  return res['data'] ?? [];
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\continue_learning_provider.dart =====

// lib/providers/continue_learning_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';
import 'package:flutter/foundation.dart'; // for debugPrint

final continueLearningProvider = FutureProvider.family<List<Map<String, dynamic>>, int>(
      (ref, userId) async {
    // Keep alive to avoid refetching when navigating back
    ref.keepAlive();

    final api = ref.read(apiServiceProvider);

    try {
      final response = await api.get(
        '/user_progress/$userId',
        query: {'type': 'course'},
      );

      if (response['success'] == true && response['data'] is List) {
        final rawList = (response['data'] as List).cast<Map<String, dynamic>>();

        return rawList.map((e) {
          // Extract nested course data if present (adjust field names as per your API)
          final courseData = e['courses'] as Map<String, dynamic>? ?? {};

          return {
            // Normalized consistent keys
            'course_id': e['course_quiz_id'], // â† Actual course ID (used for navigation)
            'title': courseData['title'] ?? e['title'] ?? 'Untitled Course',
            'course_image': courseData['thumbnail'] ?? courseData['course_image'] ?? '',
            'progress_percentage': double.tryParse(
              e['progress_percentage']?.toString() ?? '0',
            ) ??
                0.0,

            // Optional: keep original fields if needed elsewhere
            // 'progress_id': e['id'],
            // 'course_quiz_id': e['course_quiz_id'],
            // 'raw_courses': courseData,
          };
        }).where((item) {
          final progress = item['progress_percentage'] as double;
          return progress > 0 && progress < 100; // Only in-progress courses
        }).toList();
      } else {
        debugPrint('continueLearningProvider: API success=false or invalid data');
        return [];
      }
    } catch (e, stackTrace) {
      debugPrint('continueLearningProvider error for user $userId: $e');
      debugPrint('Stack trace: $stackTrace');
      return [];
    }
  },
);



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\course_progress_provider.dart =====

// lib/providers/course_progress_provider.dart
import 'package:flutter/foundation.dart'; // for debugPrint
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

/// Updated preciseCourseProgressProvider
/// Reliably detects enrollment based on whether 'data' array has entries
/// Returns a consistent map with:
///   'isEnrolled': bool            â†’ true if user has an active course attempt
///   'progress_percentage': double â†’ current progress (0.0 if not enrolled)
///   'completed': List<int>        â†’ list of completed content IDs
final preciseCourseProgressProvider = FutureProvider.family<Map<String, dynamic>, (int, int)>(
      (ref, params) async {
    final courseId = params.$1;
    final userId = params.$2;
    final api = ref.read(apiServiceProvider);

    try {
      final response = await api.get(
        '/course/$courseId/progress',
        query: {'userid': userId.toString()},
      );

      // Safely extract the data list
      final dataList = response['data'] as List? ?? [];
      final bool isEnrolled = dataList.isNotEmpty;

      if (!isEnrolled) {
        return {
          'isEnrolled': false,
          'progress_percentage': 0.0,
          'completed': <int>[],
        };
      }

      // When enrolled, extract from top-level 'progress' object
      final progress = response['progress'] as Map<String, dynamic>? ?? {};

      final double progressPercentage = double.tryParse(
        progress['progress_percentage']?.toString() ?? '0',
      ) ??
          0.0;

      final List<int> completed = (progress['completed'] as List?)
          ?.map((e) => int.tryParse(e.toString()) ?? 0)
          .where((id) => id > 0)
          .toList() ??
          <int>[];

      return {
        'isEnrolled': true,
        'progress_percentage': progressPercentage,
        'completed': completed,
      };
    } catch (e) {
      debugPrint('Error fetching precise progress for course $courseId, user $userId: $e');
      // On any error, assume not enrolled to avoid false positives
      return {
        'isEnrolled': false,
        'progress_percentage': 0.0,
        'completed': <int>[],
      };
    }
  },
);



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\course_providers.dart =====

// lib/providers/course_providers.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dio/dio.dart';
import 'dart:convert';

import '../core/services/api_service.dart';
import 'user_provider.dart'; // â† Make sure this is imported (for currentUserProvider)

/// Safe parsing helper for double values from API (handles String, int, double, null)
double _parseDouble(dynamic value) {
  if (value == null) return 0.0;
  if (value is double) return value;
  if (value is int) return value.toDouble();
  return double.tryParse(value.toString()) ?? 0.0;
}

/// Fetch the full list of courses (used by Course List Screen & Continue Learning)
/// Now properly extracts progress_percentage and completed_content_ids from backend
final courseListProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
  final api = ref.read(apiServiceProvider);
  try {
    debugPrint('Fetching course list via /course');
    final response = await api.get('/course');
    if (response['success'] != true) {
      throw Exception(response['message'] ?? 'Failed to load courses');
    }
    final rawData = response['data'] as List<dynamic>? ?? [];
    final List<Map<String, dynamic>> courses = [];
    for (final item in rawData) {
      final course = Map<String, dynamic>.from(item as Map);
      final progressMap = course['progress'] as Map<String, dynamic>? ?? {};
      // Extract and normalize progress fields from backend
      final double progressPercentage = _parseDouble(progressMap['progress_percentage']);
      final List<int> completedContentIds = (progressMap['completed'] as List<dynamic>?)
          ?.map((e) => int.tryParse(e.toString()) ?? 0)
          .where((id) => id > 0)
          .toList() ??
          [];
      // Attach normalized progress to course map for easy access everywhere
      courses.add({
        ...course,
        'progress_percentage': progressPercentage,
        'completed_content_ids': completedContentIds,
      });
    }
    debugPrint('Successfully loaded ${courses.length} course(s) with progress');
    return courses;
  } on DioException catch (e) {
    debugPrint('DioException in courseListProvider: ${e.message}');
    rethrow;
  } catch (e) {
    debugPrint('Error in courseListProvider: $e');
    rethrow;
  }
});

/// Fetch a single course detail by ID (used by CourseDetailScreen & ContentListScreen)
/// Now includes normalized progress fields + autoDispose for memory safety
/// â†’ Critical fix: Passes current userid in query params so backend returns correct progress
final courseDetailProvider = FutureProvider.family.autoDispose<Map<String, dynamic>, int>((ref, courseId) async {
  final userAsync = ref.watch(currentUserProvider);
  final userId = userAsync.value?.id;

  final api = ref.read(apiServiceProvider);
  try {
    debugPrint('Fetching course detail for ID: $courseId with userid: $userId');
    final response = await api.get(
      '/course/$courseId',
      query: userId != null ? {'userid': userId.toString()} : null,
    );

    if (response['success'] != true) {
      final message = response['message'] ?? 'Unknown error';
      throw Exception('Failed to load course: $message');
    }

    final data = Map<String, dynamic>.from(response['data'] ?? {});
    final progressMap = data['progress'] as Map<String, dynamic>? ?? {};

    final double progressPercentage = _parseDouble(progressMap['progress_percentage']);
    final List<int> completedContentIds = (progressMap['completed'] as List<dynamic>?)
        ?.map((e) => int.tryParse(e.toString()) ?? 0)
        .where((id) => id > 0)
        .toList() ??
        [];

    debugPrint('Course loaded: ${data['title'] ?? 'No title'} - Progress: $progressPercentage%');

    return {
      ...data,
      'progress_percentage': progressPercentage,
      'completed_content_ids': completedContentIds,
    };
  } on DioException catch (e) {
    final status = e.response?.statusCode;
    final raw = e.response?.data;
    final msg = e.message ?? 'Network error';
    debugPrint('DioException in courseDetailProvider: $status - $msg');
    throw Exception(
      'Network Error\nStatus: $status\nMessage: $msg\nResponse: ${raw is String ? raw : jsonEncode(raw)}',
    );
  } catch (e) {
    debugPrint('Unexpected error in courseDetailProvider: $e');
    rethrow;
  }
});

/// Fetch all contents (lessons) for a course
/// Now includes per-content progress_percentage and is_completed flag + autoDispose
final courseContentsProvider = FutureProvider.family.autoDispose<List<Map<String, dynamic>>, int>((ref, courseId) async {
  final api = ref.read(apiServiceProvider);
  try {
    debugPrint('Fetching contents for course ID: $courseId');
    final response = await api.get('/course/$courseId/contents');
    if (response['success'] != true) {
      debugPrint('Contents API failed: ${response['message']}');
      return [];
    }
    final rawData = response['data'] as List<dynamic>? ?? [];
    final List<Map<String, dynamic>> contents = [];
    for (final item in rawData) {
      final content = Map<String, dynamic>.from(item as Map);
      final progressMap = content['progress'] as Map<String, dynamic>? ?? {};
      final double contentProgress = _parseDouble(progressMap['progress_percentage']);
      final bool isCompleted = contentProgress >= 100.0;
      contents.add({
        ...content,
        'progress_percentage': contentProgress,
        'is_completed': isCompleted,
      });
    }
    debugPrint('Successfully loaded ${contents.length} content item(s) with progress');
    return contents;
  } on DioException catch (dioError) {
    final statusCode = dioError.response?.statusCode;
    final rawBody = dioError.response?.data;
    final errorMsg = dioError.message;
    debugPrint('DioException while fetching course contents: $statusCode - $errorMsg');
    throw Exception(
      'Failed to load lessons\n\nStatus: $statusCode\nError: $errorMsg\nResponse: ${rawBody is String ? rawBody : jsonEncode(rawBody)}',
    );
  } catch (e) {
    debugPrint('Unexpected error in courseContentsProvider: $e');
    rethrow;
  }
});

// Existing providers (kept intact)
final classesProvider = FutureProvider<List<dynamic>>((ref) async {
  final api = ref.read(apiServiceProvider);
  final res = await api.get('/class');
  return res['data'] ?? [];
});

final coursesProvider = FutureProvider.family<List<dynamic>, int>((ref, classId) async {
  final api = ref.read(apiServiceProvider);
  final res = await api.get('/course?class_id=$classId');
  return res['data'] ?? [];
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\exam_provider.dart =====

// lib/providers/exam_provider.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

/// Provides the list of all available exams from the server
/// Endpoint: GET /exam/all
/// Response: {"success": true, "data": [...], "count": 10}
final examsProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
  final api = ref.read(apiServiceProvider);
  try {
    final response = await api.get('/exam/all');
    final List<dynamic> rawList = response['data'] ?? [];
    return rawList.cast<Map<String, dynamic>>();
  } catch (e) {
    debugPrint('examsProvider error: $e');
    rethrow;
  }
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\firebase_init_provider.dart =====

// lib/providers/firebase_init_provider.dart
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final firebaseInitProvider = FutureProvider<FirebaseApp>((ref) async {
  return Firebase.initializeApp();
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\language_provider.dart =====

// lib/providers/language_provider.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

/// Provides the list of all available languages from the server
/// Endpoint: GET /language/all
/// Response: {"success": true, "data": [...], "count": 10}
final languagesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
  final api = ref.read(apiServiceProvider);
  try {
    final response = await api.get('/language/all');
    final List<dynamic> rawList = response['data'] ?? [];
    return rawList.cast<Map<String, dynamic>>();
  } catch (e) {
    debugPrint('languagesProvider error: $e');
    rethrow;
  }
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\quiz_attempts_provider.dart =====

// lib/providers/quiz_attempts_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';
import 'user_provider.dart';

/// ðŸ“‹ Provider for all quiz attempts
final quizAttemptsProvider = FutureProvider.family<List<Map<String, dynamic>>, int>((ref, quizId) async {
  // Watch user provider properly to handle loading states
  final userAsync = ref.watch(currentUserProvider);

  // Handle loading/error states gracefully
  if (!userAsync.hasValue || userAsync.value == null) {
    throw Exception('User not authenticated');
  }

  final user = userAsync.value!;
  final api = ref.read(apiServiceProvider);

  return api.getQuizAttempts(
    courseQuizId: quizId,
    userId: user.id,
  );
});

/// ðŸŽ¯ Provider for latest quiz attempt
final latestQuizAttemptProvider = FutureProvider.family<Map<String, dynamic>?, int>((ref, quizId) async {
  final userAsync = ref.watch(currentUserProvider);

  if (!userAsync.hasValue || userAsync.value == null) {
    throw Exception('User not authenticated');
  }

  final user = userAsync.value!;
  final api = ref.read(apiServiceProvider);

  return api.getLatestQuizAttempt(
    courseQuizId: quizId,
    userId: user.id,
  );
});

/// ðŸ”„ Provider for in-progress attempts (bonus)
final inProgressAttemptsProvider = FutureProvider.family<List<Map<String, dynamic>>, int>((ref, quizId) async {
  final userAsync = ref.watch(currentUserProvider);

  if (!userAsync.hasValue || userAsync.value == null) {
    throw Exception('User not authenticated');
  }

  final user = userAsync.value!;
  final api = ref.read(apiServiceProvider);

  return api.getInProgressAttempts(
    courseQuizId: quizId,
    userId: user.id,
  );
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\quiz_history_provider.dart =====

// lib/providers/quiz_history_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';

final quizHistoryProvider = FutureProvider.family<List<Map<String, dynamic>>, int>((ref, userId) async {
  final api = ref.read(apiServiceProvider);

  try {
    final res = await api.get('/quiz_attempt', query: {'user_id': userId.toString()});
    final List<dynamic> rawAttempts = res['data'] ?? [];

    final List<Map<String, dynamic>> history = [];

    // Batch fetch quiz titles to reduce API calls
    final Set<int> quizIds = rawAttempts
        .map((a) => a['course_quiz_id'])
        .whereType<int>()
        .toSet();

    // Map of quiz_id -> title
    final Map<int, String> quizTitles = {};

    if (quizIds.isNotEmpty) {
      for (final id in quizIds) {
        try {
          final quizRes = await api.get('/course_quiz/$id');
          final data = quizRes['data'];
          if (data != null && data is Map) {
            quizTitles[id] = data['title']?.toString() ?? 'Untitled Quiz';
          }
        } catch (e) {
          quizTitles[id] = 'Untitled Quiz';
        }
      }
    }

    for (var attempt in rawAttempts) {
      final map = Map<String, dynamic>.from(attempt);
      final quizId = map['course_quiz_id'] as int?;

      map['quiz_title'] = quizId != null
          ? (quizTitles[quizId] ?? 'Untitled Quiz')
          : (map['type'] == 'course' ? 'Course Quiz' : 'Practice Quiz');

      // Additional helpful fields
      map['display_score'] = map['status'] == 'completed'
          ? '${map['obtained_marks'] ?? '0'} / ${map['total_marks'] ?? '?'}'
          : 'In Progress';

      map['display_date'] = map['completed_at']?.toString().split(' ').first
          ?? map['started_at']?.toString().split(' ').first
          ?? 'Unknown Date';

      history.add(map);
    }

    // Sort by most recent first
    history.sort((a, b) {
      final dateA = a['completed_at'] ?? a['started_at'] ?? '';
      final dateB = b['completed_at'] ?? b['started_at'] ?? '';
      return dateB.compareTo(dateA);
    });

    return history;
  } catch (e) {
    throw Exception('Failed to load quiz history');
  }
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\user_progress_merged_provider.dart =====

// lib/providers/user_progress_merged_provider.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/services/api_service.dart';
import '../models/user_model.dart';
import 'user_provider.dart'; // assuming currentUserProvider is here

/// â”€â”€ Provider to fetch ALL course progress for a user (including per-content details) â”€â”€
final allUserCourseProgressProvider = FutureProvider.family<List<Map<String, dynamic>>, int>(
      (ref, userId) async {
    // Prevent unnecessary refetching when navigating back
    ref.keepAlive();

    final api = ref.read(apiServiceProvider);
    try {
      // This calls GET /course/progress?userid=X â†’ returns all enrolled courses with content_progress
      final response = await api.get(
        '/course/progress',
        query: {'userid': userId.toString()},
      );

      if (response['success'] == true && response['data'] is List) {
        return List<Map<String, dynamic>>.from(response['data']);
      }

      debugPrint('allUserCourseProgressProvider: API success=false or no data for user $userId');
      return [];
    } catch (e, stackTrace) {
      debugPrint('Error fetching all course progress for user $userId: $e');
      debugPrint('Stack trace: $stackTrace');
      return [];
    }
  },
);

/// â”€â”€ FINAL MERGED PROVIDER: Current logged-in user + full progress data â”€â”€
final userWithProgressProvider = FutureProvider<UserModel?>((ref) async {
  // Keep provider alive to avoid refetching on every navigation
  ref.keepAlive();

  // Watch the base user (from auth + /user endpoint)
  final userAsync = ref.watch(currentUserProvider);

  // Handle loading/error states gracefully
  if (userAsync is AsyncLoading) return null;
  if (userAsync is AsyncError) {
    debugPrint('userWithProgressProvider: currentUser error - ${userAsync.error}');
    return null;
  }

  final user = userAsync.value;
  if (user == null) {
    debugPrint('userWithProgressProvider: No logged-in user');
    return null;
  }

  final userId = user.id;

  // Fetch all course progress (including detailed content_progress)
  final progressList = await ref.watch(allUserCourseProgressProvider(userId).future);

  final Map<String, double> courseProgress = {};
  final Set<String> completedContentIds = {};

  for (final courseAttempt in progressList) {
    // Prefer course_quiz_id, but fallback to 'id' if missing (defensive)
    final courseIdRaw = courseAttempt['course_quiz_id'] ?? courseAttempt['id'];
    final courseId = courseIdRaw?.toString();
    if (courseId == null) continue;

    // 1. Course-level progress percentage (normalized to 0.0 â€“ 1.0)
    final rawPercentage = double.tryParse(
      courseAttempt['progress_percentage']?.toString() ?? '0',
    ) ??
        0.0;
    courseProgress[courseId] = (rawPercentage / 100.0).clamp(0.0, 1.0);

    // 2. Primary source: detailed content_progress records
    final contentProgressList = courseAttempt['content_progress'] as List<dynamic>? ?? [];
    for (final cp in contentProgressList) {
      final status = cp['status']?.toString().toLowerCase();
      final contentId = cp['content_id']?.toString();
      if (status == 'completed' && contentId != null) {
        completedContentIds.add(contentId);
      }
    }

    // 3. Critical fallback: progress_data.completed array (always present and up-to-date in backend)
    final progressData = courseAttempt['progress_data'];
    if (progressData is Map<String, dynamic>) {
      final completedList = progressData['completed'];
      if (completedList is List) {
        for (final id in completedList) {
          if (id != null) {
            completedContentIds.add(id.toString());
          }
        }
      }
    }
  }

  // Return updated user model with progress injected
  return user.copyWith(
    courseProgress: courseProgress,
    completedContentIds: completedContentIds,
  );
});



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\providers\user_provider.dart =====

// lib/providers/user_provider.dart
import 'package:dio/dio.dart'; // â† Required for DioException
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../core/services/api_service.dart';
import '../models/user_model.dart';
import '../core/utils/user_preferences.dart';
import '../core/utils/current_user_cache.dart';

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ API PROVIDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final apiProvider = Provider<ApiService>((ref) {
  return ref.read(apiServiceProvider);
});

/// ðŸ” Real-time Firebase auth state stream (kept for any UI that needs it)
final authStateProvider = StreamProvider<User?>((ref) {
  return FirebaseAuth.instance.authStateChanges();
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ CURRENT USER (REAL DATA FROM /user?firebaseid={uid}) â”€â”€â”€â”€â”€â”€â”€
final currentUserProvider = FutureProvider<UserModel?>((ref) async {
  final firebaseUser = FirebaseAuth.instance.currentUser;
  if (firebaseUser == null) {
    debugPrint("No Firebase user logged in");
    return null;
  }

  final api = ref.read(apiProvider);

  try {
    // Fetch user profile from backend using firebaseid
    final response = await api.get(
      '/user',
      query: {'firebaseid': firebaseUser.uid},
    );

    debugPrint("User API Response: $response");

    final data = response['data'];
    if (data is Map<String, dynamic> && data.isNotEmpty) {
      final user = UserModel.fromJson(data);

      // ðŸ”¥ Cache user ID for automatic API userid injection
      CurrentUserCache.setUserId(user.id);
      await UserPreferences().saveUserId(user.id);

      // Sync language & exam preferences to local storage (backup & fast access)
      final prefs = UserPreferences();
      if (user.languageId != null) {
        await prefs.saveLanguage(user.languageId!);
      }
      if (user.examIds.isNotEmpty) {
        await prefs.saveExams(user.examIds);
      }

      return user;
    }

    debugPrint("No user data found for uid: ${firebaseUser.uid}");
    return null;
  } on ApiException catch (apiEx) {
    debugPrint("API Error fetching user: ${apiEx.message}");

    // ðŸ”¥ CRITICAL FIX (Issue 3): Detect 401/404 when backend user is missing
    // ApiException is thrown from _handleResponse in ApiService when success == false
    // The original DioException (if any) is lost, so we rely on message content
    final lowerMessage = apiEx.message.toLowerCase();

    if (lowerMessage.contains('401') ||
        lowerMessage.contains('unauthorized') ||
        lowerMessage.contains('403') ||
        lowerMessage.contains('forbidden') ||
        lowerMessage.contains('404') ||
        lowerMessage.contains('not found') ||
        lowerMessage.contains('resource')) {
      debugPrint("Backend user not found or unauthorized â†’ signing out Firebase");
      await FirebaseAuth.instance.signOut();
      CurrentUserCache.clear();
      await UserPreferences().clearAuthData();
      return null; // Treat as logged out
    }

    // For other API errors, re-throw so splash screen can show retry dialog
    rethrow;
  } catch (e, stack) {
    debugPrint("Unexpected error fetching user: $e\n$stack");
    rethrow;
  }
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONTINUE COURSE PROGRESS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class UserProgressModel {
  final String courseTitle;
  final double progressPercentage;
  final String? courseImage;

  const UserProgressModel({
    required this.courseTitle,
    required this.progressPercentage,
    this.courseImage,
  });
}

final continueCourseProvider = FutureProvider<UserProgressModel?>((ref) async {
  final api = ref.read(apiProvider);
  try {
    final response = await api.get('/user_progress');
    final data = response['data'];
    if (data != null && data is List && data.isNotEmpty) {
      final item = data[0] as Map<String, dynamic>;
      return UserProgressModel(
        courseTitle: item['course_title']?.toString() ?? "Continue Learning",
        progressPercentage: double.tryParse(item['progress']?.toString() ?? "0") ?? 0.0,
        courseImage: item['course_image'] as String?,
      );
    }
  } on ApiException catch (e) {
    debugPrint("API Error in continueCourseProvider: ${e.message}");
    // Graceful fallback â€“ do not rethrow
  } catch (e) {
    debugPrint("Continue course error: $e");
  }

  // Consistent fallback for stable UI
  return const UserProgressModel(
    courseTitle: "Algebra Mastery 101",
    progressPercentage: 68.5,
  );
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ DAILY CHALLENGE QUIZ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class DailyQuizModel {
  final int id;
  final String title;
  final int questionCount;
  final String? thumbnail;

  const DailyQuizModel({
    required this.id,
    required this.title,
    required this.questionCount,
    this.thumbnail,
  });
}

final dailyChallengeProvider = FutureProvider<DailyQuizModel?>((ref) async {
  final api = ref.read(apiProvider);
  try {
    final response = await api.get('/course_quiz', query: {'type': 'daily'});
    final data = response['data'];
    if (data != null && data is List && data.isNotEmpty) {
      final quiz = data[0] as Map<String, dynamic>;
      return DailyQuizModel(
        id: int.tryParse(quiz['id'].toString()) ?? 0,
        title: quiz['title']?.toString() ?? "Today's Challenge",
        questionCount: int.tryParse(quiz['total_questions']?.toString() ?? "5") ?? 5,
        thumbnail: quiz['thumbnail'] as String?,
      );
    }
  } on ApiException catch (e) {
    debugPrint("API Error in dailyChallengeProvider: ${e.message}");
    // Graceful fallback â€“ do not rethrow
  } catch (e) {
    debugPrint("Daily quiz fetch error: $e");
  }

  // Consistent fallback
  return const DailyQuizModel(
    id: 999,
    title: "Daily Challenge",
    questionCount: 10,
  );
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€ ONE-TAP REFRESH ALL USER DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final refreshUserDataProvider = Provider<void Function()>((ref) {
  return () {
    ref.invalidate(currentUserProvider);
    ref.invalidate(continueCourseProvider);
    ref.invalidate(dailyChallengeProvider);
  };
});

/// ðŸ”¥ LOGOUT HELPER (PRESERVES USER PREFERENCES)
///
/// Call this function wherever logout is triggered (e.g., ProfileScreen, Settings).
/// It signs out from Firebase, clears only authentication data,
/// and preserves language/exam selections for better UX.
Future<void> performLogout(WidgetRef ref) async {
  await FirebaseAuth.instance.signOut();

  // Clear in-memory and persistent user ID (used for API userid injection)
  CurrentUserCache.clear();
  await UserPreferences().clearAuthData(); // â† Only removes user_id, keeps language/exams

  // Invalidate providers so fresh data is fetched on next login
  ref.invalidate(currentUserProvider);
  ref.invalidate(continueCourseProvider);
  ref.invalidate(dailyChallengeProvider);

  debugPrint("Logout completed: Auth cleared, preferences preserved");
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\dots_loader.dart =====

import 'package:flutter/material.dart';

class _DotsLoader extends StatefulWidget {
  const _DotsLoader();
  @override
  State<_DotsLoader> createState() => _DotsLoaderState();
}

class _DotsLoaderState extends State<_DotsLoader> with TickerProviderStateMixin {
  late final List<AnimationController> _controllers;

  @override
  void initState() {
    super.initState();
    _controllers = List.generate(3, (_) {
      return AnimationController(vsync: this, duration: const Duration(milliseconds: 600))
        ..repeat(reverse: true);
    });
    for (int i = 0; i < _controllers.length; i++) {
      Future.delayed(Duration(milliseconds: i * 150), () {
        if (mounted) _controllers[i].forward();
      });
    }
  }

  @override
  void dispose() {
    for (final c in _controllers) c.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: List.generate(3, (i) {
        return ScaleTransition(
          scale: Tween<double>(begin: 0.4, end: 1.4).animate(
            CurvedAnimation(parent: _controllers[i], curve: Curves.easeInOut),
          ),
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 6),
            width: 12,
            height: 12,
            decoration: const BoxDecoration(
              color: Colors.white,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(color: Colors.white30, blurRadius: 8, spreadRadius: 2),
              ],
            ),
          ),
        );
      }),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\login_screen.dart =====

// lib/screens/login_screen.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:animate_do/animate_do.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:url_launcher/url_launcher.dart';
import '../core/constants/api_constants.dart';
import '../core/utils/user_preferences.dart';
import '../core/services/api_service.dart';
import '../providers/user_provider.dart'; // â† For refreshUserDataProvider
import 'package:flutter_riverpod/flutter_riverpod.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  bool _isSigningIn = false;

  Future<void> _googleSignIn() async {
    if (_isSigningIn) return;
    setState(() => _isSigningIn = true);

    try {
      final googleUser = await GoogleSignIn().signIn();
      if (googleUser == null) {
        setState(() => _isSigningIn = false);
        return;
      }

      final googleAuth = await googleUser.authentication;
      final idToken = googleAuth.idToken;

      if (idToken == null) {
        debugPrint('ID token is null');
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Sign-in failed: Missing ID token')),
        );
        return;
      }

      final credential = GoogleAuthProvider.credential(idToken: idToken);
      final userCredential = await FirebaseAuth.instance.signInWithCredential(credential);

      await handlePostAuthentication(context, ref, userCredential);
    } catch (e) {
      debugPrint('Google Sign-In Error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Sign-in failed: $e')),
      );
    } finally {
      if (mounted) setState(() => _isSigningIn = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF6C5CE7),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 40),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElasticIn(
                child: Text(
                  'Welcome to PrepKing',
                  style: GoogleFonts.poppins(
                    fontSize: 34,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
              ),
              const SizedBox(height: 60),
              ElevatedButton.icon(
                onPressed: _isSigningIn ? null : _googleSignIn,
                icon: _isSigningIn
                    ? const SizedBox(
                  width: 34,
                  height: 34,
                  child: CircularProgressIndicator(color: Colors.red, strokeWidth: 2),
                )
                    : const Icon(Icons.g_mobiledata, size: 34, color: Colors.red),
                label: Text(
                  _isSigningIn ? 'Signing In...' : 'Continue with Google',
                  style: GoogleFonts.poppins(fontSize: 18),
                ),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 18),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
                ),
              ),
              const SizedBox(height: 40),
              Text('or', style: GoogleFonts.poppins(color: Colors.white, fontSize: 16)),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () => context.push('/login/email'),
                child: Text(
                  'Login with Email',
                  style: GoogleFonts.poppins(fontSize: 18, color: Colors.white, fontWeight: FontWeight.w600),
                ),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF8E44AD),
                  padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 18),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(30),
                    side: const BorderSide(color: Colors.white, width: 1.5),
                  ),
                ),
              ),
              const SizedBox(height: 40),
              Text(
                'By continuing, you agree to our',
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(color: Colors.white70, fontSize: 14),
              ),
              const SizedBox(height: 8),
              GestureDetector(
                onTap: () async {
                  if (await canLaunchUrl(Uri.parse(ApiConstants.privacyUrl))) {
                    await launchUrl(Uri.parse(ApiConstants.privacyUrl), mode: LaunchMode.externalApplication);
                  }
                },
                child: Text(
                  'Privacy Policy',
                  style: GoogleFonts.poppins(
                    color: Colors.white,
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                    decoration: TextDecoration.underline,
                  ),
                ),
              ),
              const SizedBox(height: 20),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: Text(
                  'Sign in to access your account and save your progress across devices.',
                  textAlign: TextAlign.center,
                  style: GoogleFonts.poppins(color: Colors.white70, fontSize: 14),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// â”€â”€ SHARED POST-AUTHENTICATION LOGIC â”€â”€
Future<void> handlePostAuthentication(
    BuildContext context,
    WidgetRef ref,
    UserCredential userCredential,
    ) async {
  final firebaseId = userCredential.user?.uid;
  if (firebaseId == null) {
    throw Exception('Firebase UID is missing after sign-in');
  }

  final apiService = ref.read(apiServiceProvider);
  final prefs = UserPreferences();

  // First: Try to fetch existing user
  final getResponse = await apiService.get('/user', query: {'firebaseid': firebaseId});

  Map<String, dynamic>? userData = getResponse['data'] as Map<String, dynamic>?;

  if (userData != null) {
    // Existing user â†’ use fetched data
    await prefs.saveUserData(
      userId: userData['id'] as int,
      firebaseId: firebaseId,
      name: userData['name'] as String,
      email: userData['email'] as String,
      isFirstTime: false,
      isGuest: false,
    );
  } else {
    // New user â†’ create in backend
    final createPayload = {
      'firebase_id': firebaseId,
      'name': userCredential.user?.displayName ?? 'PrepKing User',
      'email': userCredential.user?.email ?? '',
      'profile_picture': userCredential.user?.photoURL,
      'role': 'student',
    };

    await apiService.post('/user', createPayload);

    // CRITICAL FIX: After creation, fetch full user data again
    // Because POST /user only returns {success: true, id: ...} without full 'data'
    final fetchAfterCreate = await apiService.get('/user', query: {'firebaseid': firebaseId});
    userData = fetchAfterCreate['data'] as Map<String, dynamic>?;

    if (userData == null) {
      throw Exception('Failed to retrieve user data after creation');
    }

    await prefs.saveUserData(
      userId: userData['id'] as int,
      firebaseId: firebaseId,
      name: userData['name'] as String,
      email: userData['email'] as String,
      isFirstTime: true,
      isGuest: false,
    );
  }

  // Invalidate and refresh all user-related providers
  ref.read(refreshUserDataProvider)();

  if (context.mounted) {
    context.go('/home');
  }
}

// â”€â”€ EMAIL LOGIN SCREEN â”€â”€
class EmailLoginScreen extends ConsumerStatefulWidget {
  const EmailLoginScreen({super.key});

  @override
  ConsumerState<EmailLoginScreen> createState() => _EmailLoginScreenState();
}

class _EmailLoginScreenState extends ConsumerState<EmailLoginScreen> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;
  final _formKey = GlobalKey<FormState>();

  Future<void> _signInWithEmail() async {
    if (!_formKey.currentState!.validate()) return;
    setState(() => _isLoading = true);

    try {
      final credential = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );
      await handlePostAuthentication(context, ref, credential);
    } on FirebaseAuthException catch (e) {
      String message;
      switch (e.code) {
        case 'user-not-found':
          message = 'No user found for that email.';
          break;
        case 'wrong-password':
          message = 'Wrong password provided.';
          break;
        case 'invalid-email':
          message = 'Invalid email address.';
          break;
        case 'user-disabled':
          message = 'This account has been disabled.';
          break;
        default:
          message = 'Login failed: ${e.message ?? 'Unknown error'}';
      }
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(message)));
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: $e')));
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF6C5CE7),
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => context.pop(),
        ),
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 40),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                Text(
                  'Login with Email',
                  style: GoogleFonts.poppins(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
                const SizedBox(height: 60),
                TextFormField(
                  controller: _emailController,
                  keyboardType: TextInputType.emailAddress,
                  style: const TextStyle(color: Colors.white),
                  decoration: InputDecoration(
                    hintText: 'Email',
                    hintStyle: GoogleFonts.poppins(color: Colors.white70),
                    filled: true,
                    fillColor: Colors.white.withOpacity(0.2),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(30),
                      borderSide: BorderSide.none,
                    ),
                    contentPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) return 'Please enter email';
                    if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value)) {
                      return 'Enter a valid email';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                TextFormField(
                  controller: _passwordController,
                  obscureText: true,
                  style: const TextStyle(color: Colors.white),
                  decoration: InputDecoration(
                    hintText: 'Password',
                    hintStyle: GoogleFonts.poppins(color: Colors.white70),
                    filled: true,
                    fillColor: Colors.white.withOpacity(0.2),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(30),
                      borderSide: BorderSide.none,
                    ),
                    contentPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) return 'Please enter password';
                    if (value.length < 6) return 'Password must be at least 6 characters';
                    return null;
                  },
                ),
                const SizedBox(height: 40),
                ElevatedButton(
                  onPressed: _isLoading ? null : _signInWithEmail,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF8E44AD),
                    padding: const EdgeInsets.symmetric(horizontal: 60, vertical: 18),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(30),
                      side: const BorderSide(color: Colors.white, width: 1.5),
                    ),
                  ),
                  child: _isLoading
                      ? const CircularProgressIndicator(color: Colors.white)
                      : Text(
                    'Login',
                    style: GoogleFonts.poppins(fontSize: 18, color: Colors.white, fontWeight: FontWeight.w600),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\onboarding_screen.dart =====

// lib/screens/onboarding_screen.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

import '../core/utils/user_preferences.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _pageController = PageController();
  int _currentPage = 0;

  final List<Map<String, String>> onboardingData = [
    {
      "title": "Practice Smart",
      "text": "Thousands of questions with detailed solutions",
      "lottie": "practice.json",
    },
    {
      "title": "Track Progress",
      "text": "See your improvement with beautiful analytics",
      "lottie": "progress.json",
    },
    {
      "title": "Compete & Win",
      "text": "Join live contests and climb the leaderboard",
      "lottie": "trophy.json",
    },
  ];

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  /// Called when user completes onboarding
  Future<void> _completeOnboarding() async {
    // Mark onboarding as seen using the safe, updated UserPreferences
    await UserPreferences().saveOnboardingSeen();

    if (!mounted) return;

    // Always go to login after onboarding (user must sign in to save progress)
    // This is best practice: onboarding â†’ login â†’ home
    context.go('/login');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF6C5CE7),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: PageView.builder(
                controller: _pageController,
                onPageChanged: (i) => setState(() => _currentPage = i),
                itemCount: onboardingData.length,
                itemBuilder: (context, index) {
                  final data = onboardingData[index];
                  return OnboardingPage(data: data);
                },
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(30.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // Page indicators
                  Row(
                    children: List.generate(
                      onboardingData.length,
                          (i) => AnimatedContainer(
                        duration: const Duration(milliseconds: 300),
                        margin: const EdgeInsets.only(right: 8),
                        height: 10,
                        width: _currentPage == i ? 30 : 10,
                        decoration: BoxDecoration(
                          color: _currentPage == i ? Colors.white : Colors.white38,
                          borderRadius: BorderRadius.circular(5),
                        ),
                      ),
                    ),
                  ),
                  // Next / Done button
                  FloatingActionButton(
                    backgroundColor: Colors.white,
                    elevation: 6,
                    onPressed: () async {
                      if (_currentPage == onboardingData.length - 1) {
                        await _completeOnboarding();
                      } else {
                        _pageController.nextPage(
                          duration: const Duration(milliseconds: 400),
                          curve: Curves.easeInOut,
                        );
                      }
                    },
                    child: Icon(
                      _currentPage == onboardingData.length - 1
                          ? Icons.check
                          : Icons.arrow_forward,
                      color: const Color(0xFF6C5CE7),
                      size: 28,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class OnboardingPage extends StatelessWidget {
  final Map<String, String> data;

  const OnboardingPage({super.key, required this.data});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 40.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Lottie.asset(
            'assets/lottie/${data["lottie"]}',
            width: 320,
            fit: BoxFit.contain,
            repeat: true,
            errorBuilder: (context, error, stackTrace) {
              // Fallback if Lottie fails to load
              return const Icon(
                Icons.quiz,
                size: 200,
                color: Colors.white70,
              );
            },
          ),
          const SizedBox(height: 60),
          Text(
            data["title"]!,
            style: GoogleFonts.poppins(
              fontSize: 36,
              fontWeight: FontWeight.bold,
              color: Colors.white,
              height: 1.2,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 20),
          Text(
            data["text"]!,
            textAlign: TextAlign.center,
            style: GoogleFonts.poppins(
              fontSize: 18,
              color: Colors.white70,
              height: 1.5,
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\splash_screen.dart =====

// lib/screens/splash_screen.dart
import 'dart:async';
import 'package:animate_do/animate_do.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:flutter_native_splash/flutter_native_splash.dart';
import '../providers/app_init_provider.dart';
import '../providers/app_settings_provider.dart';
import '../core/utils/user_preferences.dart';

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen> {
  bool _hasHandledResult = false;
  Timer? _timeoutTimer;

  @override
  void initState() {
    super.initState();

    // Remove native splash after the first frame is rendered
    WidgetsBinding.instance.addPostFrameCallback((_) {
      FlutterNativeSplash.remove();
    });

    // Safety timeout
    _timeoutTimer = Timer(const Duration(seconds: 12), () {
      final initAsync = ref.read(appInitProvider);
      if (mounted && initAsync.isLoading) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Taking longer than expected...',
              style: GoogleFonts.poppins(),
            ),
            backgroundColor: Colors.orange.shade700,
            behavior: SnackBarBehavior.floating,
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () => ref.invalidate(appInitProvider),
            ),
          ),
        );
      }
    });
  }

  @override
  void dispose() {
    _timeoutTimer?.cancel();
    super.dispose();
  }

  void _showNoNetworkDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text(
          'No Internet Connection',
          style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
        ),
        content: Text(
          'Network not available.\nPlease check your internet connection and try again.',
          style: GoogleFonts.poppins(),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              _hasHandledResult = false;
              ref.invalidate(appInitProvider);
            },
            child: Text(
              'Retry',
              style: GoogleFonts.poppins(
                color: const Color(0xFF6C5CE7),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _showUpdateRequiredDialog() async {
    // Default to the official Play Store link (safe for Google Play distribution)
    String targetUrl = 'https://play.google.com/store/apps/details?id=online.prepking';

    // Optionally allow server-provided Play Store URL (e.g., for campaign tracking)
    final appSettingsAsync = ref.read(appSettingsProvider);
    appSettingsAsync.whenData((settings) {
      if (settings.appStoreUrl != null && settings.appStoreUrl!.trim().isNotEmpty) {
        targetUrl = settings.appStoreUrl!.trim();
      }
      // apkUrl is intentionally ignored on Android Play builds to comply with Play Store policy
    });

    final uri = Uri.parse(targetUrl);

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text(
          'Update Required',
          style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
        ),
        content: Text(
          'A new version of PrepKing is available on Google Play.\nPlease update to continue.',
          style: GoogleFonts.poppins(),
        ),
        actions: [
          TextButton(
            onPressed: () async {
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri, mode: LaunchMode.externalApplication);
              } else {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Could not open the Play Store')),
                  );
                }
              }
            },
            child: Text(
              'UPDATE NOW',
              style: GoogleFonts.poppins(
                color: const Color(0xFF6C5CE7),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _showGenericErrorDialog(String errorMsg) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text(
          'Something Went Wrong',
          style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
        ),
        content: Text(
          errorMsg.contains('Exception')
              ? errorMsg.replaceFirst('Exception: ', '')
              : 'Failed to initialize the app.\nPlease try again.',
          style: GoogleFonts.poppins(),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              _hasHandledResult = false;
              ref.invalidate(appInitProvider);
            },
            child: Text(
              'Retry',
              style: GoogleFonts.poppins(
                color: const Color(0xFF6C5CE7),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final initAsync = ref.watch(appInitProvider);

    ref.listen<AsyncValue<void>>(appInitProvider, (previous, next) {
      if (_hasHandledResult) return;

      next.whenOrNull(
        data: (_) async {
          _hasHandledResult = true;
          final prefs = UserPreferences();
          final seenOnboarding = await prefs.hasSeenOnboarding();
          final user = FirebaseAuth.instance.currentUser;

          if (!seenOnboarding) {
            context.go('/onboarding');
          } else if (user == null) {
            context.go('/login');
          } else {
            context.go('/home');
          }
        },
        error: (err, _) {
          _hasHandledResult = true;
          final errorMsg = err.toString();

          if (errorMsg.contains('NO_NETWORK')) {
            _showNoNetworkDialog();
          } else if (errorMsg.contains('UPDATE_REQUIRED')) {
            _showUpdateRequiredDialog();
          } else {
            _showGenericErrorDialog(errorMsg);
          }
        },
      );
    });

    return Scaffold(
      backgroundColor: const Color(0xFF6C5CE7),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset(
              'assets/lottie/splash.json',
              width: 280,
              fit: BoxFit.contain,
              repeat: true,
              errorBuilder: (context, error, stackTrace) {
                return Column(
                  children: [
                    Image.asset(
                      'assets/images/logo.png',
                      width: 180,
                      height: 180,
                      errorBuilder: (context, error, stackTrace) =>
                      const Icon(Icons.school, size: 100, color: Colors.white),
                    ),
                    const SizedBox(height: 20),
                    const CircularProgressIndicator(color: Colors.white),
                  ],
                );
              },
            ),
            const SizedBox(height: 50),
            FadeInDown(
              duration: const Duration(milliseconds: 1000),
              child: Text(
                'PrepKing',
                style: GoogleFonts.poppins(
                  fontSize: 52,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                  letterSpacing: 1.2,
                  shadows: const [
                    Shadow(color: Colors.black26, offset: Offset(0, 4), blurRadius: 10),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),
            FadeInUp(
              duration: const Duration(milliseconds: 1200),
              delay: const Duration(milliseconds: 400),
              child: Text(
                'Master Any Exam. Anytime. Anywhere.',
                style: GoogleFonts.poppins(fontSize: 18, color: Colors.white70),
                textAlign: TextAlign.center,
              ),
            ),
            const SizedBox(height: 120),
            if (initAsync.isLoading) const _DotsLoader(),
          ],
        ),
      ),
    );
  }
}

class _DotsLoader extends StatefulWidget {
  const _DotsLoader();

  @override
  State<_DotsLoader> createState() => _DotsLoaderState();
}

class _DotsLoaderState extends State<_DotsLoader> with TickerProviderStateMixin {
  late final List<AnimationController> _controllers = List.generate(
    3,
        (_) => AnimationController(vsync: this, duration: const Duration(milliseconds: 600))
      ..repeat(reverse: true),
  );

  @override
  void initState() {
    super.initState();
    for (int i = 0; i < 3; i++) {
      Future.delayed(Duration(milliseconds: i * 150), () {
        if (mounted) _controllers[i].forward();
      });
    }
  }

  @override
  void dispose() {
    for (final c in _controllers) c.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: List.generate(3, (i) {
        return ScaleTransition(
          scale: Tween<double>(begin: 0.4, end: 1.4).animate(
            CurvedAnimation(parent: _controllers[i], curve: Curves.easeInOut),
          ),
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 6),
            width: 12,
            height: 12,
            decoration: const BoxDecoration(
              color: Colors.white,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(color: Colors.white30, blurRadius: 8, spreadRadius: 2),
              ],
            ),
          ),
        );
      }),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\content_list_screen.dart =====

// lib/screens/courses/content_list_screen.dart
import 'package:animate_do/animate_do.dart';
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

import '../../providers/course_providers.dart'; // courseContentsProvider + courseDetailProvider
import '../../providers/user_provider.dart'; // currentUserProvider

class ContentListScreen extends ConsumerStatefulWidget {
  final int courseId;
  const ContentListScreen({super.key, required this.courseId});

  @override
  ConsumerState<ContentListScreen> createState() => _ContentListScreenState();
}

class _ContentListScreenState extends ConsumerState<ContentListScreen> {
  late ConfettiController _confettiController;

  @override
  void initState() {
    super.initState();
    _confettiController = ConfettiController(duration: const Duration(seconds: 3));
  }

  @override
  void dispose() {
    _confettiController.dispose();
    super.dispose();
  }

  void _showCompletionCelebration() {
    _confettiController.play();
    Future.delayed(const Duration(seconds: 1), () {
      if (mounted) {
        context.push('/certificate', extra: {'courseId': widget.courseId});
      }
    });
  }

  // Safe double parsing helper (handles String, int, double, null from API)
  double _parseDouble(dynamic value) {
    if (value == null) return 0.0;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    return double.tryParse(value.toString()) ?? 0.0;
  }

  @override
  Widget build(BuildContext context) {
    final userAsync = ref.watch(currentUserProvider);

    return userAsync.when(
      loading: () => Scaffold(
        appBar: AppBar(
          title: Text(
            "Course Content",
            style: GoogleFonts.poppins(
              fontWeight: FontWeight.bold,
              fontSize: 20,
            ),
          ),
          backgroundColor: const Color(0xFF6C5CE7),
          foregroundColor: Colors.white,
          elevation: 0,
        ),
        body: const Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
      ),
      error: (_, __) => Scaffold(
        appBar: AppBar(
          title: Text(
            "Course Content",
            style: GoogleFonts.poppins(
              fontWeight: FontWeight.bold,
              fontSize: 20,
            ),
          ),
          backgroundColor: const Color(0xFF6C5CE7),
          foregroundColor: Colors.white,
          elevation: 0,
        ),
        body: const Center(child: Text("Error loading user data")),
      ),
      data: (user) {
        // FIXED: Safe access with null fallback
        final int userId = user?.id ?? 0;

        // If user is null or has no id, we still proceed but progress will be 0 (safe)
        if (user == null || userId == 0) {
          debugPrint("âš ï¸ User is null or has no ID â€” progress will show 0%");
        }

        final courseAsync = ref.watch(courseDetailProvider(widget.courseId));
        final contentsAsync = ref.watch(courseContentsProvider(widget.courseId));

        return Scaffold(
          appBar: AppBar(
            title: Text(
              "Course Content",
              style: GoogleFonts.poppins(
                fontWeight: FontWeight.bold,
                fontSize: 20,
              ),
            ),
            backgroundColor: const Color(0xFF6C5CE7),
            foregroundColor: Colors.white,
            elevation: 0,
          ),
          body: Stack(
            children: [
              courseAsync.when(
                loading: () => const Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
                error: (_, __) => const Center(child: Text("Error loading course progress")),
                data: (courseData) {
                  final double courseProgressPercentage = _parseDouble(courseData['progress_percentage']);
                  final List<int> completedContentIds = courseData['completed_content_ids'] as List<int>? ?? [];

                  if (courseProgressPercentage == 0.0 && completedContentIds.isEmpty) {
                    debugPrint("âš ï¸ No progress data returned for course ${widget.courseId}, user $userId");
                  }

                  final bool isCourseCompleted = courseProgressPercentage >= 100.0;
                  if (isCourseCompleted) {
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      if (mounted) {
                        _showCompletionCelebration();
                      }
                    });
                  }

                  final double clampedProgress = courseProgressPercentage.clamp(0.0, 100.0);
                  final double progressValue = clampedProgress / 100.0;

                  return contentsAsync.when(
                    loading: () => const Center(child: CircularProgressIndicator()),
                    error: (_, __) => const Center(child: Text("Error loading content")),
                    data: (contents) {
                      if (contents.isEmpty) {
                        return const Center(child: Text("No lessons available"));
                      }

                      return Column(
                        children: [
                          // Top Progress Bar (unchanged)
                          Padding(
                            padding: const EdgeInsets.all(16.0),
                            child: FadeInDown(
                              child: Container(
                                padding: const EdgeInsets.all(16),
                                decoration: BoxDecoration(
                                  color: Colors.white,
                                  borderRadius: BorderRadius.circular(16),
                                  boxShadow: [
                                    BoxShadow(
                                      color: Colors.black.withOpacity(0.1),
                                      blurRadius: 10,
                                      offset: const Offset(0, 4),
                                    ),
                                  ],
                                ),
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      "Your Progress",
                                      style: GoogleFonts.poppins(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 12),
                                    Row(
                                      children: [
                                        Expanded(
                                          child: LinearProgressIndicator(
                                            value: progressValue,
                                            backgroundColor: Colors.grey[200],
                                            valueColor: const AlwaysStoppedAnimation(Color(0xFF6C5CE7)),
                                            minHeight: 10,
                                            borderRadius: BorderRadius.circular(8),
                                          ),
                                        ),
                                        const SizedBox(width: 12),
                                        Text(
                                          "${clampedProgress.toStringAsFixed(0)}%",
                                          style: GoogleFonts.poppins(
                                            fontSize: 18,
                                            fontWeight: FontWeight.bold,
                                            color: const Color(0xFF6C5CE7),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          ),
                          // Lessons List (fully intact)
                          Expanded(
                            child: ListView.builder(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              itemCount: contents.length,
                              itemBuilder: (ctx, i) {
                                final content = contents[i];
                                final int contentId = content['id'] as int;

                                final bool isCompleted =
                                    completedContentIds.contains(contentId) ||
                                        (content['is_completed'] as bool? ?? false);

                                final bool isLocked = i > 0 &&
                                    !completedContentIds.contains(contents[i - 1]['id'] as int);

                                final String rawType = (content['type'] as String?)
                                    ?.toLowerCase()
                                    .trim() ??
                                    'text';

                                String route;
                                switch (rawType) {
                                  case 'video':
                                  case 'youtube':
                                  case 'vimeo':
                                    route = '/courses/content/video';
                                    break;
                                  case 'audio':
                                    route = '/courses/content/audio';
                                    break;
                                  case 'quiz':
                                  case 'mcq':
                                  case 'assessment':
                                    route = '/courses/content/quiz';
                                    break;
                                  case 'pdf':
                                  case 'document':
                                  case 'file':
                                    route = '/courses/content/pdf';
                                    break;
                                  default:
                                    route = '/courses/content/text';
                                    break;
                                }

                                IconData typeIcon;
                                switch (rawType) {
                                  case 'video':
                                  case 'youtube':
                                  case 'vimeo':
                                    typeIcon = Icons.play_circle_filled;
                                    break;
                                  case 'audio':
                                    typeIcon = Icons.headset;
                                    break;
                                  case 'quiz':
                                  case 'mcq':
                                  case 'assessment':
                                    typeIcon = Icons.quiz;
                                    break;
                                  case 'pdf':
                                  case 'document':
                                  case 'file':
                                    typeIcon = Icons.picture_as_pdf;
                                    break;
                                  default:
                                    typeIcon = Icons.description;
                                    break;
                                }

                                return FadeInUp(
                                  delay: Duration(milliseconds: i * 100),
                                  duration: const Duration(milliseconds: 600),
                                  child: Container(
                                    margin: const EdgeInsets.only(bottom: 16),
                                    decoration: BoxDecoration(
                                      borderRadius: BorderRadius.circular(20),
                                      gradient: LinearGradient(
                                        colors: isLocked
                                            ? [Colors.grey.shade300, Colors.grey.shade400]
                                            : isCompleted
                                            ? [Colors.green.shade400, Colors.green.shade600]
                                            : [const Color(0xFF6C5CE7), const Color(0xFF4A43B0)],
                                        begin: Alignment.topLeft,
                                        end: Alignment.bottomRight,
                                      ),
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.black.withOpacity(0.15),
                                          blurRadius: 12,
                                          offset: const Offset(0, 6),
                                        ),
                                      ],
                                    ),
                                    child: ListTile(
                                      contentPadding: const EdgeInsets.symmetric(
                                          horizontal: 20, vertical: 12),
                                      leading: CircleAvatar(
                                        radius: 28,
                                        backgroundColor: Colors.white.withOpacity(0.3),
                                        child: Icon(
                                          isCompleted
                                              ? Icons.check_rounded
                                              : (isLocked ? Icons.lock_rounded : typeIcon),
                                          color: Colors.white,
                                          size: 28,
                                        ),
                                      ),
                                      title: Text(
                                        content['title'] ?? "Lesson ${i + 1}",
                                        style: GoogleFonts.poppins(
                                          color: Colors.white,
                                          fontWeight: FontWeight.w600,
                                          fontSize: 17,
                                        ),
                                      ),
                                      subtitle: Padding(
                                        padding: const EdgeInsets.only(top: 6),
                                        child: Row(
                                          children: [
                                            Icon(
                                              typeIcon,
                                              color: Colors.white70,
                                              size: 16,
                                            ),
                                            const SizedBox(width: 6),
                                            Text(
                                              (content['type'] as String?)
                                                  ?.toUpperCase() ??
                                                  "TEXT",
                                              style: GoogleFonts.poppins(
                                                color: Colors.white70,
                                                fontSize: 13,
                                                fontWeight: FontWeight.w500,
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                      trailing: isCompleted
                                          ? const Icon(Icons.check_circle_rounded,
                                          color: Colors.white, size: 32)
                                          : (isLocked
                                          ? const Icon(Icons.lock_outline,
                                          color: Colors.white70, size: 28)
                                          : const Icon(
                                          Icons.arrow_forward_ios_rounded,
                                          color: Colors.white,
                                          size: 24)),
                                      enabled: !isLocked,
                                      onTap: !isLocked
                                          ? () {
                                        context.push(
                                          route,
                                          extra: {
                                            ...content,
                                            'course_id': widget.courseId,
                                          },
                                        );
                                      }
                                          : null,
                                    ),
                                  ),
                                );
                              },
                            ),
                          ),
                        ],
                      );
                    },
                  );
                },
              ),
              // Confetti (unchanged)
              Align(
                alignment: Alignment.topCenter,
                child: ConfettiWidget(
                  confettiController: _confettiController,
                  blastDirectionality: BlastDirectionality.explosive,
                  colors: const [
                    Colors.purple,
                    Colors.pink,
                    Colors.blue,
                    Colors.orange,
                    Colors.green,
                    Colors.yellow
                  ],
                  emissionFrequency: 0.05,
                  numberOfParticles: 80,
                  gravity: 0.2,
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\course_detail_screen.dart =====

// lib/screens/courses/course_detail_screen.dart
import 'dart:convert';
import 'package:animate_do/animate_do.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:share_plus/share_plus.dart';
import 'package:dio/dio.dart';
import '../../providers/course_providers.dart'; // courseDetailProvider, courseContentsProvider
import '../../providers/course_progress_provider.dart'; // preciseCourseProgressProvider
import '../../providers/user_provider.dart'; // currentUserProvider for user ID
import '../../core/services/api_service.dart';

class CourseDetailScreen extends ConsumerStatefulWidget {
  final int courseId;
  const CourseDetailScreen({super.key, required this.courseId});

  @override
  ConsumerState<CourseDetailScreen> createState() => _CourseDetailScreenState();
}

class _CourseDetailScreenState extends ConsumerState<CourseDetailScreen> {
  bool _isEnrolling = false;

  // Safe parsing helper for double values from API (handles String, int, double, null)
  double _parseDouble(dynamic value) {
    if (value == null) return 0.0;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) return double.tryParse(value) ?? 0.0;
    return 0.0;
  }

  Future<void> _enrollInCourse() async {
    final api = ref.read(apiServiceProvider);
    final userId = ref.read(currentUserProvider).value?.id;
    if (userId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("User not logged in")),
      );
      return;
    }

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text("Enroll in Course", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: const Text("Are you sure you want to enroll in this course?"),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text("Cancel")),
          ElevatedButton(
            onPressed: () => Navigator.pop(ctx, true),
            style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFF6C5CE7)),
            child: const Text("Enroll Now"),
          ),
        ],
      ),
    );

    if (!(confirmed ?? false)) return;

    setState(() => _isEnrolling = true);

    try {
      await api.post(
        '/course/${widget.courseId}/enroll',
        {}, // empty body
        query: {
          "courseid": widget.courseId,
        },
      );

      // Invalidate related providers
      ref.invalidate(courseDetailProvider(widget.courseId));
      ref.invalidate(courseContentsProvider(widget.courseId));
      ref.invalidate(preciseCourseProgressProvider((widget.courseId, userId)));

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Successfully enrolled!")),
      );
    } catch (e) {
      String msg = "Enrollment failed!";
      if (e is DioException) {
        final data = e.response?.data;
        if (data is Map<String, dynamic> && data.containsKey('message')) {
          msg = data['message'];
        } else {
          msg = data is Map ? jsonEncode(data) : data.toString();
        }
      }
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(backgroundColor: Colors.red, content: Text(msg)),
      );
      debugPrint('Enrollment Error: $e');
    } finally {
      setState(() => _isEnrolling = false);
    }
  }

  void _shareCourse(String title, dynamic slug) {
    final url = "https://prepking.online/c/${slug ?? widget.courseId}";
    Share.share("$title\n\nJoin now: $url", subject: "Check out this course!");
  }

  String _getContentRoute(Map<String, dynamic> content) {
    final String rawType = (content['type'] as String?)?.toLowerCase().trim() ?? 'text';
    switch (rawType) {
      case 'video':
      case 'youtube':
      case 'vimeo':
        return '/courses/content/video';
      case 'audio':
      case 'audiobook':
      case 'mp3':
        return '/courses/content/audio';
      case 'quiz':
      case 'mcq':
      case 'assessment':
        return '/courses/content/quiz';
      case 'pdf':
      case 'document':
      case 'file':
        return '/courses/content/pdf';
      case 'text':
      case 'article':
      case 'lesson':
      case 'html':
      case 'markdown':
      default:
        return '/courses/content/text';
    }
  }

  @override
  Widget build(BuildContext context) {
    final courseAsync = ref.watch(courseDetailProvider(widget.courseId));
    final contentsAsync = ref.watch(courseContentsProvider(widget.courseId));
    final userAsync = ref.watch(currentUserProvider);
    final userId = userAsync.value?.id ?? 0;
    final progressAsync = ref.watch(preciseCourseProgressProvider((widget.courseId, userId)));

    return courseAsync.when(
      loading: () => const Scaffold(
        body: Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
      ),
      error: (err, _) => Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error, size: 80, color: Colors.red),
              const SizedBox(height: 16),
              Text("Failed to load course", style: GoogleFonts.poppins(fontSize: 18)),
              ElevatedButton.icon(
                onPressed: () => ref.invalidate(courseDetailProvider(widget.courseId)),
                icon: const Icon(Icons.refresh),
                label: const Text("Retry"),
              ),
            ],
          ),
        ),
      ),
      data: (course) {
        // Extract progress data safely from precise provider
        final progressData = progressAsync.when(
          data: (data) => data ?? {},
          loading: () => {'isEnrolled': false, 'progress_percentage': 0.0, 'completed': <int>[]},
          error: (_, __) => {'isEnrolled': false, 'progress_percentage': 0.0, 'completed': <int>[]},
        );

        final bool isEnrolled = progressData['isEnrolled'] == true;
        final double progressPercentage = _parseDouble(progressData['progress_percentage']);
        final List<int> completedContentIds = progressData['completed'] as List<int>? ?? [];

        // Clamp for UI
        final double clampedProgress = progressPercentage.clamp(0.0, 100.0);
        final double progress = clampedProgress / 100.0;
        final bool isCompleted = progressPercentage >= 100.0;

        final title = course['title'] ?? 'Course';
        final thumbnail = course['thumbnail'];
        final slug = course['slug'] ?? course['id'].toString();

        final int lessonCount = contentsAsync.when(
          data: (contents) => contents.length,
          loading: () => 0,
          error: (_, __) => 0,
        );

        return Scaffold(
          backgroundColor: const Color(0xFFF8F9FF),
          body: Stack(
            children: [
              CustomScrollView(
                slivers: [
                  SliverAppBar(
                    expandedHeight: 340,
                    pinned: true,
                    flexibleSpace: FlexibleSpaceBar(
                      background: Stack(
                        fit: StackFit.expand,
                        children: [
                          thumbnail != null
                              ? Image.network(thumbnail, fit: BoxFit.cover)
                              : Lottie.asset('assets/lottie/learning.json', fit: BoxFit.cover),
                          Container(
                            decoration: const BoxDecoration(
                              gradient: LinearGradient(
                                begin: Alignment.topCenter,
                                end: Alignment.bottomCenter,
                                colors: [Colors.black45, Colors.black87],
                              ),
                            ),
                          ),
                          Positioned(
                            bottom: 24,
                            left: 20,
                            right: 60,
                            child: FadeInUp(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(title,
                                      style: GoogleFonts.poppins(
                                          fontSize: 28, fontWeight: FontWeight.bold, color: Colors.white)),
                                  const SizedBox(height: 8),
                                  Wrap(
                                    spacing: 8,
                                    children: [
                                      Chip(
                                        backgroundColor: Colors.purple.shade100.withOpacity(0.9),
                                        label: Text(course['topic'] ?? 'General',
                                            style: GoogleFonts.poppins(fontSize: 12)),
                                      ),
                                      Chip(
                                        backgroundColor: Colors.orange.shade100.withOpacity(0.9),
                                        label: Text(course['difficulty'] ?? 'Medium',
                                            style: GoogleFonts.poppins(fontSize: 12)),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                          ),
                          Positioned(
                            top: 50,
                            right: 16,
                            child: IconButton(
                              icon: const Icon(Icons.share_rounded, color: Colors.white, size: 28),
                              onPressed: () => _shareCourse(title, slug),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  SliverToBoxAdapter(
                    child: Padding(
                      padding: const EdgeInsets.all(20),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const SizedBox(height: 16),
                          if (isEnrolled && clampedProgress > 0.0)
                            FadeInUp(
                              child: Container(
                                padding: const EdgeInsets.all(20),
                                margin: const EdgeInsets.only(bottom: 24),
                                decoration: BoxDecoration(
                                  color: Colors.white,
                                  borderRadius: BorderRadius.circular(20),
                                  boxShadow: [
                                    BoxShadow(color: Colors.black12, blurRadius: 15, offset: const Offset(0, 8))
                                  ],
                                ),
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text("Your Progress",
                                        style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w600)),
                                    const SizedBox(height: 12),
                                    Row(
                                      children: [
                                        Expanded(
                                          child: LinearProgressIndicator(
                                            value: progress,
                                            backgroundColor: Colors.grey[200],
                                            valueColor: const AlwaysStoppedAnimation(Color(0xFF6C5CE7)),
                                            minHeight: 10,
                                            borderRadius: BorderRadius.circular(8),
                                          ),
                                        ),
                                        const SizedBox(width: 12),
                                        Text("${clampedProgress.toStringAsFixed(0)}%",
                                            style: GoogleFonts.poppins(
                                                fontSize: 18,
                                                fontWeight: FontWeight.bold,
                                                color: const Color(0xFF6C5CE7))),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          Text("COURSE DETAILS",
                              style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.bold)),
                          const SizedBox(height: 16),
                          _buildInfoCard(
                            Icons.play_circle_outline,
                            "$lessonCount Lessons",
                            "Total lessons",
                          ),
                          const SizedBox(height: 12),
                          _buildInfoCard(Icons.access_time, "${course['duration_minutes'] ?? '60'} mins", "Duration"),
                          const SizedBox(height: 12),
                          _buildInfoCard(Icons.card_giftcard,
                              course['certificate_enabled'] == 1 ? "Certificate Included" : "No Certificate", ""),
                          const SizedBox(height: 32),
                          Text("LESSONS", style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.bold)),
                          const SizedBox(height: 16),
                          contentsAsync.when(
                            loading: () => const Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
                            error: (_, __) => const Text("Failed to load lessons",
                                style: TextStyle(color: Colors.red)),
                            data: (contents) => contents.isEmpty
                                ? const Text("No lessons available yet")
                                : ListView.separated(
                              shrinkWrap: true,
                              physics: const NeverScrollableScrollPhysics(),
                              itemCount: contents.length,
                              separatorBuilder: (_, __) => const Divider(height: 1),
                              itemBuilder: (context, i) {
                                final c = contents[i];
                                final int contentId = c['id'] as int;
                                final bool isCompleted = completedContentIds.contains(contentId) ||
                                    (c['is_completed'] as bool? ?? false);
                                final bool isLocked = course['is_sequential'] == 1 &&
                                    i > 0 &&
                                    !completedContentIds.contains(contents[i - 1]['id'] as int);

                                return ListTile(
                                  enabled: isEnrolled && !isLocked,
                                  leading: CircleAvatar(
                                    backgroundColor: isCompleted ? Colors.green : Colors.grey[300],
                                    child: isCompleted
                                        ? const Icon(Icons.check, color: Colors.white)
                                        : Text("${i + 1}", style: const TextStyle(color: Colors.white)),
                                  ),
                                  title: Text(c['title'] ?? "Lesson ${i + 1}",
                                      style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
                                  subtitle: c['duration_minutes'] != null
                                      ? Text("${c['duration_minutes']} mins")
                                      : null,
                                  trailing: isLocked
                                      ? const Icon(Icons.lock_outline, color: Colors.grey)
                                      : isCompleted
                                      ? const Icon(Icons.check_circle, color: Colors.green)
                                      : const Icon(Icons.chevron_right),
                                  onTap: (isEnrolled && !isLocked)
                                      ? () {
                                    final route = _getContentRoute(c);
                                    context.push(route, extra: {
                                      ...c,
                                      'course_id': widget.courseId,
                                    });
                                  }
                                      : null,
                                );
                              },
                            ),
                          ),
                          const SizedBox(height: 120),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
              // Bottom Button
              Positioned(
                bottom: 30,
                left: 24,
                right: 24,
                child: FadeInUp(
                  child: ElevatedButton.icon(
                    onPressed: _isEnrolling
                        ? null
                        : () {
                      if (isCompleted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text("Certificate coming soon!")));
                      } else if (isEnrolled) {
                        context.push('/courses/content/${widget.courseId}');
                      } else {
                        _enrollInCourse();
                      }
                    },
                    icon: _isEnrolling
                        ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(strokeWidth: 3, color: Colors.white))
                        : Icon(
                      isCompleted
                          ? Icons.card_giftcard_rounded
                          : isEnrolled
                          ? (progressPercentage > 0 ? Icons.play_arrow_rounded : Icons.play_circle_fill)
                          : Icons.rocket_launch_rounded,
                      size: 28,
                    ),
                    label: Text(
                      _isEnrolling
                          ? "Enrolling..."
                          : isCompleted
                          ? "View Certificate"
                          : isEnrolled
                          ? (progressPercentage > 0 ? "Continue Learning" : "Start Learning")
                          : "Enroll Now",
                      style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF6C5CE7),
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(vertical: 18),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
                      elevation: 12,
                    ),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildInfoCard(IconData icon, String title, String subtitle) {
    return FadeInUp(
      child: Container(
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(20),
          boxShadow: [
            BoxShadow(color: Colors.black.withOpacity(0.05), blurRadius: 15, offset: const Offset(0, 8))
          ],
        ),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(color: const Color(0xFF6C5CE7).withOpacity(0.1), borderRadius: BorderRadius.circular(16)),
              child: Icon(icon, color: const Color(0xFF6C5CE7), size: 28),
            ),
            const SizedBox(width: 16),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(title, style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.bold)),
                if (subtitle.isNotEmpty)
                  Text(subtitle, style: GoogleFonts.poppins(fontSize: 13, color: Colors.grey[600])),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\course_list_screen.dart =====

// lib/screens/courses/course_list_screen.dart

import 'package:animate_do/animate_do.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import '../../core/utils/user_preferences.dart';
import '../../providers/course_providers.dart'; // â† CHANGED: Now uses updated course_providers.dart

class CourseListScreen extends ConsumerStatefulWidget {
  const CourseListScreen({super.key});

  @override
  ConsumerState<CourseListScreen> createState() => _CourseListScreenState();
}

class _CourseListScreenState extends ConsumerState<CourseListScreen> {
  bool _isPrefsReady = false;
  bool _isLoadingPrefs = true;

  @override
  void initState() {
    super.initState();
    _checkPreferences();
  }

  Future<void> _checkPreferences() async {
    final prefs = UserPreferences();
    final ready = await prefs.isPreferencesReady();
    if (mounted) {
      setState(() {
        _isPrefsReady = ready;
        _isLoadingPrefs = false;
      });
    }
  }

  // Count total lessons from PHP-serialized content_ids string (kept for display only)
  int _getTotalContents(Map<String, dynamic> course) {
    final contentIds = course['content_ids'];
    if (contentIds == null || contentIds is! String || contentIds.trim().isEmpty) {
      return 0;
    }
    try {
      // Split by comma, trim whitespace, and filter out empty strings
      final ids = contentIds.split(',').map((id) => id.trim()).where((id) => id.isNotEmpty).toList();
      return ids.length;
    } catch (e) {
      return 0;
    }
  }

  // UI when Language & Exams are not selected
  Widget _buildMissingPrefsView() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.settings, size: 80, color: const Color(0xFF6C5CE7)),
            const SizedBox(height: 24),
            Text(
              'Please Select Language and Exams',
              style: GoogleFonts.poppins(
                fontSize: 22,
                fontWeight: FontWeight.bold,
                color: Colors.grey[800],
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            Text(
              'Go to Settings under Profile to set your Language and Exams.',
              style: GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              icon: const Icon(Icons.settings, color: Colors.white),
              label: Text(
                'Go to Settings',
                style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w600),
              ),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF6C5CE7),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
              ),
              onPressed: () {
                context.push('/profile/settings').then((_) {
                  _checkPreferences();
                });
              },
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // Show loading only while checking preferences
    if (_isLoadingPrefs) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(color: Color(0xFF6C5CE7)),
        ),
      );
    }

    // If preferences not ready â†’ show message
    if (!_isPrefsReady) {
      return Scaffold(
        appBar: AppBar(
          backgroundColor: const Color(0xFF6C5CE7),
          title: Text('Courses', style: GoogleFonts.poppins(color: Colors.white, fontWeight: FontWeight.bold)),
          elevation: 0,
        ),
        body: _buildMissingPrefsView(),
        floatingActionButton: FloatingActionButton(
          backgroundColor: const Color(0xFF6C5CE7),
          onPressed: _checkPreferences,
          child: const Icon(Icons.refresh, color: Colors.white),
        ),
      );
    }

    // Preferences ready â†’ normal course list
    // CHANGED: Now uses the enhanced courseListProvider from course_providers.dart
    final coursesAsync = ref.watch(courseListProvider);

    return Scaffold(
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            expandedHeight: 180,
            pinned: true,
            flexibleSpace: FlexibleSpaceBar(
              titlePadding: const EdgeInsetsDirectional.only(start: 20, bottom: 16),
              title: Text(
                "Courses",
                style: GoogleFonts.poppins(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
              background: Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [Color(0xFF6C5CE7), Color(0xFF4A3CB7)],
                  ),
                ),
              ),
            ),
            backgroundColor: const Color(0xFF6C5CE7),
          ),
          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: coursesAsync.when(
              loading: () => const SliverToBoxAdapter(
                child: Center(
                  child: CircularProgressIndicator(color: Color(0xFF6C5CE7)),
                ),
              ),
              error: (_, __) => SliverToBoxAdapter(
                child: Center(
                  child: Column(
                    children: [
                      Lottie.asset('assets/lottie/no_connection.json', width: 200),
                      const SizedBox(height: 20),
                      Text("No internet connection", style: GoogleFonts.poppins(fontSize: 18)),
                      TextButton(
                        onPressed: () => ref.refresh(courseListProvider),
                        child: const Text("Retry", style: TextStyle(color: Color(0xFF6C5CE7))),
                      ),
                    ],
                  ),
                ),
              ),
              data: (courses) {
                if (courses.isEmpty) {
                  return SliverToBoxAdapter(
                    child: Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Lottie.asset('assets/lottie/empty.json', width: 250),
                          const SizedBox(height: 20),
                          Text(
                            "No courses available yet",
                            style: GoogleFonts.poppins(fontSize: 20, color: Colors.grey[600]),
                            textAlign: TextAlign.center,
                          ),
                        ],
                      ),
                    ),
                  );
                }

                return SliverList(
                  delegate: SliverChildBuilderDelegate(
                        (context, index) {
                      final course = courses[index];

                      // FIXED: Use backend-provided normalized progress
                      final double progressPercentage = course['progress_percentage'] as double? ?? 0.0;
                      final int totalLessons = _getTotalContents(course);
                      final String displayId = course['id'].toString();

                      return FadeInUp(
                        delay: Duration(milliseconds: index * 100),
                        child: Hero(
                          tag: 'course-hero-$displayId',
                          child: Container(
                            margin: const EdgeInsets.only(bottom: 16),
                            child: Card(
                              elevation: 8,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
                              child: InkWell(
                                borderRadius: BorderRadius.circular(24),
                                onTap: () => context.push('/courses/detail/$displayId'),
                                child: Padding(
                                  padding: const EdgeInsets.all(20),
                                  child: Row(
                                    children: [
                                      ClipRRect(
                                        borderRadius: BorderRadius.circular(16),
                                        child: Container(
                                          width: 80,
                                          height: 80,
                                          color: Colors.grey[200],
                                          child: (course['thumbnail'] != null &&
                                              course['thumbnail'].toString().isNotEmpty)
                                              ? Image.network(
                                            course['thumbnail'],
                                            fit: BoxFit.cover,
                                            errorBuilder: (_, __, ___) => Lottie.asset(
                                              'assets/lottie/learning.json',
                                              fit: BoxFit.cover,
                                              repeat: true,
                                            ),
                                          )
                                              : Lottie.asset(
                                            'assets/lottie/learning.json',
                                            fit: BoxFit.cover,
                                            repeat: true,
                                          ),
                                        ),
                                      ),
                                      const SizedBox(width: 16),
                                      Expanded(
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            Text(
                                              course['title'] ?? "Untitled Course",
                                              style: GoogleFonts.poppins(
                                                fontSize: 18,
                                                fontWeight: FontWeight.bold,
                                              ),
                                              maxLines: 2,
                                              overflow: TextOverflow.ellipsis,
                                            ),
                                            const SizedBox(height: 8),
                                            Row(
                                              children: [
                                                const Icon(Icons.play_circle_outline, size: 18, color: Colors.grey),
                                                const SizedBox(width: 6),
                                                Text(
                                                  "$totalLessons Lessons",
                                                  style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
                                                ),
                                                const Spacer(),
                                                // Show accurate backend percentage
                                                Text(
                                                  "${progressPercentage.toStringAsFixed(0)}% Done",
                                                  style: GoogleFonts.poppins(
                                                    fontSize: 14,
                                                    fontWeight: FontWeight.w600,
                                                    color: const Color(0xFF6C5CE7),
                                                  ),
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 12),
                                            LinearProgressIndicator(
                                              value: progressPercentage / 100.0, // 0.0 to 1.0
                                              backgroundColor: Colors.grey[300],
                                              valueColor: const AlwaysStoppedAnimation(Color(0xFF6C5CE7)),
                                              minHeight: 7,
                                              borderRadius: BorderRadius.circular(10),
                                            ),
                                          ],
                                        ),
                                      ),
                                      Padding(
                                        padding: const EdgeInsets.only(left: 12),
                                        child: Icon(
                                          Icons.arrow_forward_ios_rounded,
                                          color: Colors.grey[600],
                                          size: 20,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                    childCount: courses.length,
                  ),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        backgroundColor: const Color(0xFF6C5CE7),
        onPressed: () {
          _checkPreferences();
          ref.invalidate(courseListProvider); // â† Now refreshes correct provider
        },
        child: const Icon(Icons.refresh_rounded, color: Colors.white),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\audio_player_screen.dart =====

// lib/screens/courses/contents/audio_player_screen.dart
import 'package:animate_do/animate_do.dart';
import 'package:audio_session/audio_session.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:just_audio/just_audio.dart';
import 'package:rxdart/rxdart.dart';
import '../../../core/services/api_service.dart';
import '../../../providers/user_progress_merged_provider.dart';

class AudioPlayerScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> content;
  const AudioPlayerScreen({super.key, required this.content});

  @override
  ConsumerState<AudioPlayerScreen> createState() => _AudioPlayerScreenState();
}

class _AudioPlayerScreenState extends ConsumerState<AudioPlayerScreen>
    with TickerProviderStateMixin {
  late AudioPlayer _audioPlayer;
  late AnimationController _pulseController;
  double _playbackSpeed = 1.0;
  double _volume = 1.0;

  @override
  void initState() {
    super.initState();
    _audioPlayer = AudioPlayer(
      audioPipeline: AudioPipeline(
        androidAudioEffects: [AndroidLoudnessEnhancer()],
      ),
    );
    _initAudioSession();
    final String? audioUrl = widget.content['resource_url'];
    if (audioUrl != null && audioUrl.isNotEmpty) {
      _audioPlayer.setUrl(audioUrl).catchError((e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error loading audio: $e')),
          );
        }
      });
    }
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    )..repeat(reverse: true);
  }

  Future<void> _initAudioSession() async {
    final session = await AudioSession.instance;
    await session.configure(const AudioSessionConfiguration.music());
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _audioPlayer.dispose();
    super.dispose();
  }

  Stream<PositionData> get _positionDataStream =>
      Rx.combineLatest3<Duration, Duration, Duration?, PositionData>(
        _audioPlayer.positionStream,
        _audioPlayer.bufferedPositionStream,
        _audioPlayer.durationStream,
            (position, bufferedPosition, duration) => PositionData(
          position,
          bufferedPosition,
          duration ?? Duration.zero,
        ),
      );

  String _formatDuration(Duration duration) {
    final minutes = duration.inMinutes.remainder(60).toString().padLeft(2, '0');
    final seconds = duration.inSeconds.remainder(60).toString().padLeft(2, '0');
    return '$minutes:$seconds';
  }

  /// Updated to use the correct 'course_id' key (instead of outdated 'course_quiz_id')
  /// and added proper null-safety + int casting like in TextContentScreen
  Future<void> _recordProgress({required bool completed}) async {
    final userAsync = ref.read(userWithProgressProvider);
    final user = userAsync.value;
    if (user == null) return;

    final int? contentId = widget.content['id'] as int?;
    final int? courseId = widget.content['course_id'] as int?; // â† FIXED

    if (contentId == null || courseId == null) {
      debugPrint('Invalid contentId or courseId for progress update');
      return;
    }

    try {
      final api = ref.read(apiServiceProvider);
      await api.put(
        '/content/$contentId/progress',
        {
          'completed': completed,
          'time_spent': 30,
        },
        query: {
          'userid': user.id.toString(),
          'courseid': courseId.toString(),
          'contentid': contentId.toString(),
        },
      );

      // Refresh merged user progress â€“ now works correctly because course_id is consistent
      ref.invalidate(userWithProgressProvider);
    } catch (e) {
      debugPrint('Error recording audio progress: $e');
    }
  }

  Future<bool> _onBackPressed() async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text("Leave Audio"),
        content: const Text(
          "Do you want to leave this screen?\nIs the content completed by you?",
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text("Stay"),
          ),
          TextButton(
            onPressed: () async {
              await _recordProgress(completed: true);
              if (mounted) Navigator.pop(context, true);
            },
            child: const Text("Completed"),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text("Leave"),
          ),
        ],
      ),
    );
    return result ?? false;
  }

  @override
  Widget build(BuildContext context) {
    final String title = widget.content['title'] ?? 'Audio Lesson';
    final String? audioUrl = widget.content['resource_url'];

    return WillPopScope(
      onWillPop: _onBackPressed,
      child: Scaffold(
        backgroundColor: Colors.transparent,
        extendBody: true,
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [Color(0xFF6C5CE7), Color(0xFF4A43B0)],
            ),
          ),
          child: SafeArea(
            bottom: false,
            child: Stack(
              children: [
                SingleChildScrollView(
                  physics: const BouncingScrollPhysics(),
                  padding: const EdgeInsets.only(bottom: 120),
                  child: Column(
                    children: [
                      Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Row(
                          children: [
                            IconButton(
                              icon: const Icon(Icons.arrow_downward,
                                  color: Colors.white, size: 28),
                              onPressed: () => context.pop(),
                            ),
                            Expanded(
                              child: Text(
                                title,
                                style: GoogleFonts.poppins(
                                  color: Colors.white,
                                  fontSize: 18,
                                  fontWeight: FontWeight.w600,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                            const SizedBox(width: 48),
                          ],
                        ),
                      ),
                      const SizedBox(height: 20),
                      FadeIn(
                        child: ScaleTransition(
                          scale: Tween<double>(begin: 0.95, end: 1.05)
                              .animate(_pulseController),
                          child: Container(
                            width: 240,
                            height: 240,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              color: Colors.white.withOpacity(0.15),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.25),
                                  blurRadius: 24,
                                  offset: const Offset(0, 8),
                                ),
                              ],
                            ),
                            child: const Icon(
                              Icons.headphones_rounded,
                              size: 96,
                              color: Colors.white,
                            ),
                          ),
                        ),
                      ),
                      const SizedBox(height: 40),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 32),
                        child: Column(
                          children: [
                            Text(
                              title,
                              style: GoogleFonts.poppins(
                                color: Colors.white,
                                fontSize: 24,
                                fontWeight: FontWeight.bold,
                              ),
                              textAlign: TextAlign.center,
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 8),
                            Text(
                              'Course Audio Lesson',
                              style: GoogleFonts.poppins(
                                color: Colors.white70,
                                fontSize: 16,
                              ),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 16),
                      PopupMenuButton<double>(
                        initialValue: _playbackSpeed,
                        onSelected: (speed) {
                          setState(() => _playbackSpeed = speed);
                          _audioPlayer.setSpeed(speed);
                        },
                        itemBuilder: (context) => [1, 1.25, 1.5, 2, 3, 4]
                            .map((e) => PopupMenuItem(
                          value: e.toDouble(),
                          child: Text("${e}x"),
                        ))
                            .toList(),
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 12, vertical: 6),
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(20),
                            color: Colors.white.withOpacity(0.2),
                          ),
                          child: Text(
                            "${_playbackSpeed}x",
                            style: GoogleFonts.poppins(color: Colors.white),
                          ),
                        ),
                      ),
                      const SizedBox(height: 28),
                      if (audioUrl != null && audioUrl.isNotEmpty)
                        StreamBuilder<PositionData>(
                          stream: _positionDataStream,
                          builder: (context, snapshot) {
                            final positionData = snapshot.data ??
                                PositionData(Duration.zero, Duration.zero,
                                    Duration.zero);
                            final duration = positionData.duration;
                            final position = positionData.position;
                            return Padding(
                              padding:
                              const EdgeInsets.symmetric(horizontal: 32),
                              child: Column(
                                children: [
                                  SliderTheme(
                                    data: SliderTheme.of(context).copyWith(
                                      trackHeight: 4,
                                      thumbShape: const RoundSliderThumbShape(
                                          enabledThumbRadius: 8),
                                      overlayShape:
                                      const RoundSliderOverlayShape(
                                          overlayRadius: 16),
                                      activeTrackColor: Colors.white,
                                      inactiveTrackColor: Colors.white30,
                                      thumbColor: Colors.white,
                                      overlayColor:
                                      Colors.white.withOpacity(0.2),
                                    ),
                                    child: Slider(
                                      min: 0.0,
                                      max: duration.inMilliseconds.toDouble(),
                                      value: position.inMilliseconds
                                          .toDouble()
                                          .clamp(0.0,
                                          duration.inMilliseconds.toDouble()),
                                      onChanged: (value) {
                                        _audioPlayer.seek(Duration(
                                            milliseconds: value.toInt()));
                                      },
                                    ),
                                  ),
                                  Row(
                                    mainAxisAlignment:
                                    MainAxisAlignment.spaceBetween,
                                    children: [
                                      Text(
                                        _formatDuration(position),
                                        style: GoogleFonts.poppins(
                                            color: Colors.white70,
                                            fontSize: 14),
                                      ),
                                      Text(
                                        _formatDuration(duration),
                                        style: GoogleFonts.poppins(
                                            color: Colors.white70,
                                            fontSize: 14),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            );
                          },
                        )
                      else
                        const Text(
                          "Audio file not available",
                          style: TextStyle(color: Colors.white70, fontSize: 16),
                        ),
                      const SizedBox(height: 20),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 32),
                        child: Row(
                          children: [
                            const Icon(Icons.volume_down, color: Colors.white),
                            Expanded(
                              child: Slider(
                                min: 0,
                                max: 1,
                                value: _volume,
                                onChanged: (value) {
                                  setState(() => _volume = value);
                                  _audioPlayer.setVolume(value);
                                },
                              ),
                            ),
                            const Icon(Icons.volume_up, color: Colors.white),
                          ],
                        ),
                      ),
                      const SizedBox(height: 28),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          IconButton(
                            iconSize: 40,
                            color: Colors.white70,
                            icon: const Icon(Icons.skip_previous_rounded),
                            onPressed: () {},
                          ),
                          const SizedBox(width: 32),
                          StreamBuilder<PlayerState>(
                            stream: _audioPlayer.playerStateStream,
                            builder: (context, snapshot) {
                              final playerState = snapshot.data;
                              final processingState =
                                  playerState?.processingState;
                              final playing = playerState?.playing ?? false;
                              if (processingState == ProcessingState.loading ||
                                  processingState == ProcessingState.buffering) {
                                return const SizedBox(
                                  width: 72,
                                  height: 72,
                                  child: CircularProgressIndicator(
                                      color: Colors.white, strokeWidth: 6),
                                );
                              }
                              return BounceInDown(
                                child: GestureDetector(
                                  onTap: () {
                                    if (playing) {
                                      _audioPlayer.pause();
                                    } else {
                                      _audioPlayer.play();
                                    }
                                  },
                                  child: Container(
                                    width: 72,
                                    height: 72,
                                    decoration: const BoxDecoration(
                                      shape: BoxShape.circle,
                                      color: Colors.white,
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.black26,
                                          blurRadius: 20,
                                          offset: Offset(0, 8),
                                        ),
                                      ],
                                    ),
                                    child: Icon(
                                      playing
                                          ? Icons.pause_rounded
                                          : Icons.play_arrow_rounded,
                                      size: 44,
                                      color: const Color(0xFF6C5CE7),
                                    ),
                                  ),
                                ),
                              );
                            },
                          ),
                          const SizedBox(width: 32),
                          IconButton(
                            iconSize: 40,
                            color: Colors.white70,
                            icon: const Icon(Icons.skip_next_rounded),
                            onPressed: () {},
                          ),
                        ],
                      ),
                      const SizedBox(height: 100),
                    ],
                  ),
                ),
                Positioned(
                  left: 20,
                  right: 20,
                  bottom: 20 + MediaQuery.of(context).padding.bottom,
                  child: SizedBox(
                    width: double.infinity,
                    child: ElevatedButton.icon(
                      onPressed: () async {
                        await _recordProgress(completed: true);
                        if (!mounted) return;
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content:
                            Text("Audio lesson marked as completed! ðŸŽ‰"),
                            backgroundColor: Colors.green,
                          ),
                        );
                      },
                      icon: const Icon(Icons.check_circle_outline, size: 28),
                      label: Text(
                        "Mark as Completed",
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.green,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 18),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(30),
                        ),
                        elevation: 8,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class PositionData {
  final Duration position;
  final Duration bufferedPosition;
  final Duration duration;
  PositionData(this.position, this.bufferedPosition, this.duration);
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\content_player_screen.dart =====

// lib/screens/course/contents/content_player_screen.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'text_content_screen.dart';
import 'video_content_screen.dart';
import 'quiz_content_screen.dart';
import 'pdf_content_screen.dart';

class ContentPlayerScreen extends StatelessWidget {
  final Map<String, dynamic> content;

  const ContentPlayerScreen({super.key, required this.content});

  @override
  Widget build(BuildContext context) {
    final String type = (content['type'] as String?)?.toLowerCase().trim() ?? 'text';

    Widget screen;

    switch (type) {
      case 'video':
      case 'youtube':
      case 'vimeo':
        screen = VideoContentScreen(content: content);
        break;

      case 'quiz':
      case 'mcq':
      case 'assessment':
        screen = QuizContentScreen(content: content);
        break;

      case 'pdf':
      case 'document':
      case 'file':
        screen = PdfContentScreen(content: content);
        break;

      case 'text':
      case 'article':
      case 'lesson':
      case 'html':
      case 'markdown':
      default:
        screen = TextContentScreen(content: content);
        break;
    }

    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
        title: Text(
          content['title']?.toString() ?? 'Lesson',
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600, fontSize: 18),
        ),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.share_outlined),
            onPressed: () => ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text("Share coming soon!")),
            ),
          ),
        ],
      ),
      body: SafeArea(child: screen),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\pdf_content_screen.dart =====

// lib/screens/course/contents/pdf_content_screen.dart
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_pdfviewer/pdfviewer.dart';

class PdfContentScreen extends StatelessWidget {
  final Map<String, dynamic> content;

  const PdfContentScreen({super.key, required this.content});

  @override
  Widget build(BuildContext context) {
    final url = content['pdf_url']?.toString() ?? content['file_url']?.toString() ?? '';

    if (url.isEmpty) {
      return const Center(
        child: Text("No PDF file found.", style: TextStyle(fontSize: 18)),
      );
    }

    return SfPdfViewer.network(
      url,
      canShowScrollHead: true,
      canShowScrollStatus: true,
      pageLayoutMode: PdfPageLayoutMode.continuous,
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\quiz_content_screen.dart =====

// lib/screens/course/contents/quiz_content_screen.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';

class QuizContentScreen extends StatelessWidget {
  final Map<String, dynamic> content;

  const QuizContentScreen({super.key, required this.content});

  @override
  Widget build(BuildContext context) {
    final quizId = int.tryParse(content['quiz_id']?.toString() ?? '0') ?? 0;
    final total = content['total_questions'] ?? 10;

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              padding: const EdgeInsets.all(30),
              decoration: BoxDecoration(
                color: const Color(0xFF6C5CE7).withOpacity(0.15),
                shape: BoxShape.circle,
              ),
              child: const Icon(Icons.quiz, size: 90, color: Color(0xFF6C5CE7)),
            ),
            const SizedBox(height: 40),
            Text(
              content['title']?.toString() ?? 'Quiz',
              style: GoogleFonts.poppins(fontSize: 28, fontWeight: FontWeight.bold),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            Text(
              "$total Questions â€¢ Earn points on completion",
              style: const TextStyle(fontSize: 16, color: Colors.grey),
            ),
            const SizedBox(height: 50),
            ElevatedButton.icon(
              onPressed: quizId > 0
                  ? () => context.push('/quiz/$quizId', extra: content)
                  : null,
              icon: const Icon(Icons.play_arrow, size: 28),
              label: const Text("Start Quiz", style: TextStyle(fontSize: 18)),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF6C5CE7),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 50, vertical: 18),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
              ),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\text_audio_player_screen.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:animate_do/animate_do.dart';

class TextAudioPlayerScreen extends StatefulWidget {
  final String title;
  final String text;
  const TextAudioPlayerScreen({
    super.key,
    required this.title,
    required this.text,
  });

  @override
  State<TextAudioPlayerScreen> createState() => _TextAudioPlayerScreenState();
}

class _TextAudioPlayerScreenState extends State<TextAudioPlayerScreen> {
  final FlutterTts _tts = FlutterTts();
  bool _isPlaying = false;
  double _speechRate = 0.5;
  int _currentWordIndex = -1;
  late List<String> _words;
  late String _cleanText;
  DateTime _lastHighlightTime = DateTime.now();
  final ScrollController _scrollController = ScrollController();
  List<int> _wordLineMap = [];
  List<double> _lineOffsets = [];
  int _currentLine = -1;

  // Character boundaries for each word in _cleanText
  List<int> _wordStartIndices = [];
  List<int> _wordEndIndices = [];

  @override
  void initState() {
    super.initState();
    _cleanText = _sanitizeText(widget.text);
    _words = _cleanText.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
    _computeWordBoundaries();
    _initTts();
  }

  @override
  void dispose() {
    _tts.stop();
    _scrollController.dispose();
    super.dispose();
  }

  String _sanitizeText(String text) {
    return text
        .replaceAll(RegExp(r'<[^>]*>'), ' ') // Strip HTML tags
        .replaceAll(RegExp(r'&nbsp;|\u00A0'), ' ') // Non-breaking spaces
        .replaceAll(RegExp(r'\s+'), ' ') // Multiple spaces â†’ one
        .trim();
  }

  void _computeWordBoundaries() {
    _wordStartIndices.clear();
    _wordEndIndices.clear();
    int charIndex = 0;
    for (var word in _words) {
      _wordStartIndices.add(charIndex);
      charIndex += word.length;
      _wordEndIndices.add(charIndex);
      charIndex += 1; // account for space
    }
  }

  Future<void> _initTts() async {
    await _tts.setLanguage("und"); // auto-detect
    await _tts.setSpeechRate(_speechRate);
    await _tts.setVolume(1.0);
    await _tts.setPitch(1.0);

    _tts.setStartHandler(() {
      if (mounted) setState(() => _isPlaying = true);
    });

    _tts.setContinueHandler(() {
      if (mounted) setState(() => _isPlaying = true);
    });

    _tts.setPauseHandler(() {
      if (mounted) setState(() => _isPlaying = false);
    });

    _tts.setProgressHandler((String text, int start, int end, String word) {
      if (!_isPlaying || !mounted) return;

      int? wordIndex;
      // Try to find word by start offset
      for (int i = 0; i < _wordStartIndices.length; i++) {
        if (start >= _wordStartIndices[i] && start < _wordEndIndices[i]) {
          wordIndex = i;
          break;
        }
      }

      // Fallback: use end offset if start didn't match
      if (wordIndex == null) {
        for (int i = 0; i < _wordEndIndices.length; i++) {
          if (end <= _wordEndIndices[i]) {
            wordIndex = i;
            break;
          }
        }
      }

      if (wordIndex != null) {
        final now = DateTime.now();
        if (now.difference(_lastHighlightTime).inMilliseconds > 120) {
          if (mounted) {
            setState(() {
              _currentWordIndex = wordIndex!;
            });
          }
          _lastHighlightTime = now;
          _scrollToWord(wordIndex!);
        }
      }
    });

    _tts.setCompletionHandler(() {
      if (mounted) _resetPlaybackState();
    });

    _tts.setCancelHandler(() {
      if (mounted) _resetPlaybackState();
    });
  }

  void _resetPlaybackState() {
    setState(() {
      _isPlaying = false;
      _currentWordIndex = -1;
    });
  }

  Future<void> _togglePlay() async {
    if (_isPlaying) {
      await _tts.pause();
    } else {
      await _tts.speak(_cleanText); // Always full text
    }
  }

  void _computeLineMetrics(BoxConstraints constraints) {
    final double effectiveWidth = constraints.maxWidth - 40.0;
    final TextSpan textSpan = TextSpan(
      text: _cleanText,
      style: const TextStyle(fontSize: 18, height: 1.8, color: Colors.black87),
    );
    final TextPainter painter = TextPainter(
      text: textSpan,
      textDirection: TextDirection.ltr,
    );
    painter.layout(maxWidth: effectiveWidth);
    final List<LineMetrics> lines = painter.computeLineMetrics();

    _lineOffsets = [];
    _wordLineMap = List.filled(_words.length, 0);

    // Compute character start positions of each word
    List<int> wordStarts = [];
    int charPos = 0;
    for (var word in _words) {
      wordStarts.add(charPos);
      charPos += word.length + 1;
    }
    if (_words.isNotEmpty) charPos--; // adjust for last word

    int offset = 0;
    int wordIndex = 0;
    for (int lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      final double lineY = painter.getOffsetForCaret(TextPosition(offset: offset), Rect.zero).dy;
      _lineOffsets.add(lineY);

      // Binary search for line end offset
      int low = offset;
      int high = _cleanText.length;
      while (low < high) {
        final int mid = low + (high - low) ~/ 2;
        final double midY = painter.getOffsetForCaret(TextPosition(offset: mid), Rect.zero).dy;
        if (midY == lineY) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      final int lineEnd = low;

      while (wordIndex < _words.length && wordStarts[wordIndex] < lineEnd) {
        _wordLineMap[wordIndex] = lineIndex;
        wordIndex++;
      }

      offset = lineEnd;
    }
  }

  void _scrollToWord(int wordIndex) {
    if (_wordLineMap.isEmpty || wordIndex >= _wordLineMap.length) return;
    final int lineIndex = _wordLineMap[wordIndex];
    if (lineIndex < 6) return;
    if (lineIndex != _currentLine) {
      _currentLine = lineIndex;
      if (_lineOffsets.isNotEmpty && lineIndex < _lineOffsets.length) {
        final double targetOffset = (_lineOffsets[lineIndex] - 40.0)
            .clamp(0.0, _scrollController.position.maxScrollExtent);
        _scrollController.animateTo(
          targetOffset,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    }
  }

  Widget _buildHighlightedText() {
    return SelectableText.rich(
      TextSpan(
        children: _words.asMap().entries.map((entry) {
          final index = entry.key;
          final word = entry.value;
          final isActive = index == _currentWordIndex;
          return TextSpan(
            text: "$word ",
            style: TextStyle(
              fontSize: 18,
              height: 1.8,
              color: isActive ? Colors.white : Colors.black87,
              backgroundColor: isActive ? const Color(0xFF6C5CE7) : Colors.transparent,
              fontWeight: isActive ? FontWeight.bold : FontWeight.normal,
            ),
          );
        }).toList(),
      ),
      style: const TextStyle(fontSize: 18, color: Colors.black87),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        title: Text(
          widget.title,
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
        ),
      ),
      body: Column(
        children: [
          FadeInDown(
            duration: const Duration(milliseconds: 600),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.all(24),
              decoration: const BoxDecoration(
                color: Color(0xFF6C5CE7),
                borderRadius: BorderRadius.vertical(bottom: Radius.circular(30)),
              ),
              child: Column(
                children: [
                  AnimatedContainer(
                    duration: const Duration(milliseconds: 300),
                    child: Icon(
                      _isPlaying ? Icons.graphic_eq : Icons.headphones,
                      size: 64,
                      color: Colors.white,
                    ),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    _isPlaying ? "Reading aloud..." : "Tap play to listen",
                    style: GoogleFonts.poppins(color: Colors.white70, fontSize: 16),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 20),
          Expanded(
            child: LayoutBuilder(
              builder: (context, constraints) {
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  if (_wordLineMap.isEmpty) {
                    _computeLineMetrics(constraints);
                  }
                });
                return SingleChildScrollView(
                  controller: _scrollController,
                  padding: const EdgeInsets.symmetric(horizontal: 20),
                  child: _buildHighlightedText(),
                );
              },
            ),
          ),
          Container(
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.white,
              boxShadow: [
                BoxShadow(color: Colors.black12, blurRadius: 10, offset: Offset(0, -2))
              ],
            ),
            child: Column(
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [0.5, 0.75, 1.0, 1.25, 1.5].map((rate) {
                    return Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 4),
                      child: ChoiceChip(
                        label: Text("${rate}x"),
                        selected: _speechRate == rate,
                        selectedColor: const Color(0xFF6C5CE7),
                        labelStyle: TextStyle(
                          color: _speechRate == rate ? Colors.white : Colors.black87,
                        ),
                        onSelected: (_) async {
                          setState(() => _speechRate = rate);
                          await _tts.setSpeechRate(rate);
                          if (_isPlaying) {
                            await _tts.stop();
                            await Future.delayed(const Duration(milliseconds: 100));
                            await _tts.speak(_cleanText);
                          }
                        },
                      ),
                    );
                  }).toList(),
                ),
                const SizedBox(height: 20),
                ZoomIn(
                  duration: const Duration(milliseconds: 400),
                  child: FloatingActionButton.large(
                    backgroundColor: const Color(0xFF6C5CE7),
                    onPressed: _togglePlay,
                    child: Icon(
                      _isPlaying ? Icons.pause : Icons.play_arrow,
                      size: 40,
                      color: Colors.white,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\text_content_screen.dart =====

// lib/screens/course/contents/text_content_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_html/flutter_html.dart';
import 'dart:convert';
import '../../../core/services/api_service.dart';
import '../../../providers/user_progress_merged_provider.dart';

class TextContentScreen extends ConsumerWidget {
  final Map<String, dynamic> content;
  const TextContentScreen({super.key, required this.content});

  String? _getTextContent() {
    final dynamic ctextRaw = content['ctext'];
    if (ctextRaw == null) return null;
    final String ctext = ctextRaw.toString().trim();
    return ctext.isEmpty ? null : ctext;
  }

  bool _isHtmlContent(String text) {
    return text.contains(RegExp(
      r'<(p|div|h[1-6]|ul|ol|li|blockquote|img|br|table|thead|tbody|tr|td|th|section|article|span)\b',
      caseSensitive: false,
    ));
  }

  String _getReadingTimeDisplay() {
    final dynamic readingTimeRaw = content['reading_time'];
    if (readingTimeRaw == null) return '';
    final String value = readingTimeRaw.toString().trim();
    final int? minutes = int.tryParse(value);
    if (minutes != null && minutes > 0) {
      return "Reading time: $minutes min";
    } else if (value.isNotEmpty) {
      return "Reading time: $value";
    }
    return '';
  }

  Future<void> _markAsCompleted(WidgetRef ref, BuildContext context) async {
    final userAsync = ref.read(userWithProgressProvider);
    final user = userAsync.value;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Please log in to mark as completed")),
      );
      return;
    }

    // â† FIXED: Use 'course_id' (passed from ContentListScreen) instead of 'course_quiz_id'
    final int? contentId = content['id'] as int?;
    final int? courseId = content['course_id'] as int?;

    if (contentId == null || courseId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Invalid lesson data")),
      );
      return;
    }

    try {
      final api = ref.read(apiServiceProvider);
      // Exact same format as your working quiz attempt example
      await api.put(
        '/content/$contentId/progress',
        {
          'completed': true,
          'time_spent': 30, // seconds spent on this lesson
        },
        query: {
          'userid': user.id.toString(),
          'courseid': courseId.toString(),
          'contentid': contentId.toString(),
        },
      );
      // Refresh progress so ContentListScreen, CourseDetail, etc. update instantly
      ref.invalidate(userWithProgressProvider);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Lesson marked as completed! ðŸŽ‰"),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      debugPrint('Error marking lesson as completed: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text("Failed to save progress: $e"),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final String? body = _getTextContent();
    final bool isHtml = body != null && _isHtmlContent(body ?? '');
    final String readingTimeText = _getReadingTimeDisplay();
    final String title = content['title']?.toString().trim() ?? 'Untitled Lesson';

    return Scaffold(
      appBar: AppBar(
        title: Text(
          title,
          style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
        ),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: Stack(
        children: [
          SingleChildScrollView(
            padding: const EdgeInsets.all(20),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Optional Thumbnail
                if (content['thumbnail'] != null &&
                    content['thumbnail'].toString().trim().isNotEmpty)
                  ClipRRect(
                    borderRadius: BorderRadius.circular(16),
                    child: Image.network(
                      content['thumbnail'].toString().trim(),
                      height: 220,
                      width: double.infinity,
                      fit: BoxFit.cover,
                      errorBuilder: (_, __, ___) => Container(
                        height: 220,
                        color: Colors.grey[200],
                        child: const Icon(Icons.image_not_supported,
                            size: 60, color: Colors.grey),
                      ),
                    ),
                  ),
                const SizedBox(height: 24),
                // Title
                Text(
                  title,
                  style: GoogleFonts.poppins(
                    fontSize: 28,
                    fontWeight: FontWeight.bold,
                    color: Colors.black87,
                  ),
                ),
                const SizedBox(height: 12),
                // Reading Time
                if (readingTimeText.isNotEmpty)
                  Row(
                    children: [
                      const Icon(Icons.access_time, size: 18, color: Colors.grey),
                      const SizedBox(width: 6),
                      Text(
                        readingTimeText,
                        style: const TextStyle(color: Colors.grey, fontSize: 14),
                      ),
                    ],
                  ),
                if (readingTimeText.isNotEmpty) const SizedBox(height: 16),
                // Listen Button
                if (body != null)
                  Center(
                    child: Padding(
                      padding: const EdgeInsets.symmetric(vertical: 12),
                      child: ElevatedButton.icon(
                        onPressed: () {
                          context.push(
                            '/courses/content/text-audio',
                            extra: {
                              'title': title,
                              'text': body,
                            },
                          );
                        },
                        icon: const Icon(Icons.headphones, size: 20),
                        label: const Text("Listen to this lesson"),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF6C5CE7),
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(
                              horizontal: 24, vertical: 14),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(30),
                          ),
                        ),
                      ),
                    ),
                  ),
                const Divider(height: 40, thickness: 1),
                // Main Text Content
                if (body != null)
                  isHtml
                      ? Html(
                    data: body,
                    style: {
                      "body": Style(
                        fontSize: FontSize(17),
                        lineHeight: LineHeight(1.7),
                        margin: Margins.zero,
                      ),
                      "h1,h2,h3,h4,h5,h6": Style(
                        fontWeight: FontWeight.bold,
                        fontSize: FontSize(22),
                      ),
                      "p": Style(margin: Margins.symmetric(vertical: 12)),
                      "ul,ol": Style(margin: Margins.symmetric(vertical: 12)),
                      "li": Style(margin: Margins.only(left: 20)),
                      "img": Style(
                        width: Width(100, Unit.percent),
                        height: Height.auto(),
                        margin: Margins.symmetric(vertical: 20),
                        display: Display.block,
                      ),
                      "blockquote": Style(
                        backgroundColor: Colors.grey[100],
                        padding: HtmlPaddings.all(16),
                        margin: Margins.symmetric(vertical: 16),
                        border: Border(
                            left: BorderSide(color: Colors.grey, width: 4)),
                      ),
                    },
                  )
                      : Text(
                    body,
                    style: const TextStyle(
                      fontSize: 17,
                      height: 1.7,
                      color: Colors.black87,
                    ),
                  )
                else
                  const Center(
                    child: Padding(
                      padding: EdgeInsets.symmetric(vertical: 60),
                      child: Text(
                        "No text content available.",
                        style: TextStyle(fontSize: 16, color: Colors.grey),
                      ),
                    ),
                  ),
                const SizedBox(height: 100), // Space for floating button
              ],
            ),
          ),
          // Floating "Mark as Completed" Button
          Align(
            alignment: Alignment.bottomCenter,
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: () => _markAsCompleted(ref, context),
                  icon: const Icon(Icons.check_circle_outline, size: 28),
                  label: Text(
                    "Mark as Completed",
                    style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 18),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(30),
                    ),
                    elevation: 8,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\courses\contents\video_content_screen.dart =====

// lib/screens/course/contents/video_content_screen.dart
import 'package:flutter/material.dart';
import 'package:youtube_player_flutter/youtube_player_flutter.dart';

class VideoContentScreen extends StatefulWidget {
  final Map<String, dynamic> content;
  const VideoContentScreen({super.key, required this.content});

  @override
  State<VideoContentScreen> createState() => _VideoContentScreenState();
}

class _VideoContentScreenState extends State<VideoContentScreen> {
  late YoutubePlayerController _controller;

  @override
  void initState() {
    super.initState();
    final url = widget.content['video_url']?.toString() ?? widget.content['url']?.toString() ?? '';
    final videoId = YoutubePlayer.convertUrlToId(url) ?? '';

    _controller = YoutubePlayerController(
      initialVideoId: videoId.isNotEmpty ? videoId : 'dQw4w9WgXcQ', // fallback
      flags: const YoutubePlayerFlags(autoPlay: true, mute: false),
    );
  }

  @override
  Widget build(BuildContext context) {
    final desc = widget.content['description']?.toString() ?? '';

    return Column(
      children: [
        YoutubePlayer(
          controller: _controller,
          showVideoProgressIndicator: true,
          progressColors: const ProgressBarColors(
            playedColor: Color(0xFF6C5CE7),
            handleColor: Colors.purple,
          ),
        ),
        if (desc.isNotEmpty)
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(20),
              child: Text(desc, style: const TextStyle(fontSize: 16, height: 1.6)),
            ),
          ),
      ],
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\home\home_screen.dart =====

// lib/screens/home/home_screen.dart
import 'package:animate_do/animate_do.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import '../../providers/user_provider.dart';
import '../../core/utils/user_preferences.dart';
import '../../providers/continue_learning_provider.dart'; // â† Uses /user_progress/{userId}
import '../../widgets/language_select_dialog.dart';
import '../../widgets/exam_select_dialog.dart';
import '../../models/user_model.dart';

class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});
  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen> with TickerProviderStateMixin {
  late AnimationController _fireController;
  bool _hasCheckedDialogs = false;

  @override
  void initState() {
    super.initState();
    _fireController = AnimationController(vsync: this);
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      final userAsync = ref.read(currentUserProvider);
      if (userAsync.asData == null || userAsync.asData?.value == null) return;
      UserModel user = userAsync.asData!.value!;
      user = await _loadPrefsIfMissing(user);
      if (!_hasCheckedDialogs) {
        _hasCheckedDialogs = true;
        if (user.languageId == null) {
          final languageSelected = await showLanguageSelectDialog(context);
          if (languageSelected == true && user.examIds.isEmpty) {
            await showExamSelectDialog(context);
          }
        } else if (user.examIds.isEmpty) {
          await showExamSelectDialog(context);
        }
      }
    });
  }

  Future<UserModel> _loadPrefsIfMissing(UserModel user) async {
    final prefs = UserPreferences();
    final storedLanguage = await prefs.getLanguage();
    final storedExams = await prefs.getExams();
    bool needsUpdate = false;
    UserModel updatedUser = user;
    if (user.languageId == null && storedLanguage != null) {
      updatedUser = user.copyWith(languageId: storedLanguage);
      needsUpdate = true;
    }
    if (user.examIds.isEmpty && storedExams.isNotEmpty) {
      updatedUser = updatedUser.copyWith(examIds: storedExams);
      needsUpdate = true;
    }
    if (needsUpdate) {
      ref.invalidate(currentUserProvider);
    }
    return updatedUser;
  }

  @override
  void dispose() {
    _fireController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final userAsync = ref.watch(currentUserProvider);
    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFF6C5CE7), Color(0xFF4A3CB7)],
          ),
        ),
        child: SafeArea(
          child: RefreshIndicator(
            onRefresh: () => ref.refresh(currentUserProvider.future),
            child: SingleChildScrollView(
              physics: const BouncingScrollPhysics(),
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // HEADER
                  Row(
                    children: [
                      Expanded(
                        child: userAsync.when(
                          data: (user) {
                            if (user != null) {
                              return Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text("Hello,",
                                      style: GoogleFonts.poppins(
                                          fontSize: 20, color: Colors.white70)),
                                  Text(user.name,
                                      style: GoogleFonts.poppins(
                                          fontSize: 32,
                                          fontWeight: FontWeight.bold,
                                          color: Colors.white)),
                                ],
                              );
                            } else {
                              return _buildFallbackHeader();
                            }
                          },
                          loading: () => _buildFallbackHeader(),
                          error: (_, __) => _buildFallbackHeader(),
                        ),
                      ),
                      CircleAvatar(
                        radius: 28,
                        backgroundColor: Colors.white24,
                        backgroundImage: FirebaseAuth.instance.currentUser?.photoURL != null
                            ? NetworkImage(FirebaseAuth.instance.currentUser!.photoURL!)
                            : null,
                        child: FirebaseAuth.instance.currentUser?.photoURL == null
                            ? const Icon(Icons.person, size: 36, color: Colors.white)
                            : null,
                      ),
                    ],
                  ),
                  const SizedBox(height: 30),
                  // Streak & Coins
                  userAsync.when(
                    data: (user) {
                      if (user != null) {
                        return Row(
                          children: [
                            Expanded(child: _streakCard(user.streak)),
                            const SizedBox(width: 16),
                            Expanded(child: _coinsCard(user.coins)),
                          ],
                        );
                      } else {
                        return _buildFallbackStats();
                      }
                    },
                    loading: () => _buildFallbackStats(),
                    error: (_, __) => _buildFallbackStats(),
                  ),
                  const SizedBox(height: 30),
                  // Continue Learning Section â€“ NOW LOCKED TO BACKEND PROGRESS
                  _buildContinueLearningSection(),
                  const SizedBox(height: 20),
                  _dailyChallengeCard(),
                  const SizedBox(height: 20),
                  _quickActions(),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFallbackHeader() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text("Hello,",
            style: GoogleFonts.poppins(fontSize: 20, color: Colors.white70)),
        Text("PrepKing Warrior",
            style: GoogleFonts.poppins(
                fontSize: 32,
                fontWeight: FontWeight.bold,
                color: Colors.white)),
      ],
    );
  }

  Widget _buildFallbackStats() {
    return Row(
      children: [
        Expanded(child: _streakCard(7)),
        const SizedBox(width: 16),
        Expanded(child: _coinsCard(1250)),
      ],
    );
  }

  Widget _streakCard(int streak) => FadeInLeft(
    child: Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.2),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.white24),
      ),
      child: Column(
        children: [
          Lottie.asset('assets/lottie/fire.json',
              controller: _fireController,
              onLoaded: (c) {
                _fireController
                  ..duration = c.duration
                  ..repeat();
              },
              height: 60),
          Text("$streak Day Streak",
              style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: Colors.white)),
          Text("Keep burning!",
              style: GoogleFonts.poppins(fontSize: 12, color: Colors.white70)),
        ],
      ),
    ),
  );

  Widget _coinsCard(int coins) => FadeInRight(
    child: Container(
      padding: const EdgeInsets.all(20),
      decoration: const BoxDecoration(
        gradient: LinearGradient(colors: [Colors.amber, Colors.orange]),
        borderRadius: BorderRadius.all(Radius.circular(20)),
      ),
      child: Column(
        children: [
          Lottie.asset('assets/lottie/coin.json', height: 60),
          Text(coins.toString(),
              style: GoogleFonts.poppins(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: Colors.white)),
          Text("Coins",
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.white)),
        ],
      ),
    ),
  );

  Widget _dailyChallengeCard() => FadeInUp(
    delay: const Duration(milliseconds: 200),
    child: Container(
      padding: const EdgeInsets.all(24),
      decoration: const BoxDecoration(
        gradient: LinearGradient(colors: [Colors.pinkAccent, Colors.purple]),
        borderRadius: BorderRadius.all(Radius.circular(24)),
      ),
      child: Row(
        children: [
          Lottie.asset('assets/lottie/daily.json', width: 100),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text("Daily Challenge",
                    style: GoogleFonts.poppins(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        color: Colors.white)),
                Text("Current Affairs Quiz",
                    style: GoogleFonts.poppins(fontSize: 16, color: Colors.white)),
                const SizedBox(height: 12),
                ElevatedButton(
                  onPressed: () => context.push('/quizzes/daily'),
                  style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.white,
                      foregroundColor: Colors.purple),
                  child: const Text("Start Now"),
                ),
              ],
            ),
          ),
        ],
      ),
    ),
  );

  Widget _quickActions() => FadeInUp(
    delay: const Duration(milliseconds: 400),
    child: GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: 2,
      mainAxisSpacing: 16,
      crossAxisSpacing: 16,
      childAspectRatio: 1.6,
      children: [
        _quickAction("Practice", Icons.menu_book, Colors.blue),
        _quickAction("Mock Test", Icons.timer, Colors.green),
        _quickAction("Leaderboard", Icons.emoji_events, Colors.orange),
        _quickAction("Certificates", Icons.card_membership, Colors.purple),
      ],
    ),
  );

  Widget _quickAction(String title, IconData icon, Color color) => Container(
    decoration: BoxDecoration(
      color: color.withOpacity(0.1),
      borderRadius: BorderRadius.circular(20),
      border: Border.all(color: color.withOpacity(0.3)),
    ),
    child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(icon, size: 48, color: color),
        const SizedBox(height: 12),
        Text(title,
            style: GoogleFonts.poppins(
                fontSize: 16, fontWeight: FontWeight.w600, color: color)),
      ],
    ),
  );

  // ==================== CONTINUE LEARNING SECTION (NOW ACCURATE) ====================
  Widget _buildContinueLearningSection() {
    final userAsync = ref.watch(currentUserProvider);
    return userAsync.when(
      data: (user) {
        if (user == null) return const SizedBox.shrink();
        final progressAsync = ref.watch(continueLearningProvider(user.id));
        return progressAsync.when(
          loading: () => _continueSkeleton(),
          error: (_, __) => const SizedBox.shrink(),
          data: (courses) {
            if (courses.isEmpty) return const SizedBox.shrink();
            return Column(
              children: courses.map((item) => _continueCourseCard(item)).toList(),
            );
          },
        );
      },
      loading: () => _continueSkeleton(),
      error: (_, __) => const SizedBox.shrink(),
    );
  }

  Widget _continueCourseCard(Map<String, dynamic> item) => FadeInUp(
    child: GestureDetector(
        onTap: () {
          final courseId = item['course_id'] as int?;
          if (courseId != null && courseId > 0) {
            context.push('/courses/detail/$courseId');
          }
        },
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.all(24),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(24),
          boxShadow: const [
            BoxShadow(color: Colors.black12, blurRadius: 20),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "Continue Learning",
              style: GoogleFonts.poppins(
                fontSize: 18,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                ClipRRect(
                  borderRadius: BorderRadius.circular(16),
                  child: Image.network(
                    item['course_image'] ?? '',
                    width: 80,
                    height: 80,
                    fit: BoxFit.cover,
                    errorBuilder: (_, __, ___) => Container(
                      width: 80,
                      height: 80,
                      color: Colors.grey[300],
                      child: const Icon(Icons.menu_book, color: Colors.grey),
                    ),
                    loadingBuilder: (_, child, loadingProgress) {
                      if (loadingProgress == null) return child;
                      return Container(
                        width: 80,
                        height: 80,
                        color: Colors.grey[300],
                        child: const Center(
                            child: CircularProgressIndicator(strokeWidth: 2)),
                      );
                    },
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        item['title'] ?? 'Untitled Course',
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 8),
                      // FIXED: Use backend progress_percentage directly
                      LinearProgressIndicator(
                        value: (double.tryParse(
                            item['progress_percentage']?.toString() ?? '0') ??
                            0.0) /
                            100.0,
                        backgroundColor: Colors.grey[300],
                        valueColor:
                        const AlwaysStoppedAnimation(Color(0xFF6C5CE7)),
                        minHeight: 8,
                        borderRadius: BorderRadius.circular(4),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        "${(double.tryParse(item['progress_percentage']?.toString() ?? '0') ?? 0.0).toStringAsFixed(0)}% Complete",
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          fontWeight: FontWeight.w500,
                          color: const Color(0xFF6C5CE7),
                        ),
                      ),
                    ],
                  ),
                ),
                const Icon(
                  Icons.arrow_forward_ios,
                  color: Color(0xFF6C5CE7),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );

  Widget _continueSkeleton() => FadeInUp(
    child: Container(
      height: 160,
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.1),
        borderRadius: BorderRadius.circular(24),
      ),
    ),
  );
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\leaderboard\leaderboard_screen.dart =====

// lib/screens/leaderboard/leaderboard_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:animate_do/animate_do.dart';
import '../../providers/user_provider.dart';
import '../../core/services/api_service.dart';

class LeaderboardEntry {
  final int rank;
  final int userId;
  final String name;
  final String? profilePicture;
  final int score;
  final bool isCurrentUser;

  LeaderboardEntry({
    required this.rank,
    required this.userId,
    required this.name,
    this.profilePicture,
    required this.score,
    this.isCurrentUser = false,
  });
}

enum LeaderboardType { global, quiz, course }

// Providers remain unchanged
final currentUserIdProvider = FutureProvider<int?>((ref) async {
  final user = await ref.watch(currentUserProvider.future);
  return user?.id;
});

final globalLeaderboardProvider = FutureProvider<List<LeaderboardEntry>>((ref) async {
  final api = ref.read(apiProvider);
  final response = await api.get('/leaderboard');
  final data = (response['data'] as List<dynamic>?) ?? [];
  return data.asMap().entries.map((e) {
    final index = e.key;
    final item = e.value as Map<String, dynamic>;
    return LeaderboardEntry(
      rank: index + 1,
      userId: int.tryParse(item['id']?.toString() ?? '0') ?? 0,
      name: item['name']?.toString() ?? 'Anonymous',
      profilePicture: item['profile_picture'] as String?,
      score: int.tryParse(item['total_score']?.toString() ?? '0') ??
          int.tryParse(item['score']?.toString() ?? '0') ??
          0,
    );
  }).toList();
});

final personalLeaderboardProvider = FutureProvider.family<List<LeaderboardEntry>, LeaderboardType>((ref, type) async {
  final userId = await ref.watch(currentUserIdProvider.future);
  if (userId == null) return [];
  final api = ref.read(apiProvider);
  String path = '/leaderboard/$userId';
  if (type == LeaderboardType.quiz) path += '/quiz';
  if (type == LeaderboardType.course) path += '/course';
  final response = await api.get(path);
  final data = (response['data'] as List<dynamic>?) ?? [];
  return data.map((itemRaw) {
    final item = itemRaw as Map<String, dynamic>;
    final isCurrent = (int.tryParse(item['id']?.toString() ?? '0') ?? 0) == userId;
    return LeaderboardEntry(
      rank: int.tryParse(item['rank']?.toString() ?? '0') ?? 0,
      userId: int.tryParse(item['id']?.toString() ?? '0') ?? 0,
      name: item['name']?.toString() ?? 'Anonymous',
      profilePicture: item['profile_picture'] as String?,
      score: int.tryParse(item['score']?.toString() ?? '0') ??
          int.tryParse(item['total_score']?.toString() ?? '0') ??
          0,
      isCurrentUser: isCurrent,
    );
  }).toList();
});

class LeaderboardScreen extends ConsumerStatefulWidget {
  const LeaderboardScreen({super.key});

  @override
  ConsumerState<LeaderboardScreen> createState() => _LeaderboardScreenState();
}

class _LeaderboardScreenState extends ConsumerState<LeaderboardScreen>
    with TickerProviderStateMixin {
  late final TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final currentUserAsync = ref.watch(currentUserProvider);
    return Scaffold(
      body: SafeArea( // ðŸ‘ˆ ONLY CHANGE: Wrap in SafeArea
        child: Column(
          children: [
            // Gradient Header
            Container(
              width: double.infinity,
              padding: const EdgeInsets.only(top: 48, bottom: 24), // ðŸ‘ˆ ONLY CHANGE: Reduced padding
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  colors: [Color(0xFF6C5CE7), Color(0xFFa29bfe)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
              ),
              child: Column(
                children: [
                  FadeInDown(
                    child: const Icon(Icons.emoji_events_rounded, size: 90, color: Colors.amber),
                  ),
                  const SizedBox(height: 16),
                  FadeInUp(
                    child: const Text(
                      'Leaderboard',
                      style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold, color: Colors.white),
                    ),
                  ),
                  const SizedBox(height: 12),
                  currentUserAsync.when(
                    data: (user) => FadeIn(
                      child: Text(
                        user != null
                            ? 'Streak: ${user.streak} ðŸ”¥ â€¢ Coins: ${user.coins} ðŸª™'
                            : 'Log in to compete',
                        style: const TextStyle(fontSize: 16, color: Colors.white70),
                      ),
                    ),
                    loading: () => const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2),
                    ),
                    error: (_, __) => const Text('Stats unavailable', style: TextStyle(color: Colors.white70)),
                  ),
                ],
              ),
            ),
            // Tabs
            TabBar(
              controller: _tabController,
              labelColor: Theme.of(context).colorScheme.primary,
              unselectedLabelColor: Colors.grey,
              labelStyle: const TextStyle(fontWeight: FontWeight.bold),
              indicatorColor: Theme.of(context).colorScheme.primary,
              tabs: const [
                Tab(text: 'Global'),
                Tab(text: 'Quiz Masters'),
                Tab(text: 'Course Champions'),
              ],
            ),
            // Tab Views
            Expanded(
              child: TabBarView(
                controller: _tabController,
                children: [
                  _buildLeaderboardTab(globalLeaderboardProvider, false),
                  _buildLeaderboardTab(personalLeaderboardProvider(LeaderboardType.quiz), true),
                  _buildLeaderboardTab(personalLeaderboardProvider(LeaderboardType.course), true),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLeaderboardTab(
      ProviderListenable<AsyncValue<List<LeaderboardEntry>>> provider,
      bool highlightCurrentUser,
      ) {
    final asyncValue = ref.watch(provider);
    return asyncValue.when(
      data: (entries) => _buildList(entries, highlightCurrentUser, provider),
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.sentiment_dissatisfied, size: 64, color: Colors.grey),
              const SizedBox(height: 16),
              const Text('Failed to load leaderboard', style: TextStyle(fontSize: 18)),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                onPressed: () => ref.invalidate(provider as ProviderBase), // Safe cast
                icon: const Icon(Icons.refresh),
                label: const Text('Retry'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildList(
      List<LeaderboardEntry> entries,
      bool highlightCurrentUser,
      ProviderListenable<AsyncValue<List<LeaderboardEntry>>> provider,
      ) {
    if (entries.isEmpty) {
      return const Center(
        child: Text(
          'No rankings yet.\nBe the first! ðŸ†',
          textAlign: TextAlign.center,
          style: TextStyle(fontSize: 18, color: Colors.grey),
        ),
      );
    }
    return RefreshIndicator(
      onRefresh: () async {
        ref.invalidate(provider as ProviderBase);
      },
      child: ListView.builder(
        physics: const AlwaysScrollableScrollPhysics(),
        padding: const EdgeInsets.all(16),
        itemCount: entries.length,
        itemBuilder: (context, index) {
          final entry = entries[index];
          final isTop3 = entry.rank <= 3;
          return FadeInLeft(
            duration: Duration(milliseconds: 500 + index * 100),
            child: Card(
              margin: const EdgeInsets.symmetric(vertical: 8),
              elevation: entry.isCurrentUser ? 12 : 4,
              color: entry.isCurrentUser
                  ? Theme.of(context).colorScheme.primaryContainer.withOpacity(0.4)
                  : null,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
              child: ListTile(
                contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                leading: Stack(
                  children: [
                    CircleAvatar(
                      radius: 30,
                      backgroundImage: entry.profilePicture != null
                          ? NetworkImage(entry.profilePicture!)
                          : null,
                      backgroundColor: Theme.of(context).colorScheme.primaryContainer,
                      child: entry.profilePicture == null
                          ? Text(
                        entry.name.isNotEmpty ? entry.name[0].toUpperCase() : '?',
                        style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                      )
                          : null,
                    ),
                    if (isTop3)
                      Positioned(
                        right: -6,
                        bottom: -6,
                        child: Icon(
                          Icons.star_rounded,
                          size: 32,
                          color: entry.rank == 1
                              ? Colors.amber
                              : entry.rank == 2
                              ? Colors.grey.shade400
                              : const Color(0xFFCD7F32), // Bronze
                        ),
                      ),
                  ],
                ),
                title: Text(
                  entry.name,
                  style: TextStyle(
                    fontWeight: entry.isCurrentUser ? FontWeight.bold : FontWeight.w600,
                    fontSize: 16,
                  ),
                ),
                subtitle: entry.isCurrentUser
                    ? const Text('You', style: TextStyle(fontWeight: FontWeight.bold, color: Color(0xFF6C5CE7)))
                    : null,
                trailing: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Text(
                      '#${entry.rank}',
                      style: TextStyle(
                        fontSize: 28,
                        fontWeight: FontWeight.bold,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                    ),
                    Text(
                      '${entry.score} pts',
                      style: const TextStyle(fontSize: 14, color: Colors.grey),
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\about_prepking_screen.dart =====

// lib/screens/profile/about_prepking_screen.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:package_info_plus/package_info_plus.dart';

class AboutPrepKingScreen extends StatelessWidget {
  const AboutPrepKingScreen({super.key});

  Future<String> _getAppVersion() async {
    final PackageInfo packageInfo = await PackageInfo.fromPlatform();
    return '${packageInfo.version} (Build ${packageInfo.buildNumber})';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("About PrepKing"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      backgroundColor: const Color(0xFFF8FAFC),
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Center(
              child: Lottie.asset(
                'assets/lottie/splash.json',
                width: 140,
                height: 140,
                fit: BoxFit.contain,
                errorBuilder: (_, __, ___) => Image.asset(
                  'assets/images/logo.png',
                  width: 120,
                  height: 120,
                  errorBuilder: (_, __, ___) => const Icon(
                    Icons.school,
                    size: 100,
                    color: Color(0xFF6C5CE7),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 32),
            Text(
              "PrepKing",
              style: GoogleFonts.poppins(
                fontSize: 32,
                fontWeight: FontWeight.bold,
                color: const Color(0xFF2D3436),
              ),
            ),
            const SizedBox(height: 12),
            Text(
              "A modern learning platform built for students, by educators.",
              style: GoogleFonts.poppins(
                fontSize: 16,
                color: Colors.grey[700],
                height: 1.5,
              ),
            ),
            const SizedBox(height: 32),

            // Dynamic Version Info
            FutureBuilder<String>(
              future: _getAppVersion(),
              builder: (context, snapshot) {
                final versionText = snapshot.data ?? "1.0.0";
                return _buildInfoRow("Version", versionText);
              },
            ),
            _buildInfoRow("Made in", "India ðŸ‡®ðŸ‡³"),
            _buildInfoRow("Technology", "Flutter â€¢ Firebase â€¢ Riverpod"),

            const SizedBox(height: 40),
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: Colors.grey.shade200),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.info_outline,
                    color: Colors.grey[700],
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      "PrepKing is committed to providing a distraction-free, ad-free, and safe learning environment for students across India.",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        color: Colors.grey[700],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        children: [
          Text(
            "$label: ",
            style: GoogleFonts.poppins(
              fontWeight: FontWeight.w600,
              color: Colors.grey[700],
            ),
          ),
          Text(
            value,
            style: GoogleFonts.poppins(
              fontWeight: FontWeight.w500,
              color: const Color(0xFF2D3436),
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\certificates_screen.dart =====

// lib/screens/profile/certificates_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../../providers/user_provider.dart';
import '../../providers/certificate_provider.dart';

class CertificatesScreen extends ConsumerWidget {
  const CertificatesScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(currentUserProvider).value!;
    final certs = ref.watch(certificatesProvider(user.id));

    return Scaffold(
      appBar: AppBar(
        title: const Text("My Certificates"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
      ),
      body: certs.when(
        loading: () => const Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
        error: (_, __) => const Center(child: Text("Failed to load certificates")),
        data: (list) => list.isEmpty
            ? Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.workspace_premium, size: 80, color: Colors.grey),
              const SizedBox(height: 16),
              Text("No certificates yet", style: GoogleFonts.poppins(fontSize: 18)),
              const SizedBox(height: 8),
              Text("Complete courses to earn certificates!", style: TextStyle(color: Colors.grey)),
            ],
          ),
        )
            : ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: list.length,
          itemBuilder: (_, i) => Card(
            margin: const EdgeInsets.only(bottom: 12),
            child: ListTile(
              leading: const Icon(Icons.workspace_premium, color: Color(0xFF6C5CE7)),
              title: Text(list[i]['title'] ?? 'Certificate', style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
              subtitle: Text("Issued on: ${list[i]['issued_on'] ?? 'N/A'}", style: GoogleFonts.poppins(fontSize: 13)),
            ),
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\coin_store_screen.dart =====

// lib/screens/profile/coin_store_screen.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

class CoinStoreScreen extends StatelessWidget {
  const CoinStoreScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Coin Store"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      backgroundColor: const Color(0xFFF8FAFC),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Lottie.asset(
                'assets/lottie/coin.json',
                width: 160,
                height: 160,
                fit: BoxFit.contain,
                repeat: true,
              ),
              const SizedBox(height: 32),
              Text(
                "Coming Soon ðŸš€",
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  color: const Color(0xFF2D3436),
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              Text(
                "Earn coins by learning, completing quizzes, and climbing the leaderboard!",
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 40),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
                decoration: BoxDecoration(
                  color: Colors.grey[100],
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: Colors.grey.shade200),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(Icons.info_outline, color: Colors.grey[700]),
                    const SizedBox(width: 12),
                    Flexible(
                      child: Text(
                        "Coins can be used to unlock premium content, hints, and exclusive badges.",
                        style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\edit_profile_screen.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../../models/user_model.dart';
import '../../providers/user_provider.dart';
import '../../core/services/api_service.dart';

class EditProfileScreen extends ConsumerStatefulWidget {
  const EditProfileScreen({super.key});

  @override
  ConsumerState<EditProfileScreen> createState() => _EditProfileScreenState();
}

class _EditProfileScreenState extends ConsumerState<EditProfileScreen> {
  late TextEditingController nameCtrl;
  late TextEditingController mobileCtrl;
  bool saving = false;

  @override
  void initState() {
    super.initState();
    final user = ref.read(currentUserProvider).value!;
    nameCtrl = TextEditingController(text: user.name);
    mobileCtrl = TextEditingController(text: user.mobile ?? '');
  }

  Future<void> _save(UserModel user) async {
    setState(() => saving = true);
    try {
      final api = ref.read(apiServiceProvider);
      await api.put(
        '/user/${user.id}',
        {
          'name': nameCtrl.text.trim(),
          'mobile': mobileCtrl.text.trim(),
        },
      );
      ref.read(refreshUserDataProvider)();
      if (mounted) Navigator.pop(context);
    } catch (e) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text('Update failed: $e')));
    } finally {
      setState(() => saving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = ref.watch(currentUserProvider).value!;
    return Scaffold(
      appBar: AppBar(
        title: const Text("Edit Profile"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
      ),
      body: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            TextField(
              controller: nameCtrl,
              style: GoogleFonts.poppins(),
              decoration: InputDecoration(
                labelText: 'Name',
                labelStyle: GoogleFonts.poppins(),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: mobileCtrl,
              keyboardType: TextInputType.phone,
              style: GoogleFonts.poppins(),
              decoration: InputDecoration(
                labelText: 'Mobile',
                labelStyle: GoogleFonts.poppins(),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
              ),
            ),
            const Spacer(),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: saving ? null : () => _save(user),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF6C5CE7),
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
                child: saving
                    ? const CircularProgressIndicator(color: Colors.white)
                    : const Text("Save Changes", style: TextStyle(fontWeight: FontWeight.bold)),
              ),
            )
          ],
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\help_support_screen.dart =====

// lib/screens/profile/help_support_screen.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:url_launcher/url_launcher.dart';

class HelpSupportScreen extends StatelessWidget {
  const HelpSupportScreen({super.key});

  Future<void> _launchEmail() async {
    final Uri emailUri = Uri(
      scheme: 'mailto',
      path: 'support@prepking.in',
      queryParameters: const {'subject': 'PrepKing Support Request'},
    );

    if (await canLaunchUrl(emailUri)) {
      await launchUrl(emailUri);
    }
    // Removed context-dependent SnackBar to avoid 'Undefined name context' error
    // Failure is usually silent (no email app installed)
  }

  Future<void> _launchWhatsApp() async {
    const String phoneNumber = '6266072809'; // Indian number
    const String message = 'Hello PrepKing Support, I need help with...';
    final String encodedMessage = Uri.encodeComponent(message);

    final Uri whatsappUri = Uri.parse(
      'https://wa.me/$phoneNumber?text=$encodedMessage',
    );

    if (await canLaunchUrl(whatsappUri)) {
      await launchUrl(whatsappUri, mode: LaunchMode.externalApplication);
    } else {
      // Fallback to WhatsApp Web
      final Uri webUri = Uri.parse(
        'https://web.whatsapp.com/send?phone=$phoneNumber&text=$encodedMessage',
      );
      if (await canLaunchUrl(webUri)) {
        await launchUrl(webUri, mode: LaunchMode.externalApplication);
      }
      // Removed context-dependent SnackBar to avoid 'Undefined name context' error
      // Failure is handled gracefully
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Help & Support"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      backgroundColor: const Color(0xFFF8FAFC),
      body: Padding(
        padding: const EdgeInsets.all(20),
        child: ListView(
          children: [
            Center(
              child: Lottie.asset(
                'assets/lottie/help.json',
                width: 160,
                height: 160,
                fit: BoxFit.contain,
                errorBuilder: (_, __, ___) => const Icon(
                  Icons.help_outline,
                  size: 120,
                  color: Color(0xFF6C5CE7),
                ),
              ),
            ),
            const SizedBox(height: 32),

            // Email Support
            _buildSupportCard(
              icon: Icons.email_outlined,
              title: "Email Support",
              subtitle: "support@prepking.in",
              onTap: _launchEmail,
              accentColor: const Color(0xFF6C5CE7),
            ),
            const SizedBox(height: 16),

            // WhatsApp Support
            _buildSupportCard(
              icon: Icons.chat,
              title: "WhatsApp Support",
              subtitle: "+91 62660 72809",
              onTap: _launchWhatsApp,
              accentColor: const Color(0xFF25D366), // WhatsApp green
            ),
            const SizedBox(height: 16),

            // Frequently Asked Questions
            _buildSupportCard(
              icon: Icons.help_outline,
              title: "Frequently Asked Questions",
              subtitle: "Find answers to common questions",
              onTap: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text("FAQ section coming soon!")),
                );
              },
              accentColor: const Color(0xFF6C5CE7),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSupportCard({
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
    Color accentColor = const Color(0xFF6C5CE7),
  }) {
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: ListTile(
        leading: Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: accentColor.withOpacity(0.1),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Icon(icon, color: accentColor, size: 28),
        ),
        title: Text(
          title,
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600, fontSize: 16),
        ),
        subtitle: Text(
          subtitle,
          style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
        ),
        trailing: const Icon(Icons.arrow_forward_ios, color: Colors.grey, size: 18),
        onTap: onTap,
        contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 12),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\profile_screen.dart =====

// lib/screens/profile/profile_screen.dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:lottie/lottie.dart';
import '../../core/utils/user_preferences.dart';
import '../../models/user_model.dart';
import '../../providers/user_progress_merged_provider.dart';
import '../../providers/user_provider.dart';
import '../../widgets/profile_menu_tile.dart';

// Shared GoogleSignIn instance
final GoogleSignIn googleSignIn = GoogleSignIn();

class ProfileScreen extends ConsumerWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userAsync = ref.watch(currentUserProvider);

    return userAsync.when(
      loading: () => _buildLoadingScreen(),
      error: (err, stack) => _ProfileError(
        onRetry: () => ref.invalidate(currentUserProvider),
      ),
      data: (user) {
        if (user == null) {
          return _NotLoggedInView();
        }
        return _ProfileContent(
          user: user,
          onLogout: () => _showLogoutDialog(context, ref),
        );
      },
    );
  }

  Widget _buildLoadingScreen() {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset('assets/lottie/loading.json', width: 100, height: 100),
            const SizedBox(height: 16),
            Text(
              'Loading your profile...',
              style: GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _showLogoutDialog(BuildContext context, WidgetRef ref) async {
    final shouldLogout = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text("Logout", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: Text(
          "Are you sure you want to logout?\nYour progress is saved.",
          style: GoogleFonts.poppins(),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext, false),
            child: Text("Cancel", style: GoogleFonts.poppins(color: Colors.grey[700])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),
            onPressed: () => Navigator.pop(dialogContext, true),
            child: Text("Logout", style: GoogleFonts.poppins(color: Colors.white)),
          ),
        ],
      ),
    );

    if (shouldLogout != true || !context.mounted) return;

    try {
      // Firebase sign-out
      await FirebaseAuth.instance.signOut();

      // Google sign-out (if applicable)
      try {
        if (await googleSignIn.isSignedIn()) {
          await googleSignIn.signOut();
        }
      } catch (e) {
        debugPrint("Google sign out error: $e");
      }

      // Clear local prefs
      await UserPreferences().clearAll();

      // Invalidate providers
      ref.read(refreshUserDataProvider)();
      ref.invalidate(currentUserProvider);
      ref.invalidate(userWithProgressProvider);

      // Navigate to login
      if (context.mounted) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (context.mounted) {
            context.go('/login');
          }
        });
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Logout failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}

// â”€â”€â”€ Error State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _ProfileError extends StatelessWidget {
  final VoidCallback onRetry;
  const _ProfileError({required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text("Failed to load profile", style: GoogleFonts.poppins()),
            TextButton(
              onPressed: onRetry,
              child: const Text("Retry"),
            ),
          ],
        ),
      ),
    );
  }
}

// â”€â”€â”€ Not Logged In State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _NotLoggedInView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings_outlined, color: Colors.grey),
            onPressed: () => context.push('/profile/settings'),
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text("No user logged in", style: GoogleFonts.poppins(fontSize: 18)),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () => context.go('/login'),
              child: Text("Go to Login", style: GoogleFonts.poppins()),
            ),
          ],
        ),
      ),
    );
  }
}

// â”€â”€â”€ Main Profile Content â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _ProfileContent extends StatelessWidget {
  final UserModel user;
  final VoidCallback onLogout;

  const _ProfileContent({
    required this.user,
    required this.onLogout,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings_outlined, color: Colors.grey),
            onPressed: () => context.push('/profile/settings'),
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () async {
          final ref = ProviderScope.containerOf(context, listen: false);
          ref.invalidate(currentUserProvider);
          ref.invalidate(userWithProgressProvider);
        },
        child: ListView(
          padding: const EdgeInsets.only(bottom: 40),
          children: [
            // â”€â”€â”€ Profile Header â”€â”€â”€
            Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                children: [
                  CircleAvatar(
                    radius: 64,
                    backgroundColor: Colors.grey.shade200,
                    backgroundImage: user.profilePicture != null
                        ? CachedNetworkImageProvider(user.profilePicture!)
                        : (FirebaseAuth.instance.currentUser?.photoURL != null
                        ? CachedNetworkImageProvider(FirebaseAuth.instance.currentUser!.photoURL!)
                        : null),
                    child: (user.profilePicture == null &&
                        FirebaseAuth.instance.currentUser?.photoURL == null)
                        ? const Icon(Icons.person, size: 80, color: Colors.grey)
                        : null,
                  ),
                  const SizedBox(height: 20),
                  Text(
                    user.name,
                    style: GoogleFonts.poppins(
                      fontSize: 28,
                      fontWeight: FontWeight.bold,
                      color: const Color(0xFF2D3436),
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 6),
                  Text(
                    user.email,
                    style: GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
                  ),
                  if (user.mobile != null && user.mobile!.isNotEmpty) ...[
                    const SizedBox(height: 4),
                    Text(
                      user.mobile!,
                      style: GoogleFonts.poppins(fontSize: 15, color: Colors.grey[500]),
                    ),
                  ],
                  const SizedBox(height: 32),
                  // â”€â”€â”€ Stats Row â”€â”€â”€
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      _buildStat("${user.coins}", "Coins", 'assets/lottie/coin.json'),
                      _buildStat("${user.streak}", "Day Streak", 'assets/lottie/fire.json'),
                      _buildStat("0", "Certificates", 'assets/lottie/trophy.json'),
                    ],
                  ),
                ],
              ),
            ),
            const SizedBox(height: 20),
            // â”€â”€â”€ Menu Section â”€â”€â”€
            Container(
              margin: const EdgeInsets.symmetric(horizontal: 20),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.05),
                    blurRadius: 15,
                    offset: const Offset(0, 5),
                  ),
                ],
              ),
              child: Column(
                children: [
                  ProfileMenuTile(
                    icon: Icons.person_outline,
                    title: "Edit Profile",
                    onTap: () => context.push('/profile/edit'),
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.card_membership_outlined,
                    title: "My Certificates",
                    trailing: const Icon(Icons.chevron_right),
                    onTap: () => context.push('/profile/certificates'),
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.history,
                    title: "Quiz History",
                    trailing: const Icon(Icons.chevron_right),
                    onTap: () => context.push('/profile/history'),
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.emoji_events_outlined,
                    title: "Leaderboard Rank",
                    trailing: Text(
                      "#--",
                      style: GoogleFonts.poppins(fontWeight: FontWeight.w600, color: const Color(0xFF6C5CE7)),
                    ),
                    onTap: () => context.go('/leaderboard'),
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.wallet,
                    title: "Coin Store",
                    trailing: const Icon(Icons.chevron_right),
                    onTap: () => context.push('/profile/coins'), // â† Changed
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.help_outline,
                    title: "Help & Support",
                    trailing: const Icon(Icons.chevron_right), // Added trailing for consistency
                    onTap: () => context.push('/profile/help'), // â† Changed
                  ),
                  const Divider(height: 1),
                  ProfileMenuTile(
                    icon: Icons.info_outline,
                    title: "About PrepKing",
                    trailing: const Icon(Icons.chevron_right), // Added trailing for consistency
                    onTap: () => context.push('/profile/about'), // â† Changed
                  ),
                ],
              ),
            ),
            const SizedBox(height: 40),
            // â”€â”€â”€ Logout Button â”€â”€â”€
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 40),
              child: OutlinedButton(
                style: OutlinedButton.styleFrom(
                  foregroundColor: Colors.redAccent,
                  side: const BorderSide(color: Colors.redAccent),
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                ),
                onPressed: onLogout,
                child: Text(
                  "Logout",
                  style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w600),
                ),
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }

  static Widget _buildStat(String value, String label, String lottieAsset) {
    return Column(
      children: [
        Lottie.asset(lottieAsset, height: 60, fit: BoxFit.contain),
        const SizedBox(height: 8),
        Text(
          value,
          style: GoogleFonts.poppins(
            fontSize: 26,
            fontWeight: FontWeight.bold,
            color: const Color(0xFF2D3436),
          ),
        ),
        Text(
          label,
          style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
        ),
      ],
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\quiz_history_screen.dart =====

// lib/screens/profile/quiz_history_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart';
import '../../providers/user_provider.dart';
import '../../providers/quiz_history_provider.dart';

class QuizHistoryScreen extends ConsumerWidget {
  const QuizHistoryScreen({super.key});

  String _formatDate(String? dateStr) {
    if (dateStr == null || dateStr.isEmpty) return 'Unknown Date';
    try {
      final date = DateTime.parse(dateStr.split(' ').first);
      return DateFormat('dd MMM yyyy').format(date);
    } catch (e) {
      return dateStr.split(' ').first;
    }
  }

  Color _getStatusColor(String status) {
    switch (status) {
      case 'completed':
        return Colors.green;
      case 'in_progress':
        return Colors.orange;
      default:
        return Colors.grey;
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(currentUserProvider).value!;
    final historyAsync = ref.watch(quizHistoryProvider(user.id));

    return Scaffold(
      appBar: AppBar(
        title: const Text("Quiz History"),
        backgroundColor: const Color(0xFF6C5CE7),
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      backgroundColor: const Color(0xFFF8FAFC),
      body: historyAsync.when(
        loading: () => const Center(
          child: CircularProgressIndicator(color: Color(0xFF6C5CE7)),
        ),
        error: (_, __) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text(
                "Failed to load history",
                style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.w600),
              ),
              const SizedBox(height: 8),
              ElevatedButton(
                onPressed: () => ref.refresh(quizHistoryProvider(user.id)),
                child: const Text("Retry"),
              ),
            ],
          ),
        ),
        data: (list) => list.isEmpty
            ? Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.history, size: 80, color: Colors.grey[400]),
              const SizedBox(height: 24),
              Text(
                "No quiz attempts yet",
                style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.w600, color: Colors.grey[700]),
              ),
              const SizedBox(height: 12),
              Text(
                "Your completed and in-progress quizzes will appear here",
                style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        )
            : ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: list.length,
          itemBuilder: (context, i) {
            final attempt = list[i];
            final isCompleted = attempt['status'] == 'completed';

            return Card(
              elevation: 4,
              margin: const EdgeInsets.only(bottom: 12),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              child: InkWell(
                borderRadius: BorderRadius.circular(16),
                onTap: isCompleted
                    ? () {
                  context.push('/quiz-review', extra: {
                    'attemptId': attempt['id'],
                    'testName': attempt['quiz_title'],
                  });
                }
                    : null,
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Container(
                            padding: const EdgeInsets.all(8),
                            decoration: BoxDecoration(
                              color: _getStatusColor(attempt['status']).withOpacity(0.1),
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Icon(
                              isCompleted ? Icons.check_circle : Icons.timer,
                              color: _getStatusColor(attempt['status']),
                              size: 28,
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  attempt['quiz_title'] ?? 'Untitled Quiz',
                                  style: GoogleFonts.poppins(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  _formatDate(attempt['display_date']),
                                  style: GoogleFonts.poppins(
                                    fontSize: 13,
                                    color: Colors.grey[600],
                                  ),
                                ),
                              ],
                            ),
                          ),
                          if (isCompleted)
                            Icon(Icons.arrow_forward_ios, color: Colors.grey[400], size: 18),
                        ],
                      ),
                      const SizedBox(height: 12),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          _buildInfoChip(
                            label: "Score",
                            value: attempt['display_score'],
                            icon: Icons.bar_chart,
                            color: isCompleted ? Colors.blue : Colors.grey,
                          ),
                          _buildInfoChip(
                            label: "Status",
                            value: attempt['status'] == 'completed' ? 'Completed' : 'In Progress',
                            icon: isCompleted ? Icons.done_all : Icons.pending,
                            color: _getStatusColor(attempt['status']),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildInfoChip({
    required String label,
    required String value,
    required IconData icon,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: color),
          const SizedBox(width: 6),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: GoogleFonts.poppins(fontSize: 11, color: Colors.grey[600]),
              ),
              Text(
                value,
                style: GoogleFonts.poppins(fontSize: 13, fontWeight: FontWeight.w600, color: color),
              ),
            ],
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\profile\settings_screen.dart =====

// lib/screens/profile/settings_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:url_launcher/url_launcher.dart';

import '../../core/constants/api_constants.dart';
import '../../core/services/api_service.dart';
import '../../providers/user_provider.dart';
import '../../providers/course_providers.dart'; // Assumes quizzesProvider is defined here
import '../../widgets/language_select_dialog.dart';
import '../../widgets/exam_select_dialog.dart';
import '../quizzes/quizzes_screen.dart';

class SettingsScreen extends ConsumerStatefulWidget {
  const SettingsScreen({super.key});

  @override
  ConsumerState<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends ConsumerState<SettingsScreen> {
  bool _isLoading = false;
  bool? _localNotificationValue;

  Future<void> _updateUserSettings(Map<String, dynamic> updates) async {
    if (_isLoading) return;
    setState(() => _isLoading = true);

    try {
      final userAsync = ref.watch(currentUserProvider);
      final user = userAsync.value;
      if (user == null) throw Exception('User not logged in');

      final api = ref.read(apiServiceProvider);

      final Map<String, dynamic> payload = {};
      if (updates.containsKey('notifications_enabled')) {
        payload['isNotificationEnabled'] = updates['notifications_enabled'] ? 1 : 0;
      }
      if (updates.containsKey('theme')) {
        payload['theme'] = updates['theme'] == 'dark' ? 'Dark' : 'Light';
      }

      final response = await api.put('/user/${user.id}', payload);

      if (response['success'] == true) {
        ref.invalidate(currentUserProvider); // Refresh user data
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Settings updated successfully'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        throw Exception(response['message'] ?? 'Update failed');
      }
    } catch (e) {
      debugPrint('Settings update error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to update settings: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _launchPrivacyPolicy() async {
    final url = Uri.parse(ApiConstants.privacyUrl);
    if (await canLaunchUrl(url)) {
      await launchUrl(url, mode: LaunchMode.externalApplication);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Could not open privacy policy')),
      );
    }
  }

  // Launch Delete Account Request Form
  Future<void> _launchDeleteAccountForm() async {
    const String deleteFormUrl =
        'https://docs.google.com/forms/d/e/1FAIpQLSfSqN3qrvPYhXWYR09bY-rOlxk9AOWVCTcnynX-kpKpTWJFsA/viewform?usp=header';
    final url = Uri.parse(deleteFormUrl);
    if (await canLaunchUrl(url)) {
      await launchUrl(url, mode: LaunchMode.externalApplication);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Could not open delete account form')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final userAsync = ref.watch(currentUserProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text('Settings', style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        backgroundColor: Colors.transparent,
        elevation: 0,
      ),
      body: userAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (err, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text('Error loading settings: $err'),
            ],
          ),
        ),
        data: (user) {
          if (user == null) {
            return const Center(child: Text('User not logged in'));
          }

          return Stack(
            children: [
              ListView(
                padding: const EdgeInsets.all(16),
                children: [
                  // â”€â”€â”€ Notifications â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: SwitchListTile(
                      title: Text(
                        'Enable Notifications',
                        style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w500),
                      ),
                      subtitle: Text(
                        'Receive quiz reminders and updates',
                        style: GoogleFonts.poppins(color: Colors.grey[600]),
                      ),
                      value: _localNotificationValue ?? user.notificationsEnabled,
                      onChanged: _isLoading
                          ? null
                          : (bool value) async {
                        setState(() => _localNotificationValue = value);
                        await _updateUserSettings({'notifications_enabled': value});
                        _localNotificationValue = null;
                      },
                      activeColor: const Color(0xFF6C5CE7),
                    ),
                  ),
                  const SizedBox(height: 12),

                  // â”€â”€â”€ Theme â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: ListTile(
                      title: Text(
                        'Theme',
                        style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w500),
                      ),
                      subtitle: Text(
                        'Choose your preferred appearance',
                        style: GoogleFonts.poppins(color: Colors.grey[600]),
                      ),
                      trailing: DropdownButton<String>(
                        value: user.theme.toLowerCase(),
                        underline: const SizedBox(),
                        items: const [
                          DropdownMenuItem(value: 'light', child: Text('Light')),
                          DropdownMenuItem(value: 'dark', child: Text('Dark')),
                        ],
                        onChanged: _isLoading
                            ? null
                            : (String? value) {
                          if (value != null) {
                            _updateUserSettings({'theme': value});
                          }
                        },
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),

                  // â”€â”€â”€ Privacy Policy â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: ListTile(
                      leading: const Icon(Icons.policy, color: Color(0xFF6C5CE7)),
                      title: Text(
                        'Privacy Policy',
                        style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w500),
                      ),
                      trailing: const Icon(Icons.open_in_new),
                      onTap: _launchPrivacyPolicy,
                    ),
                  ),
                  const SizedBox(height: 12),

                  // â”€â”€â”€ Select Language â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: ListTile(
                      leading: const Icon(Icons.language, color: Color(0xFF6C5CE7)),
                      title: Text(
                        'Select Language',
                        style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w500),
                      ),
                      trailing: const Icon(Icons.chevron_right),
                      onTap: () async {
                        final result = await showLanguageSelectDialog(context);
                        if (result == true) {
                          ref.invalidate(currentUserProvider);
                          ref.invalidate(courseListProvider);
                          ref.invalidate(quizzesProvider);
                        }
                      },
                    ),
                  ),
                  const SizedBox(height: 12),

                  // â”€â”€â”€ Select Exams â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: ListTile(
                      leading: const Icon(Icons.school, color: Color(0xFF6C5CE7)),
                      title: Text(
                        'Select Exams',
                        style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w500),
                      ),
                      subtitle: Text(
                        'Choose up to 4 exams you are preparing for',
                        style: GoogleFonts.poppins(color: Colors.grey[600]),
                      ),
                      trailing: const Icon(Icons.chevron_right),
                      onTap: () async {
                        final result = await showExamSelectDialog(context);
                        if (result == true) {
                          ref.invalidate(currentUserProvider);
                          ref.invalidate(courseListProvider);
                          ref.invalidate(quizzesProvider);
                        }
                      },
                    ),
                  ),
                  const SizedBox(height: 30),

                  // â”€â”€â”€ Delete Account â”€â”€â”€
                  Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    child: ListTile(
                      leading: const Icon(Icons.delete_forever, color: Colors.red),
                      title: Text(
                        'Delete Account',
                        style: GoogleFonts.poppins(
                          fontSize: 16,
                          fontWeight: FontWeight.w500,
                          color: Colors.red,
                        ),
                      ),
                      subtitle: Text(
                        'Permanently delete your account and all data',
                        style: GoogleFonts.poppins(color: Colors.grey[600]),
                      ),
                      trailing: const Icon(Icons.chevron_right, color: Colors.red),
                      onTap: () async {
                        final confirmed = await showDialog<bool>(
                          context: context,
                          builder: (ctx) => AlertDialog(
                            title: const Text('Delete Account?'),
                            content: const Text(
                              'This action is permanent and cannot be undone.\n'
                                  'All your progress, quizzes, and personal data will be deleted.',
                            ),
                            actions: [
                              TextButton(
                                onPressed: () => Navigator.pop(ctx, false),
                                child: const Text('Cancel'),
                              ),
                              TextButton(
                                onPressed: () => Navigator.pop(ctx, true),
                                child: const Text('Delete', style: TextStyle(color: Colors.red)),
                              ),
                            ],
                          ),
                        );

                        if (confirmed == true) {
                          await _launchDeleteAccountForm();
                        }
                      },
                    ),
                  ),
                  const SizedBox(height: 20),
                ],
              ),

              // Loading Overlay
              if (_isLoading)
                Container(
                  color: Colors.black26,
                  child: const Center(
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF6C5CE7)),
                    ),
                  ),
                ),
            ],
          );
        },
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\daily_quizzes_screen.dart =====

// lib/screens/quizzes/daily_quizzes_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

import '../../core/services/api_service.dart';
import '../../core/utils/user_preferences.dart'; // â† NEW IMPORT

/// Provider for fetching Daily Quizzes
/// Endpoint: https://quizard.in/api_002.php/saved_quiz?type=quiz_daily
final dailyQuizzesProvider = FutureProvider<List<dynamic>>((ref) async {
  final api = ref.read(apiServiceProvider);
  final response = await api.get('/saved_quiz', query: {'type': 'quiz_daily'});
  if (response is Map<String, dynamic> &&
      response['success'] == true &&
      response['data'] is List) {
    return List<dynamic>.from(response['data']);
  }
  return [];
});

class DailyQuizzesScreen extends ConsumerStatefulWidget {
  const DailyQuizzesScreen({super.key});

  @override
  ConsumerState<DailyQuizzesScreen> createState() => _DailyQuizzesScreenState();
}

class _DailyQuizzesScreenState extends ConsumerState<DailyQuizzesScreen> {
  bool _isPrefsReady = false;
  bool _isLoadingPrefs = true;

  @override
  void initState() {
    super.initState();
    _checkPreferences();
  }

  Future<void> _checkPreferences() async {
    final prefs = UserPreferences();
    final ready = await prefs.isPreferencesReady();

    if (mounted) {
      setState(() {
        _isPrefsReady = ready;
        _isLoadingPrefs = false;
      });
    }
  }

  // UI when Language & Exams are not selected
  Widget _buildMissingPrefsView() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.settings, size: 80, color: const Color(0xFF6C5CE7)),
            const SizedBox(height: 24),
            Text(
              'Please Select Language and Exams',
              style: GoogleFonts.poppins(
                fontSize: 22,
                fontWeight: FontWeight.bold,
                color: Colors.grey[800],
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            Text(
              'Go to Settings under Profile to set your Language and Exams.',
              style: GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              icon: const Icon(Icons.settings, color: Colors.white),
              label: Text(
                'Go to Settings',
                style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w600),
              ),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF6C5CE7),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
              ),
              onPressed: () {
                context.push('/profile/settings').then((_) {
                  // Re-check preferences when returning from settings
                  _checkPreferences();
                });
              },
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // Show loading while checking preferences
    if (_isLoadingPrefs) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(color: Color(0xFF6C5CE7)),
        ),
      );
    }

    // If preferences not ready â†’ show message
    if (!_isPrefsReady) {
      return Scaffold(
        appBar: AppBar(
          backgroundColor: const Color(0xFF6C5CE7),
          title: Text('Daily Quizzes', style: GoogleFonts.poppins(color: Colors.white, fontWeight: FontWeight.bold)),
          elevation: 0,
        ),
        body: _buildMissingPrefsView(),
        floatingActionButton: FloatingActionButton(
          backgroundColor: const Color(0xFF6C5CE7),
          onPressed: _checkPreferences,
          child: const Icon(Icons.refresh, color: Colors.white),
        ),
      );
    }

    // Preferences ready â†’ normal daily quizzes list
    final quizzesAsync = ref.watch(dailyQuizzesProvider);

    return Scaffold(
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            expandedHeight: 150,
            flexibleSpace: FlexibleSpaceBar(
              title: Text(
                "Daily Quizzes",
                style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
              ),
              background: Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    colors: [Color(0xFF6C5CE7), Color(0xFF4A3CB7)],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                ),
              ),
            ),
            pinned: true,
          ),
          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: quizzesAsync.when(
              loading: () => const SliverToBoxAdapter(
                child: Center(
                  child: CircularProgressIndicator(color: Color(0xFF6C5CE7)),
                ),
              ),
              error: (error, stack) => SliverToBoxAdapter(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.wifi_off, size: 64, color: Colors.grey),
                      const SizedBox(height: 16),
                      Text(
                        "No internet connection",
                        style: GoogleFonts.poppins(fontSize: 18),
                      ),
                      const SizedBox(height: 8),
                      TextButton(
                        onPressed: () => ref.refresh(dailyQuizzesProvider),
                        child: const Text("Retry"),
                      ),
                    ],
                  ),
                ),
              ),
              data: (quizzes) {
                if (quizzes.isEmpty) {
                  return SliverToBoxAdapter(
                    child: Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Lottie.asset(
                            'assets/lottie/empty.json',
                            width: 200,
                            errorBuilder: (context, error, stack) {
                              return const Icon(Icons.folder_open,
                                  size: 80, color: Colors.grey);
                            },
                          ),
                          const SizedBox(height: 20),
                          Text(
                            "No daily quiz available today",
                            style: GoogleFonts.poppins(fontSize: 18),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            "Check back tomorrow!",
                            style: GoogleFonts.poppins(
                                fontSize: 14, color: Colors.grey[600]),
                          ),
                        ],
                      ),
                    ),
                  );
                }
                return SliverList(
                  delegate: SliverChildBuilderDelegate(
                        (context, index) {
                      final quiz = quizzes[index];
                      // âœ… Robust Instant Quiz Detection (for list UI only)
                      final bool isInstant = () {
                        final value = quiz['isInstantQuiz'] ?? quiz['instantquiz'];
                        if (value is bool) return value;
                        if (value is int && value == 1) return true;
                        if (value is String &&
                            (value == "1" || value.toLowerCase() == "true")) {
                          return true;
                        }
                        final type = quiz['type']?.toString().trim();
                        return type == 'quiz_daily';
                      }();
                      // Safe difficulty handling
                      final String difficultyText = () {
                        final raw = quiz['difficulty'];
                        if (raw == null) return "Medium";
                        final diff = raw.toString().trim();
                        if (diff.isEmpty || diff.toLowerCase() == "null") {
                          return "Medium";
                        }
                        if (diff.length == 1) return diff.toUpperCase();
                        return diff[0].toUpperCase() +
                            diff.substring(1).toLowerCase();
                      }();
                      return Container(
                        margin: const EdgeInsets.only(bottom: 16),
                        child: Card(
                          elevation: 6,
                          shape: const RoundedRectangleBorder(
                            borderRadius: BorderRadius.all(Radius.circular(20)),
                          ),
                          child: InkWell(
                            borderRadius: const BorderRadius.all(Radius.circular(20)),
                            // ðŸ”¥ KEY FIX: Normalize quiz object BEFORE navigation
                            onTap: () {
                              final Map<String, dynamic> normalizedQuiz = {
                                ...quiz,
                                'isInstantQuiz': 1, // Force instant behavior
                                'instantquiz': 1, // Backward compatibility
                                // 'type' remains 'quiz_daily' if needed elsewhere
                              };
                              context.push('/quizzes/detail', extra: normalizedQuiz);
                            },
                            child: Padding(
                              padding: const EdgeInsets.all(20),
                              child: Row(
                                children: [
                                  Container(
                                    padding: const EdgeInsets.all(16),
                                    decoration: BoxDecoration(
                                      gradient: LinearGradient(
                                        colors: isInstant
                                            ? [Colors.pinkAccent, Colors.purple]
                                            : [const Color(0xFF6C5CE7), const Color(0xFF4A3CB7)],
                                      ),
                                      borderRadius: const BorderRadius.all(Radius.circular(16)),
                                    ),
                                    child: Lottie.asset(
                                      isInstant ? 'assets/lottie/lightning.json' : 'assets/lottie/quiz.json',
                                      width: 60,
                                      errorBuilder: (context, error, stack) {
                                        return Icon(
                                          isInstant ? Icons.flash_on : Icons.quiz_rounded,
                                          size: 40,
                                          color: Colors.white,
                                        );
                                      },
                                    ),
                                  ),
                                  const SizedBox(width: 16),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment: CrossAxisAlignment.start,
                                      children: [
                                        Text(
                                          quiz['quiz_title'] ?? "Daily Quiz",
                                          style: GoogleFonts.poppins(
                                              fontSize: 18,
                                              fontWeight: FontWeight.bold),
                                          maxLines: 2,
                                          overflow: TextOverflow.ellipsis,
                                        ),
                                        const SizedBox(height: 8),
                                        Row(
                                          children: [
                                            const Icon(Icons.timer,
                                                size: 16,
                                                color: Colors.grey),
                                            const SizedBox(width: 4),
                                            Text(
                                              "${quiz['duration_minutes'] ?? 30} mins",
                                              style: GoogleFonts.poppins(fontSize: 14),
                                            ),
                                            const SizedBox(width: 16),
                                            const Icon(Icons.bar_chart,
                                                size: 16,
                                                color: Colors.grey),
                                            const SizedBox(width: 4),
                                            Text(
                                              difficultyText,
                                              style: GoogleFonts.poppins(
                                                  fontSize: 14,
                                                  fontWeight: FontWeight.w600),
                                            ),
                                          ],
                                        ),
                                        if (isInstant) ...[
                                          const SizedBox(height: 8),
                                          Container(
                                            padding: const EdgeInsets.symmetric(
                                                horizontal: 12, vertical: 6),
                                            decoration: BoxDecoration(
                                              color: Colors.pink.withOpacity(0.2),
                                              borderRadius: const BorderRadius.all(Radius.circular(20)),
                                            ),
                                            child: Text(
                                              "Instant Quiz",
                                              style: GoogleFonts.poppins(
                                                color: Colors.pink,
                                                fontWeight: FontWeight.w600,
                                                fontSize: 13,
                                              ),
                                            ),
                                          ),
                                        ],
                                      ],
                                    ),
                                  ),
                                  const Icon(Icons.arrow_forward_ios,
                                      color: Colors.grey),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                    childCount: quizzes.length,
                  ),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        backgroundColor: const Color(0xFF6C5CE7),
        onPressed: () {
          _checkPreferences(); // Re-check prefs on refresh
          ref.invalidate(dailyQuizzesProvider);
        },
        child: const Icon(Icons.refresh_rounded, color: Colors.white),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\instant_quiz_player_screen.dart =====

// lib/screens/quizzes/instant_quiz_player_screen.dart
import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:vibration/vibration.dart';
import 'dart:developer' as developer;
import '../../core/services/api_service.dart';
import '../../providers/user_provider.dart';

/// âœ… UNIVERSAL SAFE INT PARSER - PREVENTS ALL TYPE ERRORS
int safeIntParse(dynamic value, {String? context, required int defaultValue}) {
  if (value == null) {
    developer.log('âŒ NULL VALUE ERROR | Context: $context | Using default: $defaultValue');
    return defaultValue;
  }
  if (value is int) {
    developer.log('âœ… INT VALUE OK | Context: $context | Value: $value');
    return value;
  }
  if (value is String) {
    final parsed = int.tryParse(value);
    if (parsed != null) {
      developer.log('âœ… STRINGâ†’INT SUCCESS | Context: $context | "$value" â†’ $parsed');
      return parsed;
    } else {
      developer.log('âŒ INVALID STRING ERROR | Context: $context | "$value" â†’ Using default: $defaultValue');
      return defaultValue;
    }
  }
  developer.log('âŒ TYPE MISMATCH ERROR | Context: $context | Type: ${value.runtimeType} | Value: $value â†’ Using default: $defaultValue');
  return defaultValue;
}

class InstantQuizPlayerScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> quiz;
  final int attemptId;
  const InstantQuizPlayerScreen({
    super.key,
    required this.quiz,
    required this.attemptId,
  });

  @override
  ConsumerState<InstantQuizPlayerScreen> createState() => _InstantQuizPlayerScreenState();
}

class _InstantQuizPlayerScreenState extends ConsumerState<InstantQuizPlayerScreen>
    with TickerProviderStateMixin {
  // Timer & Quiz State
  late Timer _timer;
  int _remainingSeconds = 0;
  int _currentIndex = 0;
  int _score = 0;
  List<Map<String, dynamic>> _questions = [];
  List<String?> _selectedAnswers = [];
  List<bool?> _answerResults = [];
  bool _isLoading = true;
  bool _isSubmitting = false;
  bool _isResuming = false;

  // UI State - INSTANT QUIZ SPECIFIC
  bool _isAnswered = false;
  bool _isLocked = false;
  bool _showFeedback = false;
  String? _correctAnswer;
  String? _userAnswer;
  bool _isTransitioning = false;

  // Instant Quiz Touch State
  bool _isTouchState = false;
  String? _touchedOption;

  // Animation Controllers
  late AnimationController _questionController;
  late AnimationController _optionsController;
  late AnimationController _feedbackController;
  late AnimationController _timerController;
  late AnimationController _shakeController;
  late AnimationController _exitController;
  late AnimationController _touchController;

  // Animations
  late Animation<Offset> _questionSlideAnimation;
  late Animation<double> _optionsFadeAnimation;
  late Animation<double> _feedbackScaleAnimation;
  late Animation<double> _timerAnimation;
  late Animation<double> _shakeAnimation;
  late Animation<Offset> _exitSlideAnimation;

  // Question Progress
  List<bool> _visitedQuestions = [];
  List<bool> _answeredQuestions = [];

  // â­ COLORS FROM CODE 2 (DARK THEME)
  final Color _primaryColor = const Color(0xFF6C5CE7);
  final Color _touchColor = const Color(0xFF8B78FF);
  final Color _correctColor = const Color(0xFF4CAF50);
  final Color _wrongColor = const Color(0xFFF44336);
  final Color _dullColor = Colors.grey.withOpacity(0.7);
  final Color _timerPausedColor = Colors.grey;

  final int _perQuestionTime = 30;

  /// âœ… SAFE QUIZ ID EXTRACTION
  int get _quizId {
    return safeIntParse(
        widget.quiz['id'],
        context: 'InstantQuizPlayerScreen._quizId',
        defaultValue: 0
    );
  }

  @override
  void initState() {
    super.initState();
    developer.log('ðŸ” Validating attemptId: ${widget.attemptId} (Type: ${widget.attemptId.runtimeType})');
    if (widget.attemptId <= 0) {
      developer.log('âŒ CRITICAL ERROR: Invalid attemptId: ${widget.attemptId}');
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('âŒ Invalid quiz attempt. Please start a new quiz.'),
              backgroundColor: Colors.red,
              duration: Duration(seconds: 4),
            ),
          );
          context.pop();
        }
      });
      return;
    }
    developer.log('âœ… Valid attemptId confirmed: ${widget.attemptId}');
    _initializeAnimations();
    _loadAttemptAndQuestions();
  }

  /// âœ… PERFECT API 0-3 â†’ UI 1-4 CONVERSION
  int convertCorrectAnswer(dynamic value) {
    final v = safeIntParse(value, context: 'convertCorrectAnswer', defaultValue: -1);
    if (v >= 0 && v <= 3) {
      final converted = v + 1;
      developer.log('ðŸ”¥ CONVERSION: API $v â†’ UI $converted');
      return converted;
    }
    developer.log('âš ï¸ Invalid correct_answer: $value â†’ Using -1');
    return -1;
  }

  /// âœ… COMPLETE QUESTION NORMALIZATION WITH ERROR HANDLING
  Map<String, dynamic> normalizeQuestion(Map<String, dynamic> q) {
    try {
      return {
        'id': safeIntParse(q['id'], context: 'Question ID', defaultValue: 0),
        'quiz_id': safeIntParse(q['quiz_id'], context: 'Question Quiz ID', defaultValue: 0),
        'question': q['question']?.toString() ?? "Question unavailable",
        'option1': q['option1']?.toString() ?? "",
        'option2': q['option2']?.toString() ?? "",
        'option3': q['option3']?.toString() ?? "",
        'option4': q['option4']?.toString() ?? "",
        'correct_answer': convertCorrectAnswer(q['correct_answer']),
        'order': safeIntParse(q['order'], context: 'Question Order', defaultValue: 0),
      };
    } catch (e, stackTrace) {
      developer.log('âŒ Question normalization error: $e\nStack: $stackTrace');
      return {
        'id': 0,
        'quiz_id': 0,
        'question': 'Question unavailable due to data error',
        'option1': '',
        'option2': '',
        'option3': '',
        'option4': '',
        'correct_answer': -1,
        'order': 0,
      };
    }
  }

  /// âœ… SAFE CORRECT ANSWER GETTER
  int _getCorrectAnswer(Map<String, dynamic> question) {
    final ans = question['correct_answer'];
    final correctInt = safeIntParse(ans, context: 'getCorrectAnswer', defaultValue: -1);
    if (correctInt >= 1 && correctInt <= 4) {
      return correctInt;
    }
    developer.log('âš ï¸ Invalid correct_answer in question ${question['id']}: $ans');
    return -1;
  }

  /// âœ… COMPLETE LOAD WITH MAXIMUM ERROR PROTECTION
  Future<void> _loadAttemptAndQuestions() async {
    try {
      developer.log('ðŸš€ Loading quiz ${_quizId} with attempt ${widget.attemptId}');
      final api = ref.read(apiServiceProvider);
      final questionsResponse = await api.get('/saved_question/quiz/$_quizId');
      if (questionsResponse['success'] != true) {
        throw Exception('Failed to load questions: ${questionsResponse['message'] ?? 'Unknown error'}');
      }
      final List<dynamic> questionsData = questionsResponse['data'] ?? [];
      developer.log('ðŸ“š Raw questions loaded: ${questionsData.length}');

      final questions = <Map<String, dynamic>>[];
      for (int i = 0; i < questionsData.length; i++) {
        try {
          final rawQuestion = questionsData[i] as Map<String, dynamic>;
          final normalized = normalizeQuestion(rawQuestion);
          if (normalized['id'] > 0 &&
              normalized['correct_answer'] >= 1 &&
              normalized['correct_answer'] <= 4 &&
              [normalized['option1'], normalized['option2'], normalized['option3'], normalized['option4']]
                  .where((o) => o.isNotEmpty).length >= 2) {
            questions.add(normalized);
          } else {
            developer.log('âš ï¸ Skipping invalid question ${normalized['id']}');
          }
        } catch (e) {
          developer.log('âŒ Failed to normalize question $i: $e');
        }
      }
      if (questions.isEmpty) {
        throw Exception('No valid questions found after processing');
      }
      developer.log('âœ… Loaded ${questions.length} VALID normalized questions');

      Map<String, dynamic>? attempt;
      try {
        final attemptResponse = await api.get('/quiz_attempt/${widget.attemptId}');
        if (attemptResponse['success'] == true) {
          attempt = attemptResponse['data'];
          developer.log('âœ… Attempt details loaded: ${attempt?['id']}');
        }
      } catch (e) {
        developer.log('âš ï¸ Could not load attempt details: $e');
      }

      if (!mounted) return;

      setState(() {
        _questions = questions;
        _selectedAnswers = List.filled(questions.length, null);
        _answerResults = List.filled(questions.length, null);
        _visitedQuestions = List.filled(questions.length, false);
        _answeredQuestions = List.filled(questions.length, false);
        _isLoading = false;
      });

      if (_questions.isEmpty) {
        throw Exception('No questions available after processing');
      }

      if (attempt != null && attempt['status']?.toString() == 'in_progress') {
        await _resumeAttempt(attempt);
      } else {
        setState(() {
          _currentIndex = 0;
          _visitedQuestions[0] = true;
        });
        _startQuestionAnimations();
        _startPerQuestionTimer();
        developer.log('ðŸŽ¯ New attempt started at question 1');
      }
    } catch (e, stackTrace) {
      developer.log("âŒ LOAD ATTEMPT ERROR: $e\nSTACK: $stackTrace");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error_outline, color: Colors.white),
              const SizedBox(width: 8),
              Expanded(child: Text('Failed to load quiz: ${e.toString()}')),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 5),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
        ),
      );
      setState(() => _isLoading = false);
    }
  }

  /// âœ… RESUME ATTEMPT WITH SAFE INDEXING
  Future<void> _resumeAttempt(Map<String, dynamic> attempt) async {
    try {
      setState(() => _isResuming = true);
      final currentQuestionIndex = safeIntParse(
          attempt['current_question_index'],
          context: 'Resume current_question_index',
          defaultValue: 0
      );
      final score = safeIntParse(
          attempt['obtained_marks'],
          context: 'Resume obtained_marks',
          defaultValue: 0
      );
      developer.log('ðŸ”„ Resuming attempt ${widget.attemptId} at question $currentQuestionIndex');
      developer.log('ðŸ“Š Current score: $score');

      await _loadAttemptReviewAnswers(widget.attemptId);

      if (!mounted) return;
      final clampedIndex = currentQuestionIndex.clamp(0, _questions.length - 1);
      setState(() {
        _currentIndex = clampedIndex;
        _score = score;
        _visitedQuestions[_currentIndex] = true;
        _answeredQuestions[_currentIndex] = _selectedAnswers[_currentIndex] != null;
        _isAnswered = _answeredQuestions[_currentIndex];
        _isLocked = _isAnswered;
        _isResuming = false;
      });

      if (mounted) {
        _showResumeSnackBar(clampedIndex + 1, _questions.length, _score);
      }

      _startQuestionAnimations();
      if (!_isAnswered) {
        _startPerQuestionTimer();
      }
    } catch (e, stackTrace) {
      developer.log('âŒ Resume attempt error: $e\nStack: $stackTrace');
      setState(() => _isResuming = false);
      _startQuestionAnimations();
      _startPerQuestionTimer();
    }
  }

  /// âœ… LOAD PREVIOUS ANSWERS WITH SAFE INT COMPARISONS
  Future<void> _loadAttemptReviewAnswers(int attemptId) async {
    try {
      final api = ref.read(apiServiceProvider);
      final response = await api.get('/attempt_review', query: {
        'result_id': attemptId.toString(),
      });
      if (response['success'] == true) {
        final List<dynamic> reviews = response['data'] ?? [];
        int loadedCount = 0;
        for (var review in reviews) {
          try {
            final questionId = safeIntParse(
                review['question_id'],
                context: 'Review question_id',
                defaultValue: 0
            );
            if (questionId == 0) continue;
            final selectedOption = review['selected_option']?.toString();

            final questionIndex = _questions.indexWhere((q) {
              final qId = safeIntParse(q['id'], context: 'Question ID lookup', defaultValue: 0);
              return qId == questionId;
            });
            if (questionIndex == -1) {
              developer.log('âš ï¸ Question ID $questionId not found');
              continue;
            }

            _selectedAnswers[questionIndex] = selectedOption;
            _answeredQuestions[questionIndex] = true;
            _visitedQuestions[questionIndex] = true;

            final question = _questions[questionIndex];
            final correctInt = _getCorrectAnswer(question);
            final selectedInt = int.tryParse(selectedOption ?? '') ?? -1;
            final isCorrect = selectedInt == correctInt;
            _answerResults[questionIndex] = isCorrect;
            if (isCorrect) _score += 10;
            loadedCount++;
          } catch (e) {
            developer.log('âŒ Error processing review: $e');
          }
        }
        developer.log('âœ… Loaded $loadedCount previous answers with PERFECT INT matching');
      }
    } catch (e) {
      developer.log('âš ï¸ Could not load attempt reviews: $e');
    }
  }

  /// âœ… UPDATE ATTEMPT PROGRESS
  Future<void> _updateAttemptProgress() async {
    try {
      final api = ref.read(apiServiceProvider);
      final questionsData = <Map<String, dynamic>>[];
      for (int i = 0; i < _questions.length; i++) {
        questionsData.add({
          'question_index': i,
          'question_id': _questions[i]['id'],
          'selected_option': _selectedAnswers[i],
          'is_correct': _answerResults[i],
          'answered': _answeredQuestions[i],
        });
      }
      final timeSpent = (_perQuestionTime * _currentIndex + (_perQuestionTime - _remainingSeconds));
      await api.put('/quiz_attempt/${widget.attemptId}', {
        'current_question_index': _currentIndex.toString(),
        'questions_data': jsonEncode(questionsData),
        'time_spent_total': timeSpent.toString(),
        'obtained_marks': _score.toString(),
        'correct_answers': _answerResults.where((r) => r == true).length.toString(),
        'incorrect_answers': _answerResults.where((r) => r == false).length.toString(),
        'unanswered_questions': _questions.length - _answeredQuestions.where((a) => a).length,
        'status': _currentIndex < _questions.length - 1 ? 'in_progress' : 'completed',
      });
      developer.log('âœ… Progress saved: Q$_currentIndex | Score: $_score | Time: $timeSpent');
    } catch (e) {
      developer.log('âš ï¸ Failed to save progress: $e');
    }
  }

  void _initializeAnimations() {
    _questionController = AnimationController(duration: const Duration(milliseconds: 700), vsync: this);
    _optionsController = AnimationController(duration: const Duration(milliseconds: 500), vsync: this);
    _feedbackController = AnimationController(duration: const Duration(milliseconds: 300), vsync: this);
    _timerController = AnimationController(duration: Duration(seconds: _perQuestionTime), vsync: this);
    _shakeController = AnimationController(duration: const Duration(milliseconds: 500), vsync: this);
    _exitController = AnimationController(duration: const Duration(milliseconds: 400), vsync: this);
    _touchController = AnimationController(duration: const Duration(milliseconds: 300), vsync: this);

    _questionSlideAnimation = Tween<Offset>(begin: const Offset(0, 0.3), end: Offset.zero)
        .animate(CurvedAnimation(parent: _questionController, curve: Curves.easeOut));

    _optionsFadeAnimation = Tween<double>(begin: 0.0, end: 1.0)
        .animate(CurvedAnimation(parent: _optionsController, curve: Curves.easeIn));

    _feedbackScaleAnimation = Tween<double>(begin: 0.0, end: 1.0)
        .animate(CurvedAnimation(parent: _feedbackController, curve: Curves.elasticOut));

    _timerAnimation = Tween<double>(begin: 1.0, end: 0.0).animate(_timerController);

    _shakeAnimation = TweenSequence<double>([
      TweenSequenceItem(tween: Tween<double>(begin: 0, end: -10), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: -10, end: 10), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: 10, end: -10), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: -10, end: 10), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: 10, end: 0), weight: 1),
    ]).animate(_shakeController);

    _exitSlideAnimation = Tween<Offset>(begin: Offset.zero, end: const Offset(-1, 0))
        .animate(CurvedAnimation(parent: _exitController, curve: Curves.easeInOut));
  }

  void _startQuestionAnimations() {
    _questionController.forward().then((_) {
      Future.delayed(const Duration(milliseconds: 100), () {
        if (mounted) _optionsController.forward();
      });
    });
    _timerController.duration = Duration(seconds: _perQuestionTime);
    _timerController.forward(from: 0.0);
  }

  void _startPerQuestionTimer() {
    _remainingSeconds = _perQuestionTime;
    _timerController.reset();
    _timerController.duration = Duration(seconds: _perQuestionTime);
    _timerController.forward();
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) return;
      setState(() {
        if (_remainingSeconds > 0) {
          _remainingSeconds--;
          _timerController.value = _remainingSeconds / _perQuestionTime;
        } else {
          timer.cancel();
          _handleTimeOut();
        }
      });
    });
  }

  void _handleTimeOut() {
    if (!_isAnswered) {
      final question = _questions[_currentIndex];
      final correctInt = _getCorrectAnswer(question);
      setState(() {
        _isAnswered = true;
        _isLocked = true;
        _correctAnswer = correctInt.toString();
        _answerResults[_currentIndex] = false;
        _timerController.stop();
      });
      _saveAnswerToServer("", false);
      _showTimeOutFeedback();
      _updateAttemptProgress();
    }
  }

  void _selectAnswer(String selectedOption) {
    if (_isAnswered || _isLocked) return;
    final selectedInt = int.tryParse(selectedOption);
    if (selectedInt == null || selectedInt < 1 || selectedInt > 4) {
      developer.log("âŒ Invalid option selected: $selectedOption");
      return;
    }
    final question = _questions[_currentIndex];
    final correctInt = _getCorrectAnswer(question);
    final isCorrect = selectedInt == correctInt;

    setState(() {
      _touchedOption = selectedOption;
      _isTouchState = true;
      _selectedAnswers[_currentIndex] = selectedOption;
      _userAnswer = selectedOption;
      _correctAnswer = correctInt.toString();
    });
    _touchController.forward();

    _timer.cancel();
    _timerController.stop();

    Future.delayed(const Duration(milliseconds: 300), () {
      if (!mounted) return;
      setState(() {
        _isTouchState = false;
        _isAnswered = true;
        _isLocked = true;
        _answeredQuestions[_currentIndex] = true;
        _answerResults[_currentIndex] = isCorrect;
        if (isCorrect) _score += 10;
        _showFeedback = true;
      });
      _feedbackController.forward();
      _provideHapticFeedback(isCorrect);
      if (!isCorrect) {
        _shakeController.forward();
      }
      _saveAnswerToServer(selectedOption, isCorrect);
      _updateAttemptProgress();

      Future.delayed(const Duration(seconds: 2), () {
        if (mounted) _goToNextQuestion();
      });
    });
  }

  void _provideHapticFeedback(bool isCorrect) async {
    if (await Vibration.hasVibrator() ?? false) {
      if (!isCorrect) {
        Vibration.vibrate(duration: 200, amplitude: 100);
      } else {
        Vibration.vibrate(pattern: [0, 50, 50, 50]);
      }
    }
  }

  void _showTimeOutFeedback() {
    setState(() => _showFeedback = true);
    _feedbackController.forward();
    Future.delayed(const Duration(seconds: 2), () {
      if (mounted) _goToNextQuestion();
    });
  }

  void _goToNextQuestion() {
    _updateAttemptProgress();
    if (_currentIndex < _questions.length - 1) {
      setState(() => _isTransitioning = true);
      _exitController.forward().then((_) {
        _questionController.reset();
        _optionsController.reset();
        _feedbackController.reset();
        _exitController.reset();
        _shakeController.reset();
        _touchController.reset();
        if (!mounted) return;
        setState(() {
          _currentIndex++;
          _isAnswered = _selectedAnswers[_currentIndex] != null;
          _isLocked = _isAnswered;
          _showFeedback = false;
          _isTransitioning = false;
          _isTouchState = false;
          _touchedOption = null;
          _userAnswer = null;
          _correctAnswer = null;
          _visitedQuestions[_currentIndex] = true;
        });
        _startQuestionAnimations();
        if (!_isAnswered) {
          _startPerQuestionTimer();
        }
        developer.log('âž¡ï¸ Moved to question ${_currentIndex + 1}/${_questions.length}');
      });
    } else {
      developer.log('ðŸ All questions completed! Submitting...');
      _submitQuiz();
    }
  }

  /// âœ… BULLETPROOF SAVE ANSWER - USES PUT INSTEAD OF POST FOR EXISTING ATTEMPTS
  Future<void> _saveAnswerToServer(String selected, bool isCorrect) async {
    try {
      final user = ref.read(currentUserProvider).asData?.value;
      if (user?.id == null) {
        developer.log("âŒ User ID missing");
        return;
      }
      final question = _questions[_currentIndex];
      final questionId = safeIntParse(question['id'],
          context: 'Save question_id',
          defaultValue: 0
      );
      if (questionId == 0) {
        developer.log("âŒ Invalid question ID for saving");
        return;
      }
      final correctInt = _getCorrectAnswer(question);
      final selectedInt = int.tryParse(selected) ?? -1;

      final api = ref.read(apiServiceProvider);
      Map<String, dynamic>? existingAttempt;
      try {
        final attemptResponse = await api.get('/quiz_attempt/${widget.attemptId}');
        if (attemptResponse['success'] == true) {
          existingAttempt = attemptResponse['data'];
        }
      } catch (e) {
        developer.log("âš ï¸ Could not load existing attempt: $e");
      }

      List<Map<String, dynamic>> questionsData = [];
      if (existingAttempt != null && existingAttempt['questions_data'] != null) {
        try {
          if (existingAttempt['questions_data'] is String) {
            questionsData = List<Map<String, dynamic>>.from(
                jsonDecode(existingAttempt['questions_data'])
            );
          } else if (existingAttempt['questions_data'] is List) {
            questionsData = List<Map<String, dynamic>>.from(
                existingAttempt['questions_data']
            );
          }
        } catch (e) {
          developer.log("âš ï¸ Error parsing existing questions_data: $e");
        }
      }

      final questionIndex = questionsData.indexWhere(
              (q) => safeIntParse(q['question_id'],
              context: 'Find question_id',
              defaultValue: 0
          ) == questionId
      );

      final questionPayload = {
        'question_index': _currentIndex,
        'question_id': questionId,
        'selected_option': selectedInt >= 1 ? selectedInt.toString() : null,
        'is_correct': isCorrect,
        'answered': selectedInt >= 1,
        'correct_option': correctInt,
        'question_text': question['question'] ?? 'Question unavailable',
        'options_provided': [
          question['option1'] ?? '',
          question['option2'] ?? '',
          question['option3'] ?? '',
          question['option4'] ?? ''
        ],
        'time_spent': _perQuestionTime - _remainingSeconds,
      };

      if (questionIndex >= 0) {
        questionsData[questionIndex] = questionPayload;
      } else {
        questionsData.add(questionPayload);
      }

      final timeSpent = (_perQuestionTime * _currentIndex +
          (_perQuestionTime - _remainingSeconds));
      final updatePayload = {
        'current_question_index': _currentIndex,
        'questions_data': jsonEncode(questionsData),
        'time_spent_total': timeSpent,
        'obtained_marks': _score,
        'correct_answers': _answerResults.where((r) => r == true).length,
        'incorrect_answers': _answerResults.where((r) => r == false).length,
        'unanswered_questions': _questions.length -
            _answeredQuestions.where((a) => a).length,
        'status': _currentIndex < _questions.length - 1 ?
        'in_progress' : 'completed',
      };

      developer.log("ðŸ’¾ Updating attempt ${widget.attemptId} with: ${jsonEncode(updatePayload)}");

      final response = await api.put('/quiz_attempt/${widget.attemptId}', updatePayload);
      if (response['success'] == true) {
        developer.log("âœ… Answer saved successfully in attempt ${widget.attemptId}");
      } else {
        developer.log("âš ï¸ Update warning: ${response['message']}");
      }
    } catch (e, stackTrace) {
      developer.log("âŒ Save error: $e\nStack: $stackTrace");
    }
  }

  /// âœ… COMPLETE QUIZ SUBMISSION WITH CORRECT DATA TYPES
  Future<void> _submitQuiz() async {
    if (_isSubmitting) return;
    _isSubmitting = true;
    try {
      if (_timer.isActive) _timer.cancel();
      _timerController.stop();

      await _updateAttemptProgress();

      final user = ref.read(currentUserProvider).asData?.value;
      if (user?.id == null) throw Exception("User not found");

      final totalQuestions = _questions.length;
      final fullMarks = totalQuestions * 10;
      final totalTime = (_perQuestionTime * totalQuestions);

      final resultPayload = {
        'quiz_id': _quizId,
        'user_id': user!.id,
        'attempt_id': widget.attemptId,
        'score': _score,
        'full_marks': fullMarks,
        'time_taken': totalTime,
      };

      developer.log("ðŸ“¤ Submitting result: ${jsonEncode(resultPayload)}");
      final resultResponse = await ref.read(apiServiceProvider).post('/result', resultPayload);
      if (resultResponse['success'] != true) {
        throw Exception(resultResponse['message'] ?? 'Failed to create result');
      }

      final resultId = safeIntParse(
          resultResponse['id'] ?? resultResponse['data']?['id'],
          context: 'Submit result_id',
          defaultValue: 0
      );
      if (resultId == 0) {
        throw Exception('Invalid result ID returned from server');
      }

      await ref.read(apiServiceProvider).put('/quiz_attempt/${widget.attemptId}', {
        'status': 'completed',
        'completed_at': DateTime.now().toIso8601String(),
      });

      developer.log("ðŸŽ‰ QUIZ COMPLETED! Result ID: $resultId | Score: $_score/$fullMarks (${(_score / fullMarks * 100).toStringAsFixed(1)}%)");

      if (!mounted) return;
      context.go('/quizzes/result', extra: {
        'result_id': resultId,
        'attempt_id': widget.attemptId,
        'score': _score,
        'total_questions': totalQuestions,
        'total_marks': fullMarks,
        'quiz_title': widget.quiz['quiz_title'] ?? widget.quiz['title'],
        'percentage': (_score / fullMarks * 100).toStringAsFixed(1),
        'time_taken': totalTime,
        'passed': _score >= (fullMarks * 0.6),
        'slug': widget.quiz['slug']?.toString().trim().isNotEmpty == true
            ? widget.quiz['slug']
            : widget.quiz['id'].toString(),
      });
    } catch (e, stackTrace) {
      developer.log("âŒ Submit error: $e\nStack: $stackTrace");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error_outline, color: Colors.white),
              const SizedBox(width: 8),
              Expanded(child: Text('Submit failed: ${e.toString()}')),
            ],
          ),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 5),
          behavior: SnackBarBehavior.floating,
        ),
      );
      await _fallbackSubmit();
    } finally {
      _isSubmitting = false;
    }
  }

  /// âœ… FALLBACK: Alternative submission method
  Future<void> _fallbackSubmit() async {
    try {
      final user = ref.read(currentUserProvider).asData?.value;
      if (user?.id == null) return;
      final totalQuestions = _questions.length;
      final fullMarks = totalQuestions * 10;

      final altPayload = {
        'quiz_id': _quizId.toString(),
        'user_id': user!.id.toString(),
        'score': _score.toString(),
        'full_marks': fullMarks.toString(),
        'time_taken': (_perQuestionTime * totalQuestions).toString(),
        'completed_at': DateTime.now().toIso8601String(),
      };

      developer.log("ðŸ”„ Trying fallback submission: ${jsonEncode(altPayload)}");
      final response = await ref.read(apiServiceProvider).post('/result', altPayload);
      if (response['success'] == true) {
        final resultId = safeIntParse(
            response['id'],
            context: 'Fallback result_id',
            defaultValue: 0
        );
        if (resultId > 0 && mounted) {
          context.go('/quizzes/result', extra: {
            'result_id': resultId,
            'attempt_id': widget.attemptId,
            'score': _score,
            'total_questions': totalQuestions,
            'total_marks': fullMarks,
            'quiz_title': widget.quiz['quiz_title'] ?? widget.quiz['title'],
            'percentage': (_score / fullMarks * 100).toStringAsFixed(1),
            'time_taken': _perQuestionTime * totalQuestions,
            'passed': _score >= (fullMarks * 0.6),
            'slug': widget.quiz['slug']?.toString().trim().isNotEmpty == true
                ? widget.quiz['slug']
                : widget.quiz['id'].toString(),
          });
        }
      }
    } catch (e) {
      developer.log("âŒ Fallback submit also failed: $e");
    }
  }

  /// âœ… RESUME SNACKBAR
  void _showResumeSnackBar(int current, int total, int score) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.play_arrow, color: Colors.white),
            const SizedBox(width: 8),
            Text('Resumed from question $current/$total â€¢ Score: $score'),
          ],
        ),
        backgroundColor: Colors.orange,
        duration: const Duration(seconds: 3),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    );
  }

  Future<bool> _onWillPop() async {
    await _updateAttemptProgress();
    final shouldQuit = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text("Quit Quiz?", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: Text(
          "Your progress is saved. You can resume later from question ${_currentIndex + 1}!",
          style: GoogleFonts.poppins(),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text("Continue", style: GoogleFonts.poppins(color: Colors.grey[700])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),
            onPressed: () => Navigator.pop(context, true),
            child: Text("Quit", style: GoogleFonts.poppins(color: Colors.white)),
          ),
        ],
      ),
    );
    return shouldQuit ?? false;
  }

  // ==================== UI FROM CODE 2 ====================

  Widget _buildTopBar() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text('COINS\n0',
                  textAlign: TextAlign.center,
                  style: GoogleFonts.poppins(fontSize: 14, color: Colors.white70)),
              Stack(
                alignment: Alignment.center,
                children: [
                  SizedBox(
                    width: 80,
                    height: 80,
                    child: CircularProgressIndicator(
                      value: _timerAnimation.value.clamp(0.0, 1.0),
                      strokeWidth: 6,
                      backgroundColor: Colors.grey[800],
                      valueColor: AlwaysStoppedAnimation<Color>(
                        _isLocked
                            ? _timerPausedColor
                            : (_remainingSeconds < 10 ? Colors.red : _primaryColor),
                      ),
                    ),
                  ),
                  Text('$_remainingSeconds',
                      style: GoogleFonts.poppins(
                          fontSize: 24, fontWeight: FontWeight.bold, color: Colors.white)),
                ],
              ),
              Text('SCORE\n$_score',
                  textAlign: TextAlign.center,
                  style: GoogleFonts.poppins(fontSize: 14, color: Colors.white70)),
            ],
          ),
          const SizedBox(height: 8),
          Text('${_currentIndex + 1}/${_questions.length}',
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.white60)),
        ],
      ),
    );
  }

  Widget _buildOptionButton(int index, List<dynamic> options, int correctAnswer) {
    final optionLetter = (index + 1).toString();
    final optionText = options[index]?.toString() ?? '';
    final isTouched = _touchedOption == optionLetter && _isTouchState;
    final isSelected = _selectedAnswers[_currentIndex] == optionLetter;
    final isCorrectOption = (index + 1) == correctAnswer;

    Color backgroundColor() {
      if (_showFeedback) {
        if (isCorrectOption) return _correctColor;
        if (isSelected && !isCorrectOption) return _wrongColor;
        return Colors.grey[800]!.withOpacity(0.6);
      }
      if (isTouched) return _touchColor;
      return Colors.grey[800]!;
    }

    Color textColor() => (_showFeedback || isTouched) ? Colors.white : Colors.white;

    double opacity() => (_isTouchState && !isTouched) ? 0.7 : 1.0;

    Widget? trailingIcon() {
      if (!_showFeedback) return null;
      if (isCorrectOption) {
        return ScaleTransition(
            scale: _feedbackScaleAnimation,
            child: const Icon(Icons.check, color: Colors.white, size: 28));
      }
      if (isSelected && !isCorrectOption) {
        return ScaleTransition(
            scale: _feedbackScaleAnimation,
            child: const Icon(Icons.close, color: Colors.white, size: 28));
      }
      return null;
    }

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
      child: AnimatedBuilder(
        animation: Listenable.merge([_touchController, _feedbackController]),
        builder: (context, child) {
          final double touchScale = isTouched
              ? (1.0 + 0.03 * Curves.easeOut.transform(_touchController.value))
              : 1.0;
          return Transform.scale(
            scale: touchScale,
            child: Opacity(
              opacity: opacity(),
              child: Material(
                color: backgroundColor(),
                borderRadius: BorderRadius.circular(30),
                child: InkWell(
                  borderRadius: BorderRadius.circular(30),
                  onTap: _isLocked ? null : () => _selectAnswer(optionLetter),
                  child: Container(
                    padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
                    child: Row(
                      children: [
                        CircleAvatar(
                          radius: 18,
                          backgroundColor: textColor().withOpacity(0.3),
                          child: Text(optionLetter,
                              style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                            child: Text(optionText,
                                style: GoogleFonts.poppins(fontSize: 16, color: textColor()))),
                        if (trailingIcon() != null) ...[
                          const SizedBox(width: 8),
                          trailingIcon()!,
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading || _questions.isEmpty) {
      return Scaffold(
        backgroundColor: const Color(0xFF121212),
        body: Center(child: Lottie.asset('assets/lottie/loading.json')),
      );
    }

    final question = _questions[_currentIndex];
    final List<dynamic> options = ['1', '2', '3', '4']
        .map((i) => question['option$i'])
        .where((o) => o != null && o.toString().isNotEmpty)
        .toList();
    final correctAnswer = _getCorrectAnswer(question);

    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        backgroundColor: const Color(0xFF121212),
        body: SafeArea(
          child: Column(
            children: [
              _buildTopBar(),
              const SizedBox(height: 30),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                child: SlideTransition(
                  position: _questionSlideAnimation,
                  child: Card(
                    color: const Color(0xFF1E1E1E),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                    child: Padding(
                      padding: const EdgeInsets.all(24),
                      child: Text(
                        question['question'] ?? "Question unavailable",
                        style: GoogleFonts.poppins(
                            fontSize: 20, fontWeight: FontWeight.w600, color: Colors.white),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 40),
              Expanded(
                child: FadeTransition(
                  opacity: _optionsFadeAnimation,
                  child: ListView.builder(
                    itemCount: options.length,
                    itemBuilder: (context, index) => _buildOptionButton(index, options, correctAnswer),
                  ),
                ),
              ),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _updateAttemptProgress();
    _questionController.dispose();
    _optionsController.dispose();
    _feedbackController.dispose();
    _timerController.dispose();
    _shakeController.dispose();
    _exitController.dispose();
    _touchController.dispose();
    if (_timer.isActive) _timer.cancel();
    super.dispose();
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\quizzes_screen.dart =====

// lib/screens/quizzes/quizzes_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';

import '../../core/services/api_service.dart';
import '../../core/utils/user_preferences.dart'; // â† NEW IMPORT

// âœ… UPDATED quizzesProvider - CRASH PROOF
final quizzesProvider = FutureProvider<List<dynamic>>((ref) async {
  final api = ref.read(apiServiceProvider);
  final response = await api.get('/saved_quiz');
  if (response is Map && response['data'] is List) {
    return response['data'];
  }
  return [];
});

class QuizzesScreen extends ConsumerStatefulWidget {
  const QuizzesScreen({super.key});

  @override
  ConsumerState<QuizzesScreen> createState() => _QuizzesScreenState();
}

class _QuizzesScreenState extends ConsumerState<QuizzesScreen> {
  bool _isPrefsReady = false;
  bool _isLoadingPrefs = true;

  @override
  void initState() {
    super.initState();
    _checkPreferences();
  }

  Future<void> _checkPreferences() async {
    final prefs = UserPreferences();
    final ready = await prefs.isPreferencesReady();

    if (mounted) {
      setState(() {
        _isPrefsReady = ready;
        _isLoadingPrefs = false;
      });
    }
  }

  // UI when Language & Exams are not selected
  Widget _buildMissingPrefsView() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.settings, size: 80, color: const Color(0xFF6C5CE7)),
            const SizedBox(height: 24),
            Text(
              'Please Select Language and Exams',
              style: GoogleFonts.poppins(
                fontSize: 22,
                fontWeight: FontWeight.bold,
                color: Colors.grey[800],
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            Text(
              'Go to Settings under Profile to set your Language and Exams.',
              style: GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              icon: const Icon(Icons.settings, color: Colors.white),
              label: Text(
                'Go to Settings',
                style: GoogleFonts.poppins(fontSize: 16, fontWeight: FontWeight.w600),
              ),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF6C5CE7),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
              ),
              onPressed: () {
                context.push('/profile/settings').then((_) {
                  // Re-check preferences when returning from settings
                  _checkPreferences();
                });
              },
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // Show loading while checking preferences
    if (_isLoadingPrefs) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(color: Color(0xFF6C5CE7)),
        ),
      );
    }

    // If preferences not ready â†’ show message
    if (!_isPrefsReady) {
      return Scaffold(
        appBar: AppBar(
          backgroundColor: const Color(0xFF6C5CE7),
          title: Text('Quizzes', style: GoogleFonts.poppins(color: Colors.white, fontWeight: FontWeight.bold)),
          elevation: 0,
        ),
        body: _buildMissingPrefsView(),
        floatingActionButton: FloatingActionButton(
          backgroundColor: const Color(0xFF6C5CE7),
          onPressed: _checkPreferences,
          child: const Icon(Icons.refresh, color: Colors.white),
        ),
      );
    }

    // Preferences ready â†’ normal quizzes list
    final quizzesAsync = ref.watch(quizzesProvider);

    return Scaffold(
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            expandedHeight: 150,
            flexibleSpace: FlexibleSpaceBar(
              title: Text("Quizzes", style: GoogleFonts.poppins(fontWeight: FontWeight.bold)),
              background: Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    colors: [Color(0xFF6C5CE7), Color(0xFF4A3CB7)],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                ),
              ),
            ),
            pinned: true,
          ),
          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: quizzesAsync.when(
              loading: () => SliverToBoxAdapter(
                child: Center(child: CircularProgressIndicator(color: Color(0xFF6C5CE7))),
              ),
              error: (error, stack) => SliverToBoxAdapter(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.wifi_off, size: 64, color: Colors.grey),
                      const SizedBox(height: 16),
                      Text("No internet connection", style: GoogleFonts.poppins(fontSize: 18)),
                      const SizedBox(height: 8),
                      TextButton(
                        onPressed: () => ref.refresh(quizzesProvider),
                        child: const Text("Retry"),
                      ),
                    ],
                  ),
                ),
              ),
              data: (quizzes) {
                if (quizzes.isEmpty) {
                  return SliverToBoxAdapter(
                    child: Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Lottie.asset(
                            'assets/lottie/empty.json',
                            width: 200,
                            errorBuilder: (context, error, stack) {
                              return const Icon(Icons.folder_open, size: 80, color: Colors.grey);
                            },
                          ),
                          const SizedBox(height: 20),
                          Text("No quizzes available", style: GoogleFonts.poppins(fontSize: 18)),
                        ],
                      ),
                    ),
                  );
                }
                return SliverList(
                  delegate: SliverChildBuilderDelegate(
                        (context, index) {
                      final quiz = quizzes[index];
                      // âœ… FIX 2 â€” Safe isInstantQuiz parsing
                      final isInstant = quiz['isInstantQuiz']?.toString() == "1";
                      // âœ… FIX 1 â€” Crash-proof difficulty handling
                      final String difficultyText = () {
                        final raw = quiz['difficulty'];
                        if (raw == null) return "Easy";
                        final diff = raw.toString().trim();
                        if (diff.isEmpty || diff.toLowerCase() == "null") return "Easy";
                        if (diff.length == 1) return diff.toUpperCase();
                        return diff[0].toUpperCase() + diff.substring(1).toLowerCase();
                      }();
                      return Container(
                        margin: const EdgeInsets.only(bottom: 16),
                        child: Card(
                          elevation: 6,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                          child: InkWell(
                            borderRadius: BorderRadius.circular(20),
                            onTap: () {
                              debugPrint("Opening Quiz ID: ${quiz['id']} - ${quiz['quiz_title']}");
                              context.push('/quizzes/detail', extra: quiz);
                            },
                            child: Padding(
                              padding: const EdgeInsets.all(20),
                              child: Row(
                                children: [
                                  Container(
                                    padding: const EdgeInsets.all(16),
                                    decoration: BoxDecoration(
                                      gradient: LinearGradient(
                                        colors: isInstant
                                            ? [Colors.pinkAccent, Colors.purple]
                                            : [const Color(0xFF6C5CE7), const Color(0xFF4A3CB7)],
                                      ),
                                      borderRadius: BorderRadius.circular(16),
                                    ),
                                    child: Lottie.asset(
                                      isInstant ? 'assets/lottie/lightning.json' : 'assets/lottie/quiz.json',
                                      width: 60,
                                      errorBuilder: (context, error, stack) {
                                        return Icon(
                                            isInstant ? Icons.flash_on : Icons.quiz_rounded,
                                            size: 40,
                                            color: Colors.white
                                        );
                                      },
                                    ),
                                  ),
                                  const SizedBox(width: 16),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment: CrossAxisAlignment.start,
                                      children: [
                                        Text(
                                          quiz['quiz_title'] ?? "Untitled Quiz",
                                          style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.bold),
                                          maxLines: 2,
                                          overflow: TextOverflow.ellipsis,
                                        ),
                                        const SizedBox(height: 8),
                                        Row(
                                          children: [
                                            Icon(Icons.timer, size: 16, color: Colors.grey[600]),
                                            const SizedBox(width: 4),
                                            Text("${quiz['duration_minutes'] ?? 10} mins", style: GoogleFonts.poppins(fontSize: 14)),
                                            const SizedBox(width: 16),
                                            Icon(Icons.bar_chart, size: 16, color: Colors.grey[600]),
                                            const SizedBox(width: 4),
                                            Text(
                                              difficultyText,
                                              style: GoogleFonts.poppins(fontSize: 14, fontWeight: FontWeight.w600),
                                            ),
                                          ],
                                        ),
                                        if (quiz['notifyDate'] != null)
                                          Text(
                                            "Date: ${quiz['notifyDate']?.toString().trim().isEmpty ?? true ? "N/A" : quiz['notifyDate']}",
                                            style: GoogleFonts.poppins(fontSize: 12, color: Colors.grey),
                                          ),
                                        if (isInstant)
                                          Container(
                                            margin: const EdgeInsets.only(top: 8),
                                            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                                            decoration: BoxDecoration(
                                              color: Colors.pink.withOpacity(0.2),
                                              borderRadius: BorderRadius.circular(20),
                                            ),
                                            child: Text(
                                              "Instant Quiz",
                                              style: GoogleFonts.poppins(
                                                  color: Colors.pink,
                                                  fontWeight: FontWeight.w600,
                                                  fontSize: 13
                                              ),
                                            ),
                                          ),
                                      ],
                                    ),
                                  ),
                                  const Icon(Icons.arrow_forward_ios, color: Colors.grey),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                    childCount: quizzes.length,
                  ),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        backgroundColor: const Color(0xFF6C5CE7),
        onPressed: () {
          _checkPreferences(); // Re-check prefs on refresh
          ref.invalidate(quizzesProvider);
        },
        child: const Icon(Icons.refresh_rounded, color: Colors.white),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\quiz_detail_screen.dart =====

// lib/screens/quizzes/quiz_detail_screen.dart â€” UPDATED TO TREAT DAILY QUIZZES LIKE INSTANT QUIZZES
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:share_plus/share_plus.dart';
import 'dart:developer' as developer;
import '../../core/services/api_service.dart';
import '../../providers/user_provider.dart';
import '../../providers/quiz_attempts_provider.dart';

/// âœ… UNIVERSAL SAFE INT PARSER - PREVENTS ALL TYPE ERRORS
int safeIntParse(dynamic value, {String? context, required int defaultValue}) {
  if (value == null) {
    developer.log('âŒ NULL VALUE ERROR | Context: $context | Using default: $defaultValue');
    return defaultValue;
  }
  if (value is int) {
    developer.log('âœ… INT VALUE OK | Context: $context | Value: $value');
    return value;
  }
  if (value is String) {
    final parsed = int.tryParse(value);
    if (parsed != null) {
      developer.log('âœ… STRINGâ†’INT SUCCESS | Context: $context | "$value" â†’ $parsed');
      return parsed;
    } else {
      developer.log('âŒ INVALID STRING ERROR | Context: $context | "$value" â†’ Using default: $defaultValue');
      return defaultValue;
    }
  }
  developer.log('âŒ TYPE MISMATCH ERROR | Context: $context | Type: ${value.runtimeType} | Value: $value â†’ Using default: $defaultValue');
  return defaultValue;
}

class QuizDetailScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> quiz;
  const QuizDetailScreen({super.key, required this.quiz});

  @override
  ConsumerState<QuizDetailScreen> createState() => _QuizDetailScreenState();
}

class _QuizDetailScreenState extends ConsumerState<QuizDetailScreen> {
  bool isStarting = false;

  /// âœ… SAFE QUIZ ID EXTRACTION
  int get _quizId {
    return safeIntParse(
        widget.quiz['id'],
        context: 'QuizDetailScreen._quizId',
        defaultValue: 0
    );
  }

  /// âœ… UPDATED: Treat type=="quiz_daily" exactly like isInstantQuiz==1
  bool _isInstantQuiz(Map<String, dynamic> quiz) {
    // First check explicit instant flags
    final instantValue = quiz['isInstantQuiz'] ?? quiz['instantquiz'];
    if (instantValue != null) {
      if (instantValue is bool) return instantValue;
      if (instantValue is int) return instantValue == 1;
      if (instantValue is String) {
        return instantValue == "1" || instantValue.toLowerCase() == "true";
      }
    }

    // NEW: Daily quizzes (from type=quiz_daily endpoint) behave like instant quizzes
    final type = quiz['type']?.toString().trim();
    return type == "quiz_daily";
  }

  /// âœ… SAFE ATTEMPT NUMBER EXTRACTION
  int _safeGetAttemptNumber(Map<String, dynamic> attempt) {
    return safeIntParse(
        attempt['attempt_number'],
        context: 'Attempt #${attempt['id'] ?? 'unknown'} - attempt_number',
        defaultValue: 1
    );
  }

  /// âœ… SAFE ATTEMPT ID EXTRACTION
  int _safeGetAttemptId(Map<String, dynamic> attempt) {
    return safeIntParse(
        attempt['id'],
        context: 'Attempt ID extraction',
        defaultValue: 0
    );
  }

  Future<void> _startQuiz() async {
    if (isStarting) return;
    setState(() => isStarting = true);

    try {
      developer.log('ðŸš€ Starting quiz ID: $_quizId');

      if (_quizId == 0) {
        throw Exception("âŒ INVALID QUIZ ID: ${widget.quiz['id']} (Type: ${widget.quiz['id'].runtimeType})");
      }

      final userAsync = ref.read(currentUserProvider);
      final user = userAsync.asData?.value;
      if (user == null || user.id == 0) {
        throw Exception("Profile loading... Try again.");
      }

      final api = ref.read(apiServiceProvider);

      Map<String, dynamic>? latestAttempt;

      try {
        final latestAttemptAsync = ref.read(latestQuizAttemptProvider(_quizId));
        if (latestAttemptAsync.hasValue && latestAttemptAsync.value != null) {
          latestAttempt = latestAttemptAsync.value;
          developer.log('âœ… Provider found latest attempt: ${latestAttempt?['id']}');
        }
      } catch (e) {
        developer.log('âš ï¸ Provider error, trying manual fetch: $e');
      }

      if (latestAttempt == null) {
        try {
          developer.log('ðŸ” Manual attempt fetch for quiz $_quizId');
          final attemptsResponse = await api.get('/quiz_attempt', query: {
            'course_quiz_id': _quizId.toString(),
            'user_id': user.id.toString(),
          });
          if (attemptsResponse['success'] == true) {
            final attemptsData = attemptsResponse['data'] ?? [];
            final attempts = List<Map<String, dynamic>>.from(attemptsData);
            if (attempts.isNotEmpty) {
              latestAttempt = attempts.reduce((a, b) {
                final idA = _safeGetAttemptId(a);
                final idB = _safeGetAttemptId(b);
                return idA > idB ? a : b;
              });
              developer.log('âœ… Manual latest attempt found: ${_safeGetAttemptId(latestAttempt!)}');
            }
          }
        } catch (e) {
          developer.log('âš ï¸ Manual attempt fetch failed: $e');
        }
      }

      int attemptId;
      int nextAttemptNumber;

      if (latestAttempt != null) {
        final latestStatus = latestAttempt['status']?.toString() ?? '';
        if (latestStatus == 'in_progress') {
          attemptId = _safeGetAttemptId(latestAttempt);
          nextAttemptNumber = _safeGetAttemptNumber(latestAttempt);
          developer.log('ðŸ”„ RESUMING existing attempt: ID $attemptId (Attempt #$nextAttemptNumber)');
          if (mounted) {
            _showResumeSnackBar(nextAttemptNumber);
          }
        } else {
          developer.log('â„¹ï¸ Latest attempt completed (${latestStatus}), creating new one');
          latestAttempt = null;
        }
      }

      if (latestAttempt == null) {
        final List<Map<String, dynamic>> existingAttempts = [];
        try {
          final attemptsResponse = await api.get('/quiz_attempt', query: {
            'course_quiz_id': _quizId.toString(),
            'user_id': user.id.toString(),
          });
          if (attemptsResponse['success'] == true) {
            final attemptsData = attemptsResponse['data'] ?? [];
            existingAttempts.addAll(List<Map<String, dynamic>>.from(attemptsData));
            developer.log('ðŸ“Š Found ${existingAttempts.length} existing attempts');
          }
        } catch (e) {
          developer.log("âš ï¸ Could not fetch existing attempts: $e");
        }

        nextAttemptNumber = 1;
        if (existingAttempts.isNotEmpty) {
          try {
            final validAttemptNumbers = <int>[];
            for (var attempt in existingAttempts) {
              final attemptNum = _safeGetAttemptNumber(attempt);
              if (attemptNum > 0) {
                validAttemptNumbers.add(attemptNum);
              }
            }
            if (validAttemptNumbers.isNotEmpty) {
              nextAttemptNumber = validAttemptNumbers.reduce((a, b) => a > b ? a : b) + 1;
              developer.log('ðŸ“ˆ Next attempt calculated: $nextAttemptNumber');
            }
          } catch (e) {
            developer.log('âŒ Error calculating next attempt number: $e');
            nextAttemptNumber = 1;
          }
        }

        developer.log("ðŸ“Š Creating NEW attempt #$nextAttemptNumber for quiz $_quizId");
        final response = await api.post('/quiz_attempt', {
          'course_quiz_id': _quizId.toString(),
          'user_id': user.id.toString(),
          'attempt_number': nextAttemptNumber.toString(),
          'status': 'in_progress',
          'current_question_index': '0',
          'time_spent_total': '0',
          'score': '0.00',
          'total_marks': '0.00',
          'obtained_marks': '0.00',
          'correct_answers': '0',
          'incorrect_answers': '0',
          'unanswered_questions': '0',
          'questions_data': '[]',
        });

        if (response['success'] != true) {
          throw Exception('Failed to start quiz: ${response['message'] ?? 'Unknown error'}');
        }

        attemptId = safeIntParse(
            response['data']?['id'] ?? response['id'],
            context: 'New attempt ID from API response',
            defaultValue: 0
        );

        if (attemptId == 0) {
          throw Exception("âŒ NO VALID ATTEMPT ID RETURNED!");
        }

        developer.log("âœ… NEW ATTEMPT CREATED: ID $attemptId (Attempt #$nextAttemptNumber)");
      } else {
        attemptId = _safeGetAttemptId(latestAttempt!);
      }

      final isInstantQuiz = _isInstantQuiz(widget.quiz);
      if (!mounted) return;

      final routeData = {
        'quiz': widget.quiz,
        'attempt_id': attemptId,
      };

      developer.log('ðŸŽ¯ Navigating to ${isInstantQuiz ? "Instant" : "Standard"} Quiz Player with attempt ID: $attemptId');

      if (isInstantQuiz) {
        context.go('/quizzes/instant-player', extra: routeData);
      } else {
        context.go('/quizzes/standard-player', extra: routeData);
      }
    } catch (e, stackTrace) {
      developer.log("âŒ START QUIZ ERROR: $e\nSTACK TRACE:\n$stackTrace");
      if (!mounted) return;
      _showErrorSnackBar("Failed to start quiz: ${e.toString().split('\n').first}");
    } finally {
      if (mounted) {
        setState(() => isStarting = false);
      }
    }
  }

  void _showResumeSnackBar(int attemptNumber) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.play_arrow, color: Colors.white),
            const SizedBox(width: 8),
            Text('Resuming your previous attempt #$attemptNumber'),
          ],
        ),
        backgroundColor: Colors.orange,
        duration: const Duration(seconds: 2),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    );
  }

  void _showErrorSnackBar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.error_outline, color: Colors.white),
            const SizedBox(width: 8),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 4),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    );
  }

  void _shareQuiz() {
    try {
      final slug = widget.quiz['slug'] ?? widget.quiz['id'].toString();
      final shareUrl = "https://prepking.online/q/$slug";
      final title = widget.quiz['quiz_title'] ?? "Check out this quiz!";
      Share.share(
        "Hey! Try this amazing quiz on PrepKing:\n\n$title\n\n$shareUrl",
        subject: title,
      );
    } catch (e) {
      developer.log('âŒ Share error: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to share quiz'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Widget _buildAttemptHistory() {
    return Consumer(
      builder: (context, ref, child) {
        final attemptsAsync = ref.watch(quizAttemptsProvider(_quizId));
        return attemptsAsync.when(
          data: (attempts) {
            if (attempts.isEmpty) return const SizedBox.shrink();

            List<Map<String, dynamic>> sortedAttempts;
            try {
              sortedAttempts = List.from(attempts);
              sortedAttempts.sort((a, b) {
                final idA = safeIntParse(a['id'], context: 'History sort A', defaultValue: 0);
                final idB = safeIntParse(b['id'], context: 'History sort B', defaultValue: 0);
                return idB.compareTo(idA);
              });
            } catch (e) {
              developer.log('âŒ Attempt history sorting error: $e');
              sortedAttempts = List.from(attempts);
            }

            return Card(
              margin: const EdgeInsets.only(top: 16, bottom: 8),
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Icon(Icons.history, color: Color(0xFF6C5CE7)),
                        const SizedBox(width: 8),
                        Text(
                          'ðŸ“‹ Attempt History',
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.w600,
                            color: Colors.black87,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    ...sortedAttempts.take(5).map((attempt) {
                      try {
                        final status = attempt['status']?.toString() ?? 'unknown';
                        final attemptNum = _safeGetAttemptNumber(attempt);
                        final score = attempt['score']?.toString() ?? '0.00';
                        final startedAt = attempt['started_at']?.toString();

                        Color getStatusColor() {
                          if (status == 'in_progress') return Colors.orange;
                          if (score != '0.00') {
                            final scoreNum = double.tryParse(score);
                            if (scoreNum != null && scoreNum > 0) return Colors.green;
                          }
                          return Colors.grey;
                        }

                        String getStatusText() {
                          switch (status) {
                            case 'in_progress':
                              return 'In Progress';
                            case 'completed':
                              return 'Completed';
                            default:
                              return status;
                          }
                        }

                        return Padding(
                          padding: const EdgeInsets.symmetric(vertical: 4),
                          child: ListTile(
                            dense: true,
                            contentPadding: EdgeInsets.zero,
                            leading: CircleAvatar(
                              radius: 16,
                              backgroundColor: getStatusColor(),
                              child: Text(
                                '$attemptNum',
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                  fontSize: 12,
                                ),
                              ),
                            ),
                            title: Text(
                              'Attempt #$attemptNum',
                              style: GoogleFonts.poppins(
                                fontWeight: FontWeight.w600,
                                fontSize: 14,
                              ),
                            ),
                            subtitle: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  getStatusText(),
                                  style: GoogleFonts.poppins(
                                    fontSize: 12,
                                    color: getStatusColor(),
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                                if (startedAt != null && startedAt.isNotEmpty)
                                  Text(
                                    _formatDateTime(startedAt),
                                    style: GoogleFonts.poppins(
                                      fontSize: 11,
                                      color: Colors.grey[600],
                                    ),
                                  ),
                              ],
                            ),
                            trailing: status == 'in_progress'
                                ? const Icon(Icons.play_arrow_rounded, color: Colors.orange, size: 20)
                                : Text(
                              score,
                              style: GoogleFonts.poppins(
                                fontWeight: FontWeight.bold,
                                fontSize: 14,
                                color: getStatusColor(),
                              ),
                            ),
                          ),
                        );
                      } catch (e) {
                        developer.log('âŒ Error building attempt item: $e');
                        return const SizedBox.shrink();
                      }
                    }),
                    if (sortedAttempts.length > 5)
                      Padding(
                        padding: const EdgeInsets.only(top: 12),
                        child: TextButton.icon(
                          onPressed: () {
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Full history feature coming soon!'),
                                  duration: Duration(seconds: 2),
                                ),
                              );
                            }
                          },
                          icon: const Icon(Icons.arrow_forward_ios, size: 14),
                          label: Text(
                            'View all ${sortedAttempts.length} attempts',
                            style: GoogleFonts.poppins(fontWeight: FontWeight.w500),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            );
          },
          loading: () => const SizedBox.shrink(),
          error: (error, stack) {
            developer.log('âŒ Attempt history error: $error\n$stack');
            return const SizedBox.shrink();
          },
        );
      },
    );
  }

  String _formatDateTime(String dateTimeString) {
    try {
      final dateTime = DateTime.parse(dateTimeString);
      return '${_getRelativeTime(dateTime)} â€¢ ${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
    } catch (e) {
      developer.log('âŒ DateTime parse error: $e');
      return dateTimeString;
    }
  }

  String _getRelativeTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    if (difference.inDays > 0) return '${difference.inDays}d ago';
    if (difference.inHours > 0) return '${difference.inHours}h ago';
    if (difference.inMinutes > 0) return '${difference.inMinutes}m ago';
    return 'Just now';
  }

  @override
  Widget build(BuildContext context) {
    final quiz = widget.quiz;
    final isInstant = _isInstantQuiz(quiz);

    if (_quizId == 0) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('Invalid Quiz'),
          backgroundColor: Colors.red,
        ),
        body: const Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error_outline, size: 80, color: Colors.red),
              SizedBox(height: 16),
              Text('Invalid quiz data', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              SizedBox(height: 8),
              Text('Please try again or contact support', style: TextStyle(color: Colors.grey)),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        title: Text(
          quiz['quiz_title'] ?? "Quiz",
          style: GoogleFonts.poppins(fontWeight: FontWeight.bold),
        ),
        backgroundColor: Colors.transparent,
        elevation: 0,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [const Color(0xFF6C5CE7), const Color(0xFF8B78FF)],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => context.pop(),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.share_rounded, color: Colors.white),
            onPressed: _shareQuiz,
            tooltip: "Share Quiz",
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            Card(
              elevation: 8,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
              child: Padding(
                padding: const EdgeInsets.all(24),
                child: Column(
                  children: [
                    Text(
                      quiz['quiz_title'] ?? "Quiz",
                      style: GoogleFonts.poppins(
                        fontSize: 28,
                        fontWeight: FontWeight.bold,
                        color: Colors.black87,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 20),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        _infoChip(
                          Icons.timer,
                          isInstant
                              ? "30 sec per Q"
                              : "${safeIntParse(quiz['duration_minutes'], context: 'duration_minutes', defaultValue: 10)} mins",
                        ),
                        _infoChip(
                          Icons.quiz,
                          "${safeIntParse(quiz['total_questions'], context: 'total_questions', defaultValue: 10)} Qs",
                        ),
                        _infoChip(
                          Icons.star,
                          "${safeIntParse(quiz['passing_criteria'], context: 'passing_criteria', defaultValue: 60)}% Pass",
                        ),
                      ],
                    ),
                    if (isInstant) ...[
                      const SizedBox(height: 20),
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [Colors.orange.shade400, Colors.orange.shade600],
                          ),
                          borderRadius: BorderRadius.circular(20),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.orange.withOpacity(0.3),
                              blurRadius: 10,
                              spreadRadius: 2,
                            ),
                          ],
                        ),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(Icons.flash_on, color: Colors.white, size: 20),
                            const SizedBox(width: 8),
                            Text(
                              "Instant Quiz Mode",
                              style: GoogleFonts.poppins(
                                fontWeight: FontWeight.bold,
                                color: Colors.white,
                                fontSize: 14,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                    if (quiz['description'] != null && quiz['description'].toString().isNotEmpty) ...[
                      const SizedBox(height: 20),
                      Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Colors.grey[50],
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(color: Colors.grey[200]!),
                        ),
                        child: Text(
                          quiz['description']!,
                          style: GoogleFonts.poppins(
                            fontSize: 14,
                            color: Colors.grey[600],
                            height: 1.5,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
            _buildAttemptHistory(),
            const SizedBox(height: 24),
            Card(
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Icon(Icons.info_outline, color: Color(0xFF6C5CE7)),
                        const SizedBox(width: 8),
                        Text(
                          "Instructions",
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.black87,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    ...[
                      _buildInstructionItem(
                        isInstant
                            ? "âš¡ 30 seconds per question with instant feedback"
                            : "â±ï¸ ${safeIntParse(quiz['duration_minutes'], context: 'instruction_duration', defaultValue: 10)} minutes total time",
                      ),
                      _buildInstructionItem(
                        isInstant
                            ? "ðŸŽ¯ Auto-advance to next question"
                            : "ðŸ“ Review and change answers before submitting",
                      ),
                      _buildInstructionItem("âœ… No negative marking"),
                      _buildInstructionItem("ðŸŽ® Complete in one session"),
                      _buildInstructionItem("ðŸ’¾ Progress automatically saved"),
                    ],
                  ],
                ),
              ),
            ),
            const SizedBox(height: 32),
            Consumer(
              builder: (context, ref, child) {
                final latestAttemptAsync = ref.watch(latestQuizAttemptProvider(_quizId));
                String buttonText = isInstant ? "ðŸš€ Start Instant Quiz" : "ðŸš€ Start Quiz Now";
                Color buttonColor = const Color(0xFF6C5CE7);
                IconData buttonIcon = isInstant ? Icons.flash_on : Icons.play_arrow_rounded;

                if (latestAttemptAsync.asData?.value != null) {
                  final latestAttempt = latestAttemptAsync.asData!.value!;
                  final status = latestAttempt['status']?.toString() ?? '';
                  if (status == 'in_progress') {
                    buttonText = "ðŸ“± Resume Previous Attempt";
                    buttonColor = Colors.orange;
                    buttonIcon = Icons.play_arrow_rounded;
                  }
                }

                return Column(
                  children: [
                    SizedBox(
                      width: double.infinity,
                      height: 65,
                      child: ElevatedButton.icon(
                        onPressed: isStarting ? null : _startQuiz,
                        icon: isStarting
                            ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(
                            color: Colors.white,
                            strokeWidth: 2,
                          ),
                        )
                            : Icon(buttonIcon),
                        label: Text(
                          isStarting ? "Starting Quiz..." : buttonText,
                          style: GoogleFonts.poppins(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.white,
                          ),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: isStarting ? Colors.grey : buttonColor,
                          foregroundColor: Colors.white,
                          elevation: isStarting ? 0 : 10,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(30),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 16),
                        ),
                      ),
                    ),
                    Consumer(
                      builder: (context, ref, child) {
                        final latestAttemptAsync = ref.watch(latestQuizAttemptProvider(_quizId));
                        if (latestAttemptAsync.asData?.value != null) {
                          final latestAttempt = latestAttemptAsync.asData!.value!;
                          final status = latestAttempt['status']?.toString() ?? '';
                          if (status == 'in_progress' && !isStarting) {
                            return Padding(
                              padding: const EdgeInsets.only(top: 12),
                              child: Container(
                                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                decoration: BoxDecoration(
                                  color: Colors.orange.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(20),
                                  border: Border.all(color: Colors.orange.withOpacity(0.3)),
                                ),
                                child: Row(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    Icon(Icons.info_outline, size: 16, color: Colors.orange),
                                    const SizedBox(width: 6),
                                    Text(
                                      "Your previous attempt is still in progress. Tap to resume!",
                                      style: GoogleFonts.poppins(
                                        fontSize: 12,
                                        color: Colors.orange[700],
                                        fontWeight: FontWeight.w500,
                                      ),
                                      textAlign: TextAlign.center,
                                    ),
                                  ],
                                ),
                              ),
                            );
                          }
                        }
                        return const SizedBox.shrink();
                      },
                    ),
                    const SizedBox(height: 20),
                  ],
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _infoChip(IconData icon, String text) {
    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: const Color(0xFF6C5CE7).withOpacity(0.1),
            shape: BoxShape.circle,
          ),
          child: Icon(icon, color: const Color(0xFF6C5CE7), size: 28),
        ),
        const SizedBox(height: 8),
        Text(
          text,
          style: GoogleFonts.poppins(
            fontSize: 13,
            fontWeight: FontWeight.w600,
            color: Colors.black87,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildInstructionItem(String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 20,
            height: 20,
            decoration: const BoxDecoration(
              color: Color(0xFF6C5CE7),
              shape: BoxShape.circle,
            ),
            child: const Icon(
              Icons.check,
              color: Colors.white,
              size: 12,
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              text,
              style: GoogleFonts.poppins(
                fontSize: 14,
                height: 1.4,
                color: Colors.black87,
              ),
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\quiz_result_screen.dart =====

// lib/screens/quizzes/quiz_result_screen.dart
import 'dart:convert';
import 'dart:io';
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'package:path_provider/path_provider.dart';
import 'package:screenshot/screenshot.dart';
import 'package:share_plus/share_plus.dart';
import 'dart:developer' as developer;

class QuizResultScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> result;
  const QuizResultScreen({super.key, required this.result});

  @override
  ConsumerState<QuizResultScreen> createState() => _QuizResultScreenState();
}

class _QuizResultScreenState extends ConsumerState<QuizResultScreen> {
  late final ConfettiController _confettiController;
  final ScreenshotController _screenshotController = ScreenshotController();

  double _score = 0.0;
  double _fullMarks = 50.0;
  double _percentage = 0.0;
  String _quizTitle = "Quiz";
  int _attemptId = 0;

  @override
  void initState() {
    super.initState();
    _confettiController = ConfettiController(duration: const Duration(seconds: 5));
    _extractResultData();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      Future.delayed(const Duration(milliseconds: 800), () {
        if (mounted && _percentage >= 60) {
          _confettiController.play();
        }
      });
    });
  }

  void _extractResultData() {
    try {
      final data = widget.result['data'] ?? widget.result;

      final String? idStr = data['id']?.toString() ??
          data['attempt_id']?.toString() ??
          data['attemptId']?.toString();
      _attemptId = int.tryParse(idStr ?? '') ?? 0;

      _quizTitle = data['quiz_title']?.toString() ??
          data['title']?.toString() ??
          "Quiz Result";

      final String? scoreStr = data['obtained_marks']?.toString() ??
          data['score']?.toString() ??
          data['result_score']?.toString();
      final String? totalStr = data['total_marks']?.toString() ??
          data['full_marks']?.toString() ??
          '50';

      _score = double.tryParse(scoreStr ?? '0') ?? 0.0;
      _fullMarks = double.tryParse(totalStr ?? '50') ?? 50.0;
      _percentage = _fullMarks > 0 ? (_score / _fullMarks) * 100 : 0.0;

      developer.log(
          'QuizResult â†’ attemptId: $_attemptId | Score: $_score/$_fullMarks (${_percentage.toStringAsFixed(1)}%)');
      setState(() {});
    } catch (e, s) {
      developer.log('Error extracting result data', error: e, stackTrace: s);
      setState(() {});
    }
  }

  Future<void> _shareScreenshot() async {
    // Critical: Delay to ensure full layout + confetti render
    await Future.delayed(const Duration(milliseconds: 800));

    try {
      final imageBytes = await _screenshotController.capture(
        delay: const Duration(milliseconds: 400),
        pixelRatio: MediaQuery.of(context).devicePixelRatio * 1.5, // High quality
      );

      if (imageBytes == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Failed to capture screenshot")),
        );
        return;
      }

      final quizData = widget.result['data'] ?? widget.result;
      final String slugOrId = () {
        final slug = quizData['slug']?.toString().trim();
        if (slug != null && slug.isNotEmpty) return slug;
        final quizId = quizData['quiz_id'] ?? quizData['id'];
        return quizId?.toString() ?? 'unknown';
      }();

      final String shareUrl = "https://prepking.online/q/$slugOrId";
      final directory = await getTemporaryDirectory();
      final path =
          '${directory.path}/quiz_result_${DateTime.now().millisecondsSinceEpoch}.png';
      final file = File(path)..writeAsBytesSync(imageBytes);

      await Share.shareXFiles(
        [XFile(path)],
        text:
        "I scored ${_score.toInt()}/${_fullMarks.toInt()} (${_percentageString}%) in \"$_quizTitle\" on PrepKing!\n\nCan you beat my score?\n\n$shareUrl",
        subject: "My Quiz Result - PrepKing",
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("Share failed: $e")),
        );
      }
    }
  }

  String get _percentageString => _percentage.toStringAsFixed(1);

  void _navigateToReview() {
    if (_attemptId <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Review not available for this attempt")),
      );
      return;
    }
    context.push(
      '/quiz-review',
      extra: {
        'attemptId': _attemptId,
        'testName': _quizTitle,
      },
    );
  }

  @override
  void dispose() {
    _confettiController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final passed = _percentage >= 60;
    final totalQuestions =
    (widget.result['data']?['total_questions'] ?? 5).toString();

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      body: SafeArea(
        child: SingleChildScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // ==================== FULL SCORECARD (CAPTURED AREA) ====================
              Screenshot(
                controller: _screenshotController,
                child: Container(
                  color: const Color(0xFFF8FAFC),
                  child: Stack(
                    children: [
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.stretch,
                        children: [
                          // Header: Lottie + Message
                          Container(
                            padding: const EdgeInsets.fromLTRB(20, 40, 20, 30),
                            decoration: BoxDecoration(
                              gradient: LinearGradient(
                                begin: Alignment.topCenter,
                                end: Alignment.bottomCenter,
                                colors: [
                                  const Color(0xFF6C5CE7).withOpacity(0.15),
                                  Colors.white.withOpacity(0.9),
                                  Colors.white,
                                ],
                              ),
                            ),
                            child: Column(
                              children: [
                                Lottie.asset(
                                  passed
                                      ? 'assets/lottie/trophy.json'
                                      : 'assets/lottie/sad.json',
                                  width: 260,
                                  height: 260,
                                  fit: BoxFit.contain,
                                  repeat: true,
                                  errorBuilder: (_, __, ___) => Icon(
                                    passed ? Icons.celebration : Icons.sentiment_dissatisfied,
                                    size: 160,
                                    color: passed ? Colors.amber.shade700 : Colors.orange.shade700,
                                  ),
                                ),
                                const SizedBox(height: 20),
                                Container(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 36, vertical: 18),
                                  decoration: BoxDecoration(
                                    color:
                                    passed ? Colors.green.shade600 : Colors.orange.shade600,
                                    borderRadius: BorderRadius.circular(32),
                                    boxShadow: [
                                      BoxShadow(
                                        color: (passed ? Colors.green : Colors.orange)
                                            .withOpacity(0.5),
                                        blurRadius: 16,
                                        offset: const Offset(0, 8),
                                      ),
                                    ],
                                  ),
                                  child: Text(
                                    passed
                                        ? "Congratulations! You Passed!"
                                        : "Better Luck Next Time!",
                                    style: GoogleFonts.poppins(
                                      fontSize: 26,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white,
                                    ),
                                    textAlign: TextAlign.center,
                                  ),
                                ),
                              ],
                            ),
                          ),

                          // Score & Stats
                          Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 20),
                            child: Column(
                              children: [
                                // Final Score Card
                                Card(
                                  elevation: 14,
                                  shadowColor: const Color(0xFF6C5CE7).withOpacity(0.35),
                                  shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(28)),
                                  child: Padding(
                                    padding: const EdgeInsets.all(32.0),
                                    child: Column(
                                      children: [
                                        Text(
                                          "Your Final Score",
                                          style: GoogleFonts.poppins(
                                            fontSize: 22,
                                            color: Colors.grey[700],
                                            fontWeight: FontWeight.w600,
                                          ),
                                        ),
                                        const SizedBox(height: 28),
                                        FittedBox(
                                          child: Row(
                                            mainAxisAlignment: MainAxisAlignment.center,
                                            children: [
                                              Text(
                                                _score.toStringAsFixed(0),
                                                style: GoogleFonts.poppins(
                                                  fontSize: 84,
                                                  fontWeight: FontWeight.bold,
                                                  color: const Color(0xFF6C5CE7),
                                                ),
                                              ),
                                              Text(
                                                " / ${_fullMarks.toStringAsFixed(0)}",
                                                style: GoogleFonts.poppins(
                                                  fontSize: 38,
                                                  color: Colors.grey[600],
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                        const SizedBox(height: 24),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                              horizontal: 44, vertical: 16),
                                          decoration: BoxDecoration(
                                            color: passed
                                                ? Colors.green.shade600
                                                : Colors.orange.shade600,
                                            borderRadius: BorderRadius.circular(32),
                                          ),
                                          child: Text(
                                            "${_percentageString}%",
                                            style: GoogleFonts.poppins(
                                              fontSize: 38,
                                              fontWeight: FontWeight.bold,
                                              color: Colors.white,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ),

                                const SizedBox(height: 28),

                                // Quiz Info + Stats Card
                                Card(
                                  elevation: 10,
                                  shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(20)),
                                  child: Padding(
                                    padding: const EdgeInsets.all(24.0),
                                    child: Column(
                                      children: [
                                        Row(
                                          children: [
                                            Container(
                                              padding: const EdgeInsets.all(14),
                                              decoration: BoxDecoration(
                                                color: const Color(0xFF6C5CE7)
                                                    .withOpacity(0.12),
                                                borderRadius:
                                                BorderRadius.circular(16),
                                              ),
                                              child: const Icon(Icons.quiz_outlined,
                                                  color: Color(0xFF6C5CE7), size: 32),
                                            ),
                                            const SizedBox(width: 16),
                                            Expanded(
                                              child: Column(
                                                crossAxisAlignment:
                                                CrossAxisAlignment.start,
                                                children: [
                                                  Text(
                                                    _quizTitle,
                                                    style: GoogleFonts.poppins(
                                                        fontSize: 20,
                                                        fontWeight:
                                                        FontWeight.w600),
                                                  ),
                                                  Text(
                                                    "$totalQuestions Questions â€¢ Instant Quiz",
                                                    style: GoogleFonts.poppins(
                                                        fontSize: 15,
                                                        color: Colors.grey[600]),
                                                  ),
                                                ],
                                              ),
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 28),
                                        Row(
                                          mainAxisAlignment:
                                          MainAxisAlignment.spaceEvenly,
                                          children: [
                                            _buildStatCard(Icons.timer_outlined,
                                                "Time Taken", "2m 30s"),
                                            _buildStatCard(Icons.trending_up,
                                                "Accuracy", "${_percentageString}%"),
                                            _buildStatCard(Icons.star,
                                                "Points", _score.toStringAsFixed(0)),
                                          ],
                                        ),
                                      ],
                                    ),
                                  ),
                                ),

                                const SizedBox(height: 80), // Clean bottom padding for share
                              ],
                            ),
                          ),
                        ],
                      ),

                      // Confetti (inside screenshot)
                      if (passed)
                        ConfettiWidget(
                          confettiController: _confettiController,
                          blastDirectionality: BlastDirectionality.explosive,
                          emissionFrequency: 0.04,
                          numberOfParticles: 80,
                          gravity: 0.18,
                          shouldLoop: false,
                          colors: const [
                            Colors.red,
                            Colors.blue,
                            Colors.green,
                            Colors.yellow,
                            Colors.purple,
                            Colors.orange,
                            Colors.pink
                          ],
                        ),
                    ],
                  ),
                ),
              ),

              // ==================== ACTION BUTTONS (OUTSIDE SCREENSHOT) ====================
              Padding(
                padding: const EdgeInsets.fromLTRB(20, 40, 20, 50),
                child: Column(
                  children: [
                    SizedBox(
                      width: double.infinity,
                      height: 60,
                      child: ElevatedButton.icon(
                        onPressed: _shareScreenshot,
                        icon: const Icon(Icons.share, size: 28),
                        label: Text(
                          "Share My Result",
                          style: GoogleFonts.poppins(
                              fontSize: 19, fontWeight: FontWeight.w600),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.green.shade600,
                          elevation: 8,
                          shadowColor: Colors.green.withOpacity(0.5),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(30)),
                        ),
                      ),
                    ),
                    const SizedBox(height: 18),
                    SizedBox(
                      width: double.infinity,
                      height: 60,
                      child: ElevatedButton.icon(
                        onPressed: _attemptId > 0 ? _navigateToReview : null,
                        icon: const Icon(Icons.remove_red_eye_outlined, size: 28),
                        label: Text(
                          _attemptId > 0 ? "Review Answers" : "Review Not Available",
                          style: GoogleFonts.poppins(
                              fontSize: 19, fontWeight: FontWeight.w600),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _attemptId > 0
                              ? const Color(0xFF6C5CE7)
                              : Colors.grey.shade400,
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(30)),
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),
                    SizedBox(
                      width: double.infinity,
                      height: 60,
                      child: OutlinedButton.icon(
                        onPressed: () => context.go('/quizzes'),
                        icon: const Icon(Icons.arrow_back_ios_new, size: 22),
                        label: Text(
                          "Back to Quizzes",
                          style: GoogleFonts.poppins(
                              fontSize: 19, fontWeight: FontWeight.w600),
                        ),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: const Color(0xFF6C5CE7),
                          side: const BorderSide(
                              color: Color(0xFF6C5CE7), width: 2.8),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(30)),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildStatCard(IconData icon, String label, String value) {
    return Column(
      children: [
        Container(
          width: 70,
          height: 70,
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                const Color(0xFF6C5CE7).withOpacity(0.2),
                const Color(0xFF5A4FCF).withOpacity(0.1)
              ],
            ),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(color: const Color(0xFF6C5CE7).withOpacity(0.4)),
          ),
          child: Icon(icon, color: const Color(0xFF6C5CE7), size: 34),
        ),
        const SizedBox(height: 14),
        Text(
          value,
          style: GoogleFonts.poppins(
              fontSize: 20, fontWeight: FontWeight.bold, color: const Color(0xFF6C5CE7)),
        ),
        Text(
          label,
          style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey.shade600),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\quiz_review_screen.dart =====

import 'package:flutter/material.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';

class QuizReviewScreen extends StatefulWidget {
  final int attemptId; // Only this is required now
  final String? testName;

  const QuizReviewScreen({
    Key? key,
    required this.attemptId,
    this.testName,
  }) : super(key: key);

  @override
  _QuizReviewScreenState createState() => _QuizReviewScreenState();
}

class _QuizReviewScreenState extends State<QuizReviewScreen> {
  List<Map<String, dynamic>> _questions = [];
  Map<String, dynamic> _testStats = {};
  Map<String, dynamic> _metaData = {};
  bool _isLoading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _fetchReviewData();
  }

  Future<void> _fetchReviewData() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final url =
          'https://quizard.in/api_002.php/attempt_review/fulldata/${widget.attemptId}';
      final response = await http.get(Uri.parse(url)).timeout(
        Duration(seconds: 15),
      );

      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);

        if (jsonResponse['success'] == true) {
          final data = jsonResponse['data'];

          // Extract metadata
          _metaData = {
            'quiz_title': data['quiz_title'] ?? 'Quiz Review',
            'score': data['obtained_marks'] ?? '0',
            'total_marks': data['total_marks'] ?? '0',
            'percentage': data['result_percentage'] ?? '0',
            'time_taken': data['time_spent_total'] ?? 0,
            'completed_at': data['completed_at'] ?? '',
            'user_name': data['user_name'] ?? '',
          };

          final List<dynamic> rawQuestions = data['questions_data'] ?? [];

          final List<Map<String, dynamic>> parsedQuestions = rawQuestions.map((item) {
            final fullQ = item['full_question'] as Map<String, dynamic>;

            // Convert option1, option2, option3, option4 â†’ List<String>
            List<String> options = [];
            for (int i = 1; i <= 4; i++) {
              String? opt = fullQ['option$i'];
              if (opt != null && opt.toString().trim().isNotEmpty) {
                options.add(opt.toString().trim());
              }
            }

            // Correct answer is 1-based in API, but we convert to 0-based letter (A, B, C, D)
            int correctIdx = (fullQ['correct_answer'] is num)
                ? (fullQ['correct_answer'] as num).toInt()
                : 0;
            String correctOptionLetter = correctIdx >= 0 && correctIdx < 4
                ? String.fromCharCode(65 + correctIdx)
                : '?';

            // Selected option is string like "1", "2", etc. â†’ convert to "A", "B"
            String? selectedLetter;
            if (item['selected_option'] != null) {
              int sel = int.tryParse(item['selected_option'].toString()) ?? -1;
              if (sel >= 1 && sel <= 4) {
                selectedLetter = String.fromCharCode(64 + sel);
              }
            }

            return {
              'question_index': item['question_index'] ?? 0,
              'question_text': fullQ['question']?.toString() ?? 'Question not available',
              'options': options,
              'correct_answer': correctOptionLetter,
              'selected_option': selectedLetter,
              'is_correct': item['is_correct'] == true,
              'answered': item['answered'] == true,
              'marked': false, // not supported in new API, kept for compatibility
              'explanation': fullQ['explanation']?.toString(),
              'difficulty': fullQ['difficulty']?.toString() ?? 'Medium',
            };
          }).toList();

          final stats = _calculateTestStats(parsedQuestions);

          setState(() {
            _questions = parsedQuestions;
            _testStats = stats;
            _isLoading = false;
          });
        } else {
          throw Exception(jsonResponse['message'] ?? 'Failed to load review');
        }
      } else {
        throw Exception('Server error: ${response.statusCode}');
      }
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  Map<String, dynamic> _calculateTestStats(List<Map<String, dynamic>> questions) {
    int total = questions.length;
    int correct = questions.where((q) => q['is_correct'] == true).length;
    int answered = questions.where((q) => q['answered'] == true).length;
    int incorrect = answered - correct;
    int unanswered = total - answered;

    double accuracy = total > 0 ? (correct / total) * 100 : 0.0;

    return {
      'total': total,
      'correct': correct,
      'incorrect': incorrect,
      'unanswered': unanswered,
      'accuracy': accuracy,
      'score': _metaData['score'] ?? '$correct/ $total',
    };
  }

  Future<void> _saveReview() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final reviews = prefs.getStringList('saved_reviews') ?? [];

      final reviewToSave = {
        'timestamp': DateTime.now().toIso8601String(),
        'attempt_id': widget.attemptId,
        'test_name': widget.testName ?? _metaData['quiz_title'],
        'stats': _testStats,
        'meta': _metaData,
        'questions': _questions,
      };

      reviews.add(jsonEncode(reviewToSave));
      await prefs.setStringList('saved_reviews', reviews);

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Review saved offline!'), backgroundColor: Colors.green),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Save failed'), backgroundColor: Colors.red),
      );
    }
  }

  // === UI Widgets (same beautiful design as before) ===

  Widget _buildStatsCard() {
    return Card(
      elevation: 6,
      margin: EdgeInsets.all(16),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: EdgeInsets.all(20),
        child: Column(
          children: [
            Text(
              _metaData['quiz_title'] ?? 'Quiz Review',
              style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: Colors.indigo),
            ),
            SizedBox(height: 12),
            Text(
              'Score: ${_metaData['score']} / ${_metaData['total_marks']}  â€¢  ${_metaData['percentage']}%',
              style: TextStyle(fontSize: 18, color: Colors.blueGrey),
            ),
            SizedBox(height: 20),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _buildStatItem('Correct', '${_testStats['correct']}', Colors.green),
                _buildStatItem('Wrong', '${_testStats['incorrect']}', Colors.red),
                _buildStatItem('Skipped', '${_testStats['unanswered']}', Colors.orange),
                _buildStatItem('Accuracy', '${_testStats['accuracy'].toStringAsFixed(1)}%', Colors.blue),
              ],
            ),
            SizedBox(height: 16),
            LinearProgressIndicator(
              value: _testStats['correct'] / _testStats['total'],
              backgroundColor: Colors.red.shade100,
              valueColor: AlwaysStoppedAnimation(Colors.green),
              minHeight: 10,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(String label, String value, Color color) {
    return Column(
      children: [
        Text(value, style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: color)),
        Text(label, style: TextStyle(color: Colors.grey.shade600)),
      ],
    );
  }

  Widget _buildQuestionCard(Map<String, dynamic> q, int index) {
    final selected = q['selected_option'] as String?;
    final correct = q['correct_answer'] as String;
    final options = q['options'] as List<String>;

    return Card(
      margin: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                CircleAvatar(
                  backgroundColor: q['is_correct']
                      ? Colors.green
                      : q['answered']
                      ? Colors.red
                      : Colors.grey,
                  child: Text('${q['question_index'] + 1}', style: TextStyle(color: Colors.white)),
                ),
                SizedBox(width: 12),
                Expanded(
                  child: Text(
                    'Question ${q['question_index'] + 1}',
                    style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                  ),
                ),
              ],
            ),
            SizedBox(height: 12),
            Text(q['question_text'], style: TextStyle(fontSize: 15, height: 1.5)),
            SizedBox(height: 20),

            // Options
            ...options.asMap().entries.map((e) {
              int idx = e.key;
              String text = e.value;
              String letter = String.fromCharCode(65 + idx);

              bool isCorrect = letter == correct;
              bool isSelected = letter == selected;

              return Container(
                margin: EdgeInsets.only(bottom: 8),
                padding: EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                decoration: BoxDecoration(
                  color: isCorrect
                      ? Colors.green.withOpacity(0.1)
                      : isSelected
                      ? Colors.red.withOpacity(0.1)
                      : null,
                  border: Border.all(
                    color: isCorrect
                        ? Colors.green
                        : isSelected
                        ? Colors.red
                        : Colors.grey.shade300,
                    width: isCorrect || isSelected ? 2 : 1,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    CircleAvatar(
                      radius: 14,
                      backgroundColor: isCorrect
                          ? Colors.green
                          : isSelected
                          ? Colors.red
                          : Colors.grey.shade300,
                      child: Text(letter, style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                    ),
                    SizedBox(width: 12),
                    Expanded(child: Text(text)),
                    if (isCorrect) Icon(Icons.check_circle, color: Colors.green),
                    if (isSelected && !isCorrect) Icon(Icons.cancel, color: Colors.red),
                  ],
                ),
              );
            }).toList(),

            SizedBox(height: 16),
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: q['is_correct']
                    ? Colors.green.withOpacity(0.1)
                    : q['answered']
                    ? Colors.red.withOpacity(0.1)
                    : Colors.grey.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    q['is_correct']
                        ? Icons.check_circle
                        : q['answered']
                        ? Icons.cancel
                        : Icons.help_outline,
                    color: q['is_correct']
                        ? Colors.green
                        : q['answered']
                        ? Colors.red
                        : Colors.grey,
                  ),
                  SizedBox(width: 12),
                  Text(
                    q['is_correct']
                        ? 'Correct Answer'
                        : q['answered']
                        ? 'Wrong Answer'
                        : 'Not Attempted',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  Spacer(),
                  Text('Correct: $correct', style: TextStyle(color: Colors.green, fontWeight: FontWeight.bold)),
                ],
              ),
            ),

            if (q['explanation'] != null && q['explanation'].toString().trim().isNotEmpty)
              Padding(
                padding: EdgeInsets.only(top: 16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(children: [Icon(Icons.lightbulb, color: Colors.amber), SizedBox(width: 8), Text('Explanation', style: TextStyle(fontWeight: FontWeight.bold))]),
                    SizedBox(height: 8),
                    Container(
                      width: double.infinity,
                      padding: EdgeInsets.all(12),
                      decoration: BoxDecoration(color: Colors.amber.shade50, borderRadius: BorderRadius.circular(8)),
                      child: Text(q['explanation'], style: TextStyle(height: 1.5)),
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.testName ?? 'Review'),
        actions: [
          IconButton(icon: Icon(Icons.save), onPressed: _saveReview),
          IconButton(icon: Icon(Icons.refresh), onPressed: _fetchReviewData),
        ],
      ),
      body: _isLoading
          ? Center(child: CircularProgressIndicator())
          : _error != null
          ? Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error, size: 64, color: Colors.red),
            SizedBox(height: 16),
            Text('Failed to load review', style: TextStyle(fontSize: 18)),
            Text(_error!, style: TextStyle(color: Colors.red)),
            ElevatedButton(onPressed: _fetchReviewData, child: Text('Retry')),
          ],
        ),
      )
          : Column(
        children: [
          _buildStatsCard(),
          Expanded(
            child: ListView.builder(
              itemCount: _questions.length,
              itemBuilder: (ctx, i) => _buildQuestionCard(_questions[i], i),
            ),
          ),
        ],
      ),
      floatingActionButton: _questions.isNotEmpty
          ? FloatingActionButton(
        child: Icon(Icons.arrow_upward),
        onPressed: () => PrimaryScrollController.of(context).animateTo(0, duration: Duration(milliseconds: 400), curve: Curves.ease),
      )
          : null,
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\screens\quizzes\standard_quiz_player_screen.dart =====

import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:lottie/lottie.dart';
import 'dart:developer' as developer;
import '../../core/services/api_service.dart';
import '../../providers/user_provider.dart';

class StandardQuizPlayerScreen extends ConsumerStatefulWidget {
  final Map<String, dynamic> quiz;
  final int attemptId;

  const StandardQuizPlayerScreen({
    super.key,
    required this.quiz,
    required this.attemptId,
  });

  @override
  ConsumerState<StandardQuizPlayerScreen> createState() => _StandardQuizPlayerScreenState();
}

class _StandardQuizPlayerScreenState extends ConsumerState<StandardQuizPlayerScreen>
    with TickerProviderStateMixin, WidgetsBindingObserver {
  // Timer & Quiz State
  late Timer _timer;
  int _remainingSeconds = 0;
  int _originalDurationSeconds = 0;
  int _currentIndex = 0;
  List<Map<String, dynamic>> _questions = [];
  List<String?> _selectedAnswers = [];
  bool _isLoading = true;
  bool _isSubmitting = false;
  bool _isResuming = false;

  // Quiz Mode
  late final bool _isSequential;
  late final bool _isStandardMode; // ðŸ”¥ NEW: Standard Exam Mode flag

  // UI State
  bool _isTransitioning = false;

  // Animation Controllers
  late AnimationController _questionController;
  late AnimationController _optionsController;
  late AnimationController _exitController;

  // Animations
  late Animation<Offset> _questionSlideAnimation;
  late Animation<double> _optionsFadeAnimation;
  late Animation<Offset> _exitSlideAnimation;

  // Question Palette
  bool _showPalette = false;
  List<bool> _visitedQuestions = [];
  List<bool> _answeredQuestions = [];
  List<bool> _markedQuestions = [];

  // Colors
  final Color _primaryColor = const Color(0xFF6C5CE7);

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeAnimations();
    _initQuizType();
    _loadAttemptAndQuestions();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _updateAttemptProgress();
    _questionController.dispose();
    _optionsController.dispose();
    _exitController.dispose();
    if (_timer.isActive) _timer.cancel();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.paused || state == AppLifecycleState.inactive) {
      _updateAttemptProgress();
    }
  }

  int convertCorrectAnswer(dynamic value) {
    final v = int.tryParse(value?.toString() ?? '-1') ?? -1;
    if (v >= 0 && v <= 3) {
      return v + 1;
    }
    return -1;
  }

  Map<String, dynamic> normalizeQuestion(Map<String, dynamic> q) {
    return {
      'id': int.tryParse(q['id']?.toString() ?? '0') ?? 0,
      'quiz_id': int.tryParse(q['quiz_id']?.toString() ?? '0') ?? 0,
      'question': q['question']?.toString() ?? "",
      'option1': q['option1']?.toString() ?? "",
      'option2': q['option2']?.toString() ?? "",
      'option3': q['option3']?.toString() ?? "",
      'option4': q['option4']?.toString() ?? "",
      'correct_answer': convertCorrectAnswer(q['correct_answer']),
      'order': int.tryParse(q['order']?.toString() ?? '0') ?? 0,
    };
  }

  int _getCorrectAnswer(Map<String, dynamic> question) {
    final ans = question['correct_answer'];
    if (ans is int && ans >= 1 && ans <= 4) return ans;
    return -1;
  }

  void _initializeAnimations() {
    _questionController = AnimationController(
      duration: const Duration(milliseconds: 700),
      vsync: this,
    );
    _optionsController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );
    _exitController = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );
    _questionSlideAnimation = Tween<Offset>(
      begin: const Offset(0, 0.5),
      end: Offset.zero,
    ).animate(CurvedAnimation(parent: _questionController, curve: Curves.elasticOut));
    _optionsFadeAnimation = Tween<double>(begin: 0.0, end: 1.0)
        .animate(CurvedAnimation(parent: _optionsController, curve: Curves.easeIn));
    _exitSlideAnimation = Tween<Offset>(
      begin: Offset.zero,
      end: const Offset(-1.0, 0.0),
    ).animate(CurvedAnimation(parent: _exitController, curve: Curves.easeInOut));
  }

  void _initQuizType() {
    _isSequential = widget.quiz['is_sequential'] == "1" || widget.quiz['is_sequential'] == 1;
    // ðŸ”¥ STANDARD MODE FLAG
    _isStandardMode = widget.quiz['instantQuiz'] == 0 || widget.quiz['instantQuiz'] == "0";
    final durationMinutes = int.tryParse(widget.quiz['duration_minutes']?.toString() ?? '10') ?? 10;
    _remainingSeconds = durationMinutes * 60;
    _originalDurationSeconds = durationMinutes * 60;
  }

  Future<void> _loadAttemptAndQuestions() async {
    try {
      final api = ref.read(apiServiceProvider);
      final questionsResponse = await api.get('/saved_question/quiz/${widget.quiz['id']}');
      if (questionsResponse['success'] != true) {
        throw Exception(questionsResponse['message'] ?? 'Failed to load questions');
      }
      final List<dynamic> rawQuestions = questionsResponse['data'] ?? [];
      final questions = rawQuestions.map((q) => normalizeQuestion(q as Map<String, dynamic>)).toList();
      developer.log('ðŸŽ¯ NORMALIZATION COMPLETE: ${questions.length} questions');

      Map<String, dynamic>? attempt;
      try {
        final attemptResponse = await api.get('/quiz_attempt/${widget.attemptId}');
        if (attemptResponse['success'] == true) {
          attempt = attemptResponse['data'];
        }
      } catch (e) {
        developer.log('âš ï¸ Could not load attempt details: $e');
      }

      if (!mounted) return;
      setState(() {
        _questions = questions;
        _selectedAnswers = List.filled(questions.length, null);
        _visitedQuestions = List.filled(questions.length, false);
        _answeredQuestions = List.filled(questions.length, false);
        _markedQuestions = List.filled(questions.length, false);
        _isLoading = false;
      });

      if (_questions.isEmpty) return;

      if (attempt != null && attempt['status'] == 'in_progress') {
        await _resumeAttempt(attempt);
      } else {
        setState(() {
          _currentIndex = 0;
          _visitedQuestions[0] = true;
        });
        _startQuestionAnimations();
        _startMainTimer();
      }
    } catch (e) {
      developer.log("âŒ Load attempt error: $e");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Failed to load quiz: $e")));
      setState(() => _isLoading = false);
    }
  }

  Future<void> _resumeAttempt(Map<String, dynamic> attempt) async {
    try {
      setState(() => _isResuming = true);
      final currentQuestionIndex = int.tryParse(attempt['current_question_index']?.toString() ?? '0') ?? 0;
      _applyQuestionsDataFromAttempt(attempt);
      if (!mounted) return;
      setState(() {
        _currentIndex = currentQuestionIndex.clamp(0, _questions.length - 1);
        _visitedQuestions[_currentIndex] = true;
        _isResuming = false;
      });
      _startQuestionAnimations();
      _startMainTimer();
    } catch (e) {
      developer.log('âŒ Resume attempt error: $e');
      setState(() => _isResuming = false);
      _startQuestionAnimations();
      _startMainTimer();
    }
  }

  Future<void> _loadAttemptReviewAnswers(int attemptId) async {
    try {
      final api = ref.read(apiServiceProvider);
      final response = await api.get('/attempt_review', query: {'result_id': attemptId.toString()});
      if (response['success'] == true) {
        final List<dynamic> reviews = response['data'] ?? [];
        int loadedCount = 0;
        for (var review in reviews) {
          final questionId = review['question_id'] as int?;
          final selectedOption = review['selected_option'];
          final questionIndex = _questions.indexWhere((q) => (q['id'] as int) == questionId);
          if (questionIndex == -1) continue;
          final selectedStr = selectedOption?.toString();
          _selectedAnswers[questionIndex] = selectedStr;
          _answeredQuestions[questionIndex] = true;
          _visitedQuestions[questionIndex] = true;
          loadedCount++;
        }
        developer.log('âœ… Loaded $loadedCount previous answers');
      }
    } catch (e) {
      developer.log('âš ï¸ Could not load attempt reviews: $e');
    }
  }

  void _applyQuestionsDataFromAttempt(Map<String, dynamic> attempt) {
    final raw = attempt['questions_data'];
    if (raw == null) return;
    List<dynamic> decoded;
    try {
      decoded = jsonDecode(raw);
    } catch (e) {
      developer.log('âŒ Failed to decode questions_data: $e');
      return;
    }
    for (final item in decoded) {
      final index = item['question_index'];
      if (index == null || index >= _questions.length) continue;
      _selectedAnswers[index] = item['selected_option'];
      _answeredQuestions[index] = item['answered'] == true;
      _markedQuestions[index] = item['marked'] == true;
      // visited if answered OR marked OR explicitly visited before
      _visitedQuestions[index] =
          _answeredQuestions[index] || _markedQuestions[index];
    }
    developer.log('âœ… Applied resume data from questions_data');
  }

  Future<void> _updateAttemptProgress() async {
    try {
      final api = ref.read(apiServiceProvider);
      final questionsData = [];
      for (int i = 0; i < _questions.length; i++) {
        questionsData.add({
          'question_index': i,
          'question_id': _questions[i]['id'],
          'selected_option': _selectedAnswers[i],
          'answered': _answeredQuestions[i],
          'marked': _markedQuestions[i],
        });
      }
      await api.put('/quiz_attempt/${widget.attemptId}', {
        'current_question_index': _currentIndex.toString(),
        'questions_data': jsonEncode(questionsData),
        'time_spent_total': (_originalDurationSeconds - _remainingSeconds).toString(),
        'status': 'in_progress',
      });
      developer.log('âœ… Progress saved: Question $_currentIndex');
    } catch (e) {
      developer.log('âš ï¸ Failed to save progress: $e');
    }
  }

  Future<void> _saveCurrentAnswerOnly() async {
    try {
      final api = ref.read(apiServiceProvider);
      await api.post('/coursequizattempt', {
        'attempt_id': widget.attemptId.toString(),
        'question_id': _questions[_currentIndex]['id'].toString(),
        'selected_option': _selectedAnswers[_currentIndex],
        'question_index': _currentIndex.toString(),
      });
      developer.log('âœ… Answer saved for Q$_currentIndex');
    } catch (e) {
      developer.log('âš ï¸ Failed to save answer: $e');
    }
  }

  void _startQuestionAnimations() {
    _questionController.forward().then((_) {
      Future.delayed(const Duration(milliseconds: 100), () {
        _optionsController.forward();
      });
    });
  }

  void _startMainTimer() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) return;
      setState(() {
        if (_remainingSeconds > 0) {
          _remainingSeconds--;
        } else {
          timer.cancel();
          _submitQuiz();
        }
      });
    });
  }

  // ðŸ”¥ UPDATED: Standard Mode - No score, no lock, no auto-next
  void _selectAnswer(String selectedOption) {
    final selectedInt = int.tryParse(selectedOption);
    if (selectedInt == null || selectedInt < 1 || selectedInt > 4) return;
    setState(() {
      _selectedAnswers[_currentIndex] = selectedOption;
      _answeredQuestions[_currentIndex] = true;
      _visitedQuestions[_currentIndex] = true;
    });
    _updateAttemptProgress();
  }

  void _goToNextQuestion() async {
    await _saveCurrentAnswerOnly(); // ðŸ”¥ NEW
    _updateAttemptProgress();
    if (_currentIndex < _questions.length - 1) {
      setState(() => _isTransitioning = true);
      _exitController.forward().then((_) {
        _questionController.reset();
        _optionsController.reset();
        _exitController.reset();
        setState(() {
          _currentIndex++;
          _visitedQuestions[_currentIndex] = true;
          _isTransitioning = false;
        });
        _startQuestionAnimations();
      });
    } else {
      _showSubmitConfirmation();
    }
  }

  void _goToPreviousQuestion() {
    if (_currentIndex > 0) {
      _updateAttemptProgress();
      setState(() {
        _currentIndex--;
        _visitedQuestions[_currentIndex] = true;
      });
      _startQuestionAnimations();
    }
  }

  void _jumpToQuestion(int index) {
    _updateAttemptProgress();
    setState(() {
      _currentIndex = index;
      _visitedQuestions[_currentIndex] = true;
      _showPalette = false;
    });
    _startQuestionAnimations();
  }

  void _toggleMarkQuestion() {
    setState(() {
      _markedQuestions[_currentIndex] = !_markedQuestions[_currentIndex];
    });
    _updateAttemptProgress();
  }

  void _showQuestionPalette() {
    setState(() => _showPalette = true);
  }

  Future<void> _submitQuiz() async {
    if (_isSubmitting) return;
    _isSubmitting = true;
    if (_timer.isActive) _timer.cancel();
    await _updateAttemptProgress();
    try {
      final userId = ref.read(currentUserProvider).asData?.value?.id;
      if (userId == null) throw Exception("User not found");
      // ðŸ”¥ FINAL SCORE CALCULATION ONLY HERE
      int calculatedScore = 0;
      for (int i = 0; i < _questions.length; i++) {
        if (_selectedAnswers[i] != null) {
          final correctInt = _getCorrectAnswer(_questions[i]);
          final selectedInt = int.tryParse(_selectedAnswers[i]!) ?? -1;
          if (selectedInt == correctInt) calculatedScore += 10;
        }
      }
      final fullMarks = _questions.length * 10;
      final totalTimeTaken = (_originalDurationSeconds - _remainingSeconds);
      final resultResponse = await ref.read(apiServiceProvider).post('/result', {
        'quiz_id': widget.quiz['id'].toString(),
        'user_id': userId.toString(),
        'attempt_id': widget.attemptId.toString(),
        'score': calculatedScore.toString(),
        'full_marks': fullMarks.toString(),
        'time_taken': totalTimeTaken.toString(),
      });
      if (resultResponse['success'] != true) {
        throw Exception(resultResponse['message'] ?? 'Failed to create result');
      }
      final resultId = resultResponse['id'];
      final linkedAttemptId = resultResponse['attempt_id'] ?? widget.attemptId;
      await ref.read(apiServiceProvider).put('/quiz_attempt/${widget.attemptId}', {
        'status': 'completed',
        'completed_at': DateTime.now().toIso8601String(),
      });
      if (!mounted) return;
      context.go('/quizzes/result', extra: {
        'result_id': resultId,
        'attempt_id': linkedAttemptId,
        'score': calculatedScore,
        'total_questions': _questions.length,
        'total_marks': fullMarks,
        'quiz_title': widget.quiz['quiz_title'] ?? widget.quiz['title'],
        'percentage': (calculatedScore / fullMarks * 100).toStringAsFixed(1),
        'time_taken': totalTimeTaken,
        'passed': calculatedScore >= (fullMarks * 0.6),
        'slug': widget.quiz['slug']?.toString().trim().isNotEmpty == true
            ? widget.quiz['slug']
            : widget.quiz['id'].toString(),
      });
    } catch (e) {
      developer.log("âŒ Submit error: $e");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Submit failed: $e")));
      setState(() => _isSubmitting = false);
    }
  }

  void _showSubmitConfirmation() {
    final answeredCount = _selectedAnswers.where((answer) => answer != null).length;
    final unansweredCount = _questions.length - answeredCount;
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text("Submit Quiz?", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Summary:", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            const SizedBox(height: 8),
            Text("âœ… Answered: $answeredCount", style: GoogleFonts.poppins()),
            Text(
              unansweredCount > 0 ? "âŒ Unanswered: $unansweredCount" : "âœ… All questions answered!",
              style: GoogleFonts.poppins(color: unansweredCount > 0 ? Colors.orange : Colors.green),
            ),
            const SizedBox(height: 12),
            Text("Are you sure you want to submit your answers?", style: GoogleFonts.poppins()),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text("Go Back", style: GoogleFonts.poppins(color: Colors.grey[700])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: _primaryColor, foregroundColor: Colors.white),
            onPressed: () {
              Navigator.pop(context);
              _submitQuiz();
            },
            child: Text("Submit Quiz", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          ),
        ],
      ),
    );
  }

  Future<bool> _onWillPop() async {
    if (_showPalette) {
      setState(() => _showPalette = false);
      return false; // ðŸ”¥ do NOT exit screen
    }
    await _updateAttemptProgress();
    final shouldQuit = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text("Leave Quiz?", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Your progress is saved.", style: GoogleFonts.poppins()),
            const SizedBox(height: 8),
            Text("You can resume later from where you left off.", style: GoogleFonts.poppins(color: Colors.grey[600])),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text("Stay", style: GoogleFonts.poppins(color: Colors.grey[700])),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: _primaryColor),
            onPressed: () => Navigator.pop(context, true),
            child: Text("Leave", style: GoogleFonts.poppins(color: Colors.white)),
          ),
        ],
      ),
    );
    if (shouldQuit == true && mounted) {
      context.go('/quizzes');
    }
    return shouldQuit ?? false;
  }

  String _formatTime(int seconds) {
    final mins = seconds ~/ 60;
    final secs = seconds % 60;
    return '${mins.toString().padLeft(2, '0')}:${secs.toString().padLeft(2, '0')}';
  }

  Widget _buildTopBar() {
    final totalTime = _originalDurationSeconds;
    return Column(
      children: [
        LinearProgressIndicator(
          value: 1.0 - (_remainingSeconds / totalTime),
          backgroundColor: Colors.grey[300],
          color: _primaryColor,
          minHeight: 6,
        ),
        const SizedBox(height: 16),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Q ${_currentIndex + 1}/${_questions.length}',
              style: GoogleFonts.poppins(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: _remainingSeconds < 60 ? Colors.red : _primaryColor,
                borderRadius: BorderRadius.circular(20),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.timer, color: Colors.white, size: 18),
                  const SizedBox(width: 6),
                  Text(
                    _formatTime(_remainingSeconds),
                    style: GoogleFonts.poppins(color: Colors.white, fontWeight: FontWeight.bold),
                  ),
                ],
              ),
            ),
            IconButton(
              icon: const Icon(Icons.grid_view_rounded),
              onPressed: _showQuestionPalette,
            ),
          ],
        ),
      ],
    );
  }

  // ðŸ”¥ UPDATED: Neutral selection only (blue when selected)
  Widget _buildOptionButton(int index, String optionText) {
    final optionValue = (index + 1).toString();
    final isSelected = _selectedAnswers[_currentIndex] == optionValue;
    return AnimatedContainer(
      duration: const Duration(milliseconds: 250),
      margin: const EdgeInsets.only(bottom: 12),
      child: ElevatedButton(
        onPressed: () {
          _selectAnswer(optionValue);
          // ðŸ”¥ AUTO NEXT (Requirement #4)
          Future.delayed(const Duration(milliseconds: 180), () {
            if (_currentIndex < _questions.length - 1) {
              _goToNextQuestion();
            }
          });
        },
        style: ElevatedButton.styleFrom(
          backgroundColor: isSelected ? _primaryColor : Colors.grey[200],
          foregroundColor: isSelected ? Colors.white : Colors.black87,
          elevation: isSelected ? 6 : 2,
          padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 16),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
        ),
        child: Row(
          children: [
            CircleAvatar(
              backgroundColor: isSelected ? Colors.white24 : _primaryColor,
              radius: 18,
              child: Text(
                optionValue,
                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                optionText,
                style: GoogleFonts.poppins(fontSize: 16),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNavigation() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          children: [
            if (_currentIndex > 0 || !_isSequential)
              ElevatedButton.icon(
                onPressed: _goToPreviousQuestion,
                icon: const Icon(Icons.arrow_back),
                label: const Text("Previous"),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.grey[300],
                  foregroundColor: Colors.black87,
                  padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
              ),
          ],
        ),
        ElevatedButton.icon(
          onPressed: _currentIndex < _questions.length - 1 ? _goToNextQuestion : _showSubmitConfirmation,
          icon: Icon(_currentIndex < _questions.length - 1 ? Icons.arrow_forward : Icons.send),
          label: Text(_currentIndex < _questions.length - 1 ? "Next" : "Submit Quiz"),
          style: ElevatedButton.styleFrom(
            backgroundColor: _primaryColor,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        ),
      ],
    );
  }

  Widget _buildQuestionPalette() {
    if (!_showPalette) return const SizedBox.shrink();
    return GestureDetector(
      onTap: () => setState(() => _showPalette = false),
      child: Container(
        color: Colors.black54,
        child: GestureDetector(
          onTap: () {},
          child: DraggableScrollableSheet(
            initialChildSize: 0.7,
            minChildSize: 0.5,
            maxChildSize: 0.9,
            builder: (context, scrollController) {
              return Container(
                decoration: const BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                ),
                child: SingleChildScrollView(
                  controller: scrollController,
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            'Question Palette',
                            style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.bold),
                          ),
                          ElevatedButton.icon(
                            onPressed: _showSubmitConfirmation,
                            icon: const Icon(Icons.send, size: 18),
                            label: Text('Submit Quiz', style: GoogleFonts.poppins(fontSize: 14)),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: _primaryColor,
                              foregroundColor: Colors.white,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          _buildStatusIndicator('Answered', Colors.blue),
                          _buildStatusIndicator('Visited', Colors.yellow[700]!),
                          _buildStatusIndicator('Not Visited', Colors.grey),
                          _buildStatusIndicator('Marked', Colors.purple),
                        ],
                      ),
                      const SizedBox(height: 20),
                      GridView.builder(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(),
                        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                          crossAxisCount: 5,
                          crossAxisSpacing: 8,
                          mainAxisSpacing: 8,
                          childAspectRatio: 1,
                        ),
                        itemCount: _questions.length,
                        itemBuilder: (context, index) {
                          return _buildPaletteNumber(index);
                        },
                      ),
                      const SizedBox(height: 20),
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          onPressed: () => setState(() => _showPalette = false),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: _primaryColor,
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(vertical: 16),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          ),
                          child: Text('Close Palette', style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
      ),
    );
  }

  Widget _buildPaletteNumber(int index) {
    Color getColor() {
      if (_markedQuestions[index]) return Colors.purple;
      if (_answeredQuestions[index]) return Colors.blue;
      if (_visitedQuestions[index]) return Colors.yellow[700]!;
      return Colors.grey;
    }
    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      child: GestureDetector(
        onTap: () => _jumpToQuestion(index),
        child: Container(
          decoration: BoxDecoration(
            color: getColor(),
            borderRadius: BorderRadius.circular(8),
            border: _currentIndex == index ? Border.all(color: Colors.black, width: 2) : null,
            boxShadow: [
              BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 4, offset: const Offset(0, 2)),
            ],
          ),
          child: Center(
            child: Text(
              '${index + 1}',
              style: GoogleFonts.poppins(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildStatusIndicator(String text, Color color) {
    return Expanded(
      child: Row(
        children: [
          Container(
            width: 16,
            height: 16,
            decoration: BoxDecoration(color: color, borderRadius: BorderRadius.circular(4)),
          ),
          const SizedBox(width: 4),
          Text(text, style: GoogleFonts.poppins(fontSize: 12)),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Scaffold(
        backgroundColor: const Color(0xFFF8FAFC),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              if (_isResuming)
                Column(
                  children: [
                    Lottie.asset('assets/lottie/loading.json', width: 80, height: 80),
                    const SizedBox(height: 16),
                    Text("Resuming your progress...", style: GoogleFonts.poppins(fontSize: 16, color: _primaryColor)),
                    const SizedBox(height: 8),
                    Text("Loading question ${_currentIndex + 1}...", style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600])),
                  ],
                )
              else ...[
                Lottie.asset('assets/lottie/loading.json', width: 120, height: 120),
                const SizedBox(height: 20),
                Text("Loading Questions...", style: GoogleFonts.poppins(fontSize: 18, color: _primaryColor)),
              ],
            ],
          ),
        ),
      );
    }
    if (_questions.isEmpty) {
      return Scaffold(
        backgroundColor: const Color(0xFFF8FAFC),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.quiz_outlined, size: 100, color: Colors.grey[400]),
              const SizedBox(height: 20),
              Text("No questions available for this quiz", style: GoogleFonts.poppins(fontSize: 18, color: Colors.grey[600])),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () => context.pop(),
                style: ElevatedButton.styleFrom(backgroundColor: _primaryColor, foregroundColor: Colors.white),
                child: Text("Back to Quizzes", style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
              ),
            ],
          ),
        ),
      );
    }
    final question = _questions[_currentIndex];
    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        backgroundColor: const Color(0xFFF8FAFC),
        appBar: AppBar(
          backgroundColor: Colors.transparent,
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back, color: Colors.black87),
            onPressed: () => _onWillPop().then((shouldPop) {
              if (shouldPop) {
                // Navigation handled in _onWillPop
              }
            }),
          ),
          title: const SizedBox.shrink(),
          actions: [
            IconButton(
              icon: Icon(
                _markedQuestions[_currentIndex] ? Icons.bookmark : Icons.bookmark_border,
                color: _markedQuestions[_currentIndex] ? Colors.purple : Colors.grey,
              ),
              onPressed: _toggleMarkQuestion,
            ),
          ],
        ),
        body: GestureDetector(
          onHorizontalDragEnd: (details) {
            if (details.primaryVelocity! < 0 && _currentIndex < _questions.length - 1) {
              _goToNextQuestion();
            } else if (details.primaryVelocity! > 0 && _currentIndex > 0) {
              _goToPreviousQuestion();
            }
          },
          child: Stack(
            children: [
              Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    _buildTopBar(),
                    const SizedBox(height: 30),
                    AnimatedSwitcher(
                      duration: const Duration(milliseconds: 400),
                      child: _isTransitioning
                          ? const SizedBox.shrink()
                          : SlideTransition(
                        key: ValueKey(_currentIndex),
                        position: _isTransitioning ? _exitSlideAnimation : _questionSlideAnimation,
                        child: FadeTransition(
                          opacity: _isTransitioning ? ReverseAnimation(_exitController) : _questionController,
                          child: Card(
                            elevation: 8,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                            child: Padding(
                              padding: const EdgeInsets.all(24),
                              child: Text(
                                question['question'] ?? "Question?",
                                style: GoogleFonts.poppins(fontSize: 20, fontWeight: FontWeight.w600),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(height: 30),
                    Expanded(
                      child: AnimatedSwitcher(
                        duration: const Duration(milliseconds: 300),
                        child: _isTransitioning
                            ? const SizedBox.shrink()
                            : FadeTransition(
                          key: ValueKey('options_$_currentIndex'),
                          opacity: _optionsFadeAnimation,
                          child: ListView(
                            padding: EdgeInsets.zero,
                            children: [
                              _buildOptionButton(0, question['option1'] ?? ''),
                              _buildOptionButton(1, question['option2'] ?? ''),
                              _buildOptionButton(2, question['option3'] ?? ''),
                              _buildOptionButton(3, question['option4'] ?? ''),
                            ],
                          ),
                        ),
                      ),
                    ),
                    if (!_isSubmitting) ...[
                      const SizedBox(height: 12),
                      SafeArea(
                        top: false,
                        child: Padding(
                          padding: const EdgeInsets.only(bottom: 12),
                          child: _buildNavigation(),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              _buildQuestionPalette(),
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\widgets\exam_select_dialog.dart =====

// lib/widgets/exam_select_dialog.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:shimmer/shimmer.dart';

import '../core/services/api_service.dart';
import '../core/utils/user_preferences.dart';
import '../providers/exam_provider.dart';
import '../providers/user_provider.dart';
import '../models/user_model.dart'; // â† NEW: Needed for UserModel type

Future<bool?> showExamSelectDialog(BuildContext context) {
  return showGeneralDialog<bool>(
    context: context,
    barrierDismissible: false,
    barrierColor: Colors.black.withOpacity(0.6),
    transitionDuration: const Duration(milliseconds: 300),
    transitionBuilder: (context, animation, secondaryAnimation, child) {
      return ScaleTransition(
        scale: CurvedAnimation(parent: animation, curve: Curves.easeOutBack),
        child: FadeTransition(opacity: animation, child: child),
      );
    },
    pageBuilder: (context, _, __) {
      return const _ExamSelectDialogContent();
    },
  );
}

class _ExamSelectDialogContent extends ConsumerStatefulWidget {
  const _ExamSelectDialogContent();

  @override
  ConsumerState<_ExamSelectDialogContent> createState() => _ExamSelectDialogContentState();
}

class _ExamSelectDialogContentState extends ConsumerState<_ExamSelectDialogContent> {
  late Set<int> _selectedExamIds; // â† Will be initialized in initState

  @override
  void initState() {
    super.initState();
    _selectedExamIds = {}; // Initial empty set

    // ðŸ”¥ STEP 3: Pre-populate selected exams from UserModel + SharedPreferences fallback
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      final userAsync = ref.read(currentUserProvider);
      if (userAsync.asData == null) return;

      final UserModel? user = userAsync.value;
      if (user == null) return;

      // Primary source: UserModel.examIds
      Set<int> initialIds = Set.from(user.examIds);

      // Fallback: If UserModel is missing exams, load from SharedPreferences
      if (initialIds.isEmpty) {
        final prefs = UserPreferences();
        final storedExams = await prefs.getExams();
        initialIds = Set.from(storedExams);
      }

      // Apply to UI if still mounted
      if (mounted) {
        setState(() {
          _selectedExamIds = initialIds;
        });
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final examsAsync = ref.watch(examsProvider);
    final userAsync = ref.watch(currentUserProvider);

    return Center(
      child: Material(
        borderRadius: BorderRadius.circular(24),
        elevation: 20,
        child: Container(
          width: MediaQuery.of(context).size.width * 0.85,
          constraints: const BoxConstraints(maxHeight: 600),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(24),
          ),
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Select Exams (Max 4)',
                style: GoogleFonts.poppins(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: const Color(0xFF6C5CE7),
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
              Text(
                'Choose up to 4 exams you are preparing for',
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey[600],
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 20),
              Flexible(
                child: examsAsync.when(
                  loading: () => _buildShimmerGrid(),
                  error: (err, stack) => Center(
                    child: Text(
                      'Failed to load exams',
                      style: GoogleFonts.poppins(color: Colors.red),
                    ),
                  ),
                  data: (exams) {
                    if (exams.isEmpty) {
                      return Center(
                        child: Text(
                          'No exams available',
                          style: GoogleFonts.poppins(),
                        ),
                      );
                    }
                    return SingleChildScrollView(
                      child: Wrap(
                        spacing: 12,
                        runSpacing: 12,
                        alignment: WrapAlignment.center,
                        children: exams.map((exam) {
                          final id = exam['id'] as int;
                          final name = exam['name'] as String;
                          final isSelected = _selectedExamIds.contains(id);

                          return FilterChip(
                            label: Text(
                              name,
                              style: GoogleFonts.poppins(fontSize: 14),
                            ),
                            selected: isSelected,
                            onSelected: _selectedExamIds.length >= 4 && !isSelected
                                ? null
                                : (selected) {
                              setState(() {
                                if (selected) {
                                  _selectedExamIds.add(id);
                                } else {
                                  _selectedExamIds.remove(id);
                                }
                              });
                            },
                            selectedColor: const Color(0xFF6C5CE7).withOpacity(0.2),
                            checkmarkColor: const Color(0xFF6C5CE7),
                            backgroundColor: Colors.grey[200],
                            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                            labelPadding: const EdgeInsets.symmetric(horizontal: 8),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(30),
                              side: BorderSide(
                                color: isSelected ? const Color(0xFF6C5CE7) : Colors.transparent,
                                width: 2,
                              ),
                            ),
                          );
                        }).toList(),
                      ),
                    );
                  },
                ),
              ),
              const SizedBox(height: 16),
              Text(
                '${_selectedExamIds.length}/4 selected',
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: _selectedExamIds.length >= 4 ? Colors.orange : Colors.grey[600],
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _selectedExamIds.isEmpty
                      ? null
                      : () async {
                    final user = userAsync.value;
                    if (user == null) {
                      Navigator.pop(context, false);
                      return;
                    }

                    try {
                      final api = ref.read(apiServiceProvider);
                      await api.updateUserExams(user.id, _selectedExamIds.toList());

                      final prefs = UserPreferences();
                      await prefs.saveExams(_selectedExamIds.toList());

                      // ðŸ”¥ Force refresh currentUserProvider so UI updates instantly everywhere
                      ref.invalidate(currentUserProvider);

                      if (mounted) Navigator.pop(context, true);
                    } catch (e) {
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(content: Text('Failed to save exams: $e')),
                        );
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF6C5CE7),
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  child: Text(
                    'Confirm Exams',
                    style: GoogleFonts.poppins(
                      color: Colors.white,
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildShimmerGrid() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[300]!,
      highlightColor: Colors.grey[100]!,
      child: Wrap(
        spacing: 12,
        runSpacing: 12,
        children: List.generate(8, (_) => Container(
          width: 140,
          height: 44,
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(30),
          ),
        )),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\widgets\language_select_dialog.dart =====

// lib/widgets/language_select_dialog.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:shimmer/shimmer.dart';

import '../core/services/api_service.dart';
import '../core/utils/user_preferences.dart';
import '../providers/language_provider.dart';
import '../providers/user_provider.dart';
import '../models/user_model.dart'; // â† NEW: Needed for UserModel type

Future<bool?> showLanguageSelectDialog(BuildContext context) {
  return showGeneralDialog<bool>(
    context: context,
    barrierDismissible: false,
    barrierColor: Colors.black.withOpacity(0.6),
    transitionDuration: const Duration(milliseconds: 300),
    transitionBuilder: (context, animation, secondaryAnimation, child) {
      return ScaleTransition(
        scale: CurvedAnimation(parent: animation, curve: Curves.easeOutBack),
        child: FadeTransition(opacity: animation, child: child),
      );
    },
    pageBuilder: (context, _, __) {
      return const _LanguageSelectDialogContent();
    },
  );
}

class _LanguageSelectDialogContent extends ConsumerStatefulWidget {
  const _LanguageSelectDialogContent();

  @override
  ConsumerState<_LanguageSelectDialogContent> createState() => _LanguageSelectDialogContentState();
}

class _LanguageSelectDialogContentState extends ConsumerState<_LanguageSelectDialogContent> {
  int? _selectedLanguageId;

  @override
  void initState() {
    super.initState();

    // ðŸ”¥ STEP 3: Pre-populate selected language from UserModel + SharedPreferences fallback
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      final userAsync = ref.read(currentUserProvider);
      if (userAsync.asData == null) return;

      final UserModel? user = userAsync.value;
      if (user == null) return;

      // Primary source: UserModel.languageId
      int? initialId = user.languageId;

      // Fallback: If UserModel is missing language, load from SharedPreferences
      if (initialId == null) {
        final prefs = UserPreferences();
        final storedLanguage = await prefs.getLanguage();
        initialId = storedLanguage;
      }

      // Apply to UI if still mounted
      if (mounted) {
        setState(() {
          _selectedLanguageId = initialId;
        });
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final languagesAsync = ref.watch(languagesProvider);
    final userAsync = ref.watch(currentUserProvider);

    return Center(
      child: Material(
        borderRadius: BorderRadius.circular(24),
        elevation: 20,
        child: Container(
          width: MediaQuery.of(context).size.width * 0.85,
          constraints: const BoxConstraints(maxHeight: 600),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(24),
          ),
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Select Your Language',
                style: GoogleFonts.poppins(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: const Color(0xFF6C5CE7),
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 20),
              Flexible(
                child: languagesAsync.when(
                  loading: () => _buildShimmerList(),
                  error: (err, stack) => Center(
                    child: Text(
                      'Failed to load languages',
                      style: GoogleFonts.poppins(color: Colors.red),
                    ),
                  ),
                  data: (languages) {
                    if (languages.isEmpty) {
                      return Center(
                        child: Text(
                          'No languages available',
                          style: GoogleFonts.poppins(),
                        ),
                      );
                    }
                    return ListView.builder(
                      shrinkWrap: true,
                      itemCount: languages.length,
                      itemBuilder: (context, index) {
                        final lang = languages[index];
                        final id = lang['id'] as int;
                        final name = lang['language_name'] as String;

                        return RadioListTile<int>(
                          value: id,
                          groupValue: _selectedLanguageId,
                          onChanged: (value) {
                            setState(() {
                              _selectedLanguageId = value;
                            });
                          },
                          title: Text(
                            name,
                            style: GoogleFonts.poppins(fontSize: 16),
                          ),
                          activeColor: const Color(0xFF6C5CE7),
                          dense: true,
                        );
                      },
                    );
                  },
                ),
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _selectedLanguageId == null
                      ? null
                      : () async {
                    final user = userAsync.value;
                    if (user == null) {
                      Navigator.pop(context, false);
                      return;
                    }

                    try {
                      final api = ref.read(apiServiceProvider);
                      await api.updateUserLanguage(user.id, _selectedLanguageId!);

                      final prefs = UserPreferences();
                      await prefs.saveLanguage(_selectedLanguageId!);

                      // ðŸ”¥ Force refresh currentUserProvider so UI updates instantly everywhere
                      ref.invalidate(currentUserProvider);

                      if (mounted) Navigator.pop(context, true);
                    } catch (e) {
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(content: Text('Failed to save language: $e')),
                        );
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF6C5CE7),
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  child: Text(
                    'Confirm Language',
                    style: GoogleFonts.poppins(
                      color: Colors.white,
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildShimmerList() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[300]!,
      highlightColor: Colors.grey[100]!,
      child: ListView.builder(
        shrinkWrap: true,
        itemCount: 8,
        itemBuilder: (context, index) => Padding(
          padding: const EdgeInsets.symmetric(vertical: 8),
          child: Row(
            children: [
              Container(width: 24, height: 24, color: Colors.white),
              const SizedBox(width: 16),
              Expanded(child: Container(height: 16, color: Colors.white)),
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: D:\MyAndroidProjects2025\PrepKing\lib\widgets\profile_menu_tile.dart =====

// lib/widgets/profile_menu_tile.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class ProfileMenuTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final Widget? trailing;
  final VoidCallback onTap;

  const ProfileMenuTile({
    super.key,
    required this.icon,
    required this.title,
    this.trailing,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: Icon(icon, color: const Color(0xFF6C5CE7), size: 28),
      title: Text(
        title,
        style: GoogleFonts.poppins(
          fontSize: 16,
          fontWeight: FontWeight.w500,
        ),
      ),
      trailing: trailing ?? const Icon(Icons.chevron_right, color: Colors.grey),
      onTap: onTap,
      contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 4),
    );
  }
}



